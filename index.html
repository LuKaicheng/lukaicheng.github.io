<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Lucifer"><meta name="description"><title>羽逝神伤</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="https://lukaicheng.github.io/"><link rel="alternate" href="/atom.xml" title="羽逝神伤"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">羽逝神伤</a><ul class="nav"><li class="nav-link"><a href="/" class="active">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li></ul></header><section id="container"><ul class="home"><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/07/23/Comprehend-volatile/" class="post-link">Java并发基础--理解volatile</a></h2><span class="post-time">Jul 23, 2017</span><div class="post-content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>众所周知，Java语言是通过共享内存的方式，来实现多线程之间的通信行为。为了保证共享变量的值能在不同线程之间得到一致地更新，可以考虑使用<code>synchronized</code>来确保共享变量的可见性。除此之外，Java语言还提供了另一种机制：<code>volatile</code>。使用<code>volatile</code>同样也提供对共享变量内存可见性的保证，并且它的运行时开销相比<code>sychronized</code>会更少，这种行为是由Java内存模型所确保的。下面就以<code>volatile</code>为中心，梳理并总结一下对内存可见性、重排序、Java内存模型、happens-before规则、内存屏障等一系列概念的理解。</p></div><a href="/2017/07/23/Comprehend-volatile/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/07/19/ThreadPoolExecutor-summary/" class="post-link">Java线程池总结</a></h2><span class="post-time">Jul 19, 2017</span><div class="post-content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>java.util.concurrent.ThreadPoolExecutor</code>是JDK提供的一个线程池实现，在实际项目中是最 常用的JUC组件之一。通过合理使用线程池，可以复用已创建的线程，这不仅能够降低创建和销毁线程的整体消耗，还能够更快速地响应任务，并且通过线程池统一分配、管理、监控，也可以避免无限制地创建线程而造成的系统故障。</p></div><a href="/2017/07/19/ThreadPoolExecutor-summary/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/06/30/CGlib-tutorial-translate/" class="post-link">CGlib教程[译]</a></h2><span class="post-time">Jun 30, 2017</span><div class="post-content"><p><a href="https://github.com/cglib/cglib/wiki/Tutorial">原文链接</a></p>
<p>原始文章：<a href="http://mydailyjava.blogspot.no/2013/11/cglib-missing-manual.html">http://mydailyjava.blogspot.no/2013/11/cglib-missing-manual.html</a></p>
<h2 id="增强器"><a href="#增强器" class="headerlink" title="增强器"></a>增强器</h2><p>让我们从<code>Enhancer</code>类开始，这可能是cglib库中最常被使用的类。一个增强器允许为没有接口的类型创建一个Java代理。<code>Enhancer</code>可以与java标准库的<code>Proxy</code>类做对比，后者是在Java 1.3时引入的。<code>Enhancer</code>动态地创建给定类型的子类而拦截所有的方法调用。与<code>Proxy</code>类不同的是，它对于类和接口都适用。接下来的例子和后续的一些例子都是基于这个简单的Java POJO：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String input)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello world!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><a href="/2017/06/30/CGlib-tutorial-translate/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/06/25/Delay-task-practice/" class="post-link">延迟任务实践总结</a></h2><span class="post-time">Jun 25, 2017</span><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在实际开发项目过程中，可能会碰到类似这样的需求：期望一个任务不是马上执行，而是可以在给定的时间段之后才执行，通常这被称为<strong>延迟任务</strong>。解决这个问题的方案已经有不少，最直接的是采用定时任务的方式扫描数据库，或者考虑使用时间轮算法，或者基于RabbitMQ来实现延迟队列。最近我在项目中就碰到了同样的问题：当新内容添加到系统时，会带有一个过期时间，一旦到达此过期时间，那么需要自动下架该内容。对于此问题，在实际项目演变过程中我采用了与上述不同的两种方式来解决。</p></div><a href="/2017/06/25/Delay-task-practice/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/06/24/Java-serialization-mechanism/" class="post-link">Java序列化机制总结</a></h2><span class="post-time">Jun 24, 2017</span><div class="post-content"><h2 id="序列化缘由"><a href="#序列化缘由" class="headerlink" title="序列化缘由"></a>序列化缘由</h2><p>在实际的程序运行过程中，总会有这样的场景：程序可以将本次运行的某些对象或者状态保存下来，以供下次启动时使用；在一个联网环境里，不同节点之间的系统需要进行通信，发送者要将某些对象发送到远程的接收者从而达到沟通协调的目的。序列化正是缘于这些场景而出现的一种技术概念，为了能够序列化Java平台的对象，JDK从很早的版本开始就提供了一种序列化机制，它可以将对象编码成字节流(<em>序列化</em>)，也可以反向从字节流编码中重新构建对象(<em>反序列化</em>)，以用于支持RMI和JavaBean。</p></div><a href="/2017/06/24/Java-serialization-mechanism/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/06/09/TagBasedStatistics/" class="post-link">基于标签的人群统计实现分析</a></h2><span class="post-time">Jun 9, 2017</span><div class="post-content"><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>最近在做项目过程中，碰到了这样一个需求：当前台页面勾选偏好标签的时候，后端服务需要快速给出标签对应的人群数量。如果仅仅只是单个标签的话，那么问题是非常简单的，然而现实是残酷的，我必须考虑基于多个标签勾选的交并集统计情况。</p>
<p>在此，先做一个假设，每个标签后面对应的人群数量是一百万，当然有可能人群会有重叠，而后续的讨论都是基于此数量级展开。</p></div><a href="/2017/06/09/TagBasedStatistics/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/05/15/Spring-BeanPostProcessor/" class="post-link">Spring基础 - BeanPostProcessor</a></h2><span class="post-time">May 15, 2017</span><div class="post-content"><h1 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h1><p><strong>BeanPostProcessor</strong>是Spring提供的一个钩子(<em>Hook</em>)接口，可用于实现对新的bean实例进行自定义修改，比如说，检测bean是否实现了某些特定接口从而可以对其进行进一步操作，或者可以将原实例进行包装而实际返回代理对象。其内部主要声明了<em>postProcessBeforeInitialization</em>和<em>postProcessAfterInitialization</em>两个回调方法，具体的接口声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line">  	<span class="comment">//在bean进行初始化行为之前被调用</span></div><div class="line">	<span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">  	<span class="comment">//在bean进行初始化行为之后被调用</span></div><div class="line">	<span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是这里所说的bean初始化行为主要是指调用<strong>InitializingBean</strong>的<em>afterPropertiesSet</em>或者一个自定义的<em>init-method</em>。</p></div><a href="/2017/05/15/Spring-BeanPostProcessor/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/05/13/Spring5-validation-translate/" class="post-link">Spring 5 验证、数据绑定和类型转换[译]</a></h2><span class="post-time">May 13, 2017</span><div class="post-content"><p>发布于并发编程网，文章<a href="http://ifeve.com/spring-5-validation/">链接</a></p>
<h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><blockquote>
<p>JSR-303/JSR-349 Bean Validation</p>
<p>在设置支持方面，Spring Framework 4.0支持Bean Validation 1.0(JSR-303)和Bean Validation 1.1(JSR-349)，也将其改写成了Spring的<code>Validator</code>接口。</p>
<p>正如<a href="#5.8 Spring Validation">5.8 Spring验证</a>所述，应用程序可以选择一次性全局启用Bean验证，并使其专门用于所有的验证需求。</p>
<p>正如<a href="#5.8.3 Configuring a DataBinder">5.8.3 配置DataBinder</a>所述，应用程序也可以为每个<code>DataBinder</code>实例注册额外的Spring <code>Validator</code>实例，这可能有助于不通过使用注解而插入验证逻辑。</p>
</blockquote></div><a href="/2017/05/13/Spring5-validation-translate/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/11/17/Reading-JDK-ArrayList/" class="post-link">JDK源码阅读总结--ArrayList</a></h2><span class="post-time">Nov 17, 2016</span><div class="post-content"><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<p>ArrayList是List接口的一种可变长的数组实现，支持随机访问，它允许添加包括<strong>null</strong>在内的所有元素。另外，ArrayList的实现并不是线程安全的，如果有多个线程访问，且其中至少一个会涉及<strong>结构性修改</strong>，最好采用并发控制策略，或者采用<em>Collections.synchronizedList</em>进行包装，防止意外的非同步访问。以下所述基于JDK1.7.0_79源码。</p></div><a href="/2016/11/17/Reading-JDK-ArrayList/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/11/02/ABNF/" class="post-link">ABNF应知应会</a></h2><span class="post-time">Nov 2, 2016</span><div class="post-content"><p>ABNF英文全称是Augmented Backus-Naur Form，这是一种基于BNF的元语言，在很多的Internet technical Specification中用于定义正式语法。</p></div><a href="/2016/11/02/ABNF/" class="read-more">Read more..</a></article></li></ul><div class="paginator"><a href="/page/2/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div></section><footer><div class="social"><a href="mailto:lukc1986@gmail.com" title="email" class="iconfont icon-email"></a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2017<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Lucifer</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>