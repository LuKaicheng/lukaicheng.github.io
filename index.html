<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Lucifer"><meta name="description"><title>羽逝神伤</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="https://lukaicheng.github.io/"><link rel="alternate" href="/atom.xml" title="羽逝神伤"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">羽逝神伤</a><ul class="nav"><li class="nav-link"><a href="/" class="active">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li></ul></header><section id="container"><ul class="home"><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/11/17/Reading-JDK-ArrayList/" class="post-link">JDK源码阅读--ArrayList</a></h2><span class="post-time">Nov 17, 2016</span><div class="post-content"><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>ArrayList是List接口的一种可增长数组实现。<br>以下基于JDK1.7.0_79。</p>
<h2 id="2-基本属性"><a href="#2-基本属性" class="headerlink" title="2 基本属性"></a>2 基本属性</h2><h3 id="2-1-elementData"><a href="#2-1-elementData" class="headerlink" title="2.1 elementData"></a>2.1 elementData</h3><p><strong>elementData</strong>属性是实际存储列表元素的数组缓存区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>
<p>尽管从声明上看它是数组类型，然而它的长度却并不固定，这里的意思并不说是可以在数组创建之后再改变它的大小，而是指当进行容量评估时，如果发现需要扩容或者收缩时，那么会重新创建一个数组并伴随一次拷贝，然后将<strong>elementData</strong>指向新数组，从而达到扩容或者收缩的目的。</p>
<h3 id="2-2-size"><a href="#2-2-size" class="headerlink" title="2.2 size"></a>2.2 size</h3><p><strong>size</strong>属性就是列表实际所包含的元素个数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure></p>
<p>这是因为一般情况下，<strong>elementData</strong>数组并不会被完全占满，所以无法用数组长度等价于元素个数，而又需要有一种机制能够快速反馈元素个数，因此设置了<strong>size</strong>属性来缓存这个信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>size()</strong>方法和<strong>isEmpty()</strong>方法就是通过它才保证调用只需花费常数时间。</p>
<h2 id="3-容量调整"><a href="#3-容量调整" class="headerlink" title="3 容量调整"></a>3 容量调整</h2><h3 id="3-1-扩容"><a href="#3-1-扩容" class="headerlink" title="3.1 扩容"></a>3.1 扩容</h3><p>在新版本JDK中，ArrayList不仅像之前一样拥有私有的动态扩容方法，同时还对外提供了公有方法供调用者主动进行扩容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY,minCapacity);</div><div class="line">    &#125;</div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上所示，<strong>ensureCapacity()</strong>是供外部主动扩容调用的方法，<strong>ensureCapacityInternal()</strong>是供内部扩容调用的方法。这两个方法都是先预估出所需的最小容量，进而通过调用私有方法<strong>ensureExplicitCapacity()</strong>来保证这个容量需求得以满足。接下来看一下这个方法的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span>(minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//扩容到1.5倍</span></div><div class="line">    <span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span>(newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) <span class="comment">//overflow处理</span></div><div class="line">	    newCapacity = hugeCapacity(minCapacity);</div><div class="line">    elementData = Arrays.copyOf(elementData,newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(minCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? </div><div class="line">        Integer.MAX_VALUE : </div><div class="line">        MAX_ARRAY_SIZE; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ensureExplicitCapacity()</strong>方法会首先判定所需的最小容量是否超过当前数组长度，只有在肯定的情况下，才会调用<strong>grow()</strong>方法。观察10-11行代码，JDK会默认将原先的数组长度扩充到1.5倍，接着12-13行代码，新容量会同最小容量比较，如果新容量小于最小容量，那么将会把新容量赋值为最小容量。而代码14-15行，则是考虑到了容量扩充到1.5倍时可能发生的int值溢出并进行相应处理。最后16行才是真正的进行新数组创建，旧数组元素拷贝的过程。</p>
<h3 id="3-2-收缩"><a href="#3-2-收缩" class="headerlink" title="3.2 收缩"></a>3.2 收缩</h3><p>由于列表在增加元素的时候会进行隐式扩容，从而导致底层数组容量往往超过实际所包含的元素，如果碰到资源敏感的场景下，那么可以使用<strong>trimToSize()</strong>方法进行收缩，使得底层数组容量和实际元素个数持平。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span></span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span>(size &lt; elementData.length)&#123;</div><div class="line">        elementData = Arrays.copyOf(elementData,size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-异常检测"><a href="#4-异常检测" class="headerlink" title="4 异常检测"></a>4 异常检测</h2><h3 id="4-1-rangeCheck"><a href="#4-1-rangeCheck" class="headerlink" title="4.1 rangeCheck"></a>4.1 rangeCheck</h3><p>针对索引范围的检查，ArrayList提供了两个版本的方法：<strong>rangeCheck()</strong>和<strong>rangeCheckForAdd()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index &gt;= size)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>rangeCheck()</strong>主要是针对get()、set()、remove()方法进行索引检测，注意到上面代码并没有对index为负的情况进行检测，这是因为紧跟本方法调用的是对底层数组的访问，而后者会直接检测索引为负的情况，但另外一方面由于隐式扩容的缘故，底层数组包含的实际元素个数往往小于数组长度，因此针对索引超出的情况只能在本方法里判定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>顾名思义，<strong>rangeCheckForAdd()</strong>方法在运行时会被add()、addAll()所调用。相比<strong>rangeCheck()</strong>方法，由于后续不是紧跟对底层数组的访问，因此增加了对于索引为负的情况的判定，同时因为允许元素可以末端添加，去掉了index = size这种情况。</p>
<h3 id="4-2-modCount"><a href="#4-2-modCount" class="headerlink" title="4.2 modCount"></a>4.2 modCount</h3><p><strong>modCount</strong>是ArrayList从父类AbstractList从继承过来的属性，这个属性用于记录列表经历的结构性修改的次数，主要被迭代器(<a href="#51-iterator">iterator</a>和<a href="#52-listiterator">listIterator</a>)使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>迭代器借助于它可以提供fast-fail行为，即当迭代器进行迭代时，如果检测它的值被意外修改，可以抛出ConcurrentModificationException异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount) <span class="comment">//与预期不符合，抛出异常</span></div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5 迭代器"></a>5 迭代器</h2><h3 id="5-1-iterator"><a href="#5-1-iterator" class="headerlink" title="5.1 iterator"></a><span id="51-iterator">5.1 iterator</span></h3><p>ArrayList声明了内部类<strong>Itr</strong>实现了Iterator接口,通过方法<strong>iterator()</strong>对外提供该迭代器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Itr</strong>在内部定义了三个属性：<strong>cursor</strong>用于表示下一个元素的索引，默认初始为0；<strong>lastRet</strong>用于表示上一个返回元素的索引，初始为-1；<strong>expectedModCount</strong>用于表示期望的修改次数，初始为迭代器实例化时外部列表的modCount值。对于<strong>hasNext()</strong>方法，只要判定<strong>cursor</strong>是否已经和当前列表的<strong>size</strong>相同，即可判定是否还存在下一个元素。对于<strong>next()</strong>方法，由于已经知道需要返回的元素的索引(cursor)，那么可以直接通过数组索引访问获取元素，当然对于索引的校验以及列表的结构修改检测也是必须的，且同时需要更新cursor和lastRet。下面主要详细看下<strong>remove()</strong>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">    checkForComodification();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</div><div class="line">        cursor = lastRet;</div><div class="line">        lastRet = -<span class="number">1</span>;</div><div class="line">        expectedModCount = modCount;</div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第7行调用外部对应的remove方法，可不仅仅只是删除了上一个返回的元素，还做了另外两件事情：一、将被删除元素之后的元素统一进行了前移；二、将modCount进行了+1操作。因此，可以看到代码第8行，cursor的值被赋予上一次返回的索引位置，这是因为下个元素被前移的缘故。第9行将lastRet重新赋值为-1，结合代码第2、3行，保证只有再次调用next之后，才能重新调用remove。最后第10行，将expetedModCount重新赋值为列表的modCount，这是由于上述第二个副作用的缘由，如果不重新赋值，将无法通过下一次的checkForComodification检测。</p>
<h3 id="5-2-listIterator"><a href="#5-2-listIterator" class="headerlink" title="5.2 listIterator"></a><span id="52-listiterator">5.2 listIterator</span></h3><p>除了一般版本的迭代器，ArrayList还提供了listIterator，与一般版本相比，不仅可以往后进行迭代，还可以向前迭代。外部可以通过<strong>listIterator()</strong>方法获取该迭代器，该方法返回<strong>ListItr</strong>内部类的一个实例，<strong>ListItr</strong>继承关系如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>由于<strong>List</strong>继承了<strong>Itr</strong>，在<strong>hasNext()、next()、remove()</strong>这几个方法的实现上，并未改变父类中的行为，仅仅实现了<strong>hasPrevious()、previous()、nextIndex()、previousIndex()、set()、add()</strong>。<strong>nextIndex()</strong>和<strong>previousIndex()</strong>由于cursor属性的存在，实现比较简单。<strong>hasPrevious()</strong>方法同next实现类似，只不过这次是需要判定cursor是否同0相同。</p>
<p><strong>未完待续…</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://stackoverflow.com/questions/38950203/why-does-arraylistrangecheck-not-check-if-the-index-is-negative" target="_blank" rel="external">why-does-arraylistrangecheck-not-check-if-the-index-is-negative</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/11/02/ABNF/" class="post-link">ABNF应知应会</a></h2><span class="post-time">Nov 2, 2016</span><div class="post-content"><p>ABNF英文全称是Augmented Backus-Naur Form，这是一种基于BNF的元语言，在很多的Internet technical Specification中用于定义正式语法。</p>
<h2 id="1-规则定义"><a href="#1-规则定义" class="headerlink" title="1 规则定义"></a>1 规则定义</h2><h3 id="1-1-规则形式"><a href="#1-1-规则形式" class="headerlink" title="1.1 规则形式"></a>1.1 规则形式</h3><p>规则定义的形式如下所示</p>
<blockquote>
<p>name = elements crlf</p>
</blockquote>
<p>其中</p>
<ul>
<li>name 表示规则名称，对于它的解释可以参考<a href="#12-规则名称">1.2 规则名称</a>，</li>
<li>elements 可以是一个或者多个规则或者最终值的操作组合，关于最终值可以参考<a href="#13-最终值">1.3 最终值</a></li>
<li>crlf 行结束标志(回车换行)</li>
</ul>
<p>为了视觉效果，规则定义需要左对齐，如果碰上一个规则需要多行的情况，那么接下来的行需要缩进，而它们对齐和缩进的基准是ABNF规则的第一行。</p>
<h3 id="1-2-规则名称"><a href="#1-2-规则名称" class="headerlink" title="1.2 规则名称"></a><span id="12-规则名称">1.2 规则名称</span></h3><p>规则名称由字母开头，后续可以包含字母、数字和连字符(减号)组合的序列,其中需要注意的是规则名称<strong>不区分大小写</strong>。而且不像BNF，用尖括号(<strong>&lt;</strong>，<strong>&gt;</strong>)包围规则名称并不是必需的。</p>
<h3 id="1-3-最终值"><a href="#1-3-最终值" class="headerlink" title="1.3 最终值"></a><span id="13-最终值">1.3 最终值</span></h3><p>所有规则最终都会由最终值来解释，而所谓的最终值是由一个指定的基数再结合一个或者多个数值字符来指定。当前已经定义的基数有三种：</p>
<ul>
<li>b： 二进制 binary</li>
<li>d： 十进制 decimal</li>
<li>x： 十六进制 hexadecimal</li>
</ul>
<p>以回车CR为例，下面的规则分别采用十进制和十六进制为基数</p>
<blockquote>
<p>CR = %d13</p>
<p>CR = %x0D</p>
</blockquote>
<p>当碰到需要表示多个字符时，可以用<strong>“.”</strong>来进行串联</p>
<blockquote>
<p>false = %x66.61.6c.73.65</p>
</blockquote>
<p>同时ABNF也允许使用双引号来直接说明文字文本</p>
<blockquote>
<p>command = “pwd”</p>
</blockquote>
<p>但是需要注意的是，这里字符串是大小写不敏感，且使用的字符集是US-ASCII。因此上面的字符串会匹配”pwd”,”Pwd”,”pWd”,”pwD”,”PWd”,”pWD”,”PwD”和”PWD”。如果我们需要字符串具备大小写敏感特性，那么可以分别指定每个字符，有下面两种方式:</p>
<blockquote>
<p>command = %d112.119.100</p>
<p>command = %d112 %d119 %d109</p>
</blockquote>
<h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h2><h3 id="2-1-级联-R1-R2"><a href="#2-1-级联-R1-R2" class="headerlink" title="2.1 级联 R1 R2"></a>2.1 级联 R1 R2</h3><p>可以将已经定义的规则和最终值按顺序列出来，元素之间用空白字符来进行区分。</p>
<blockquote>
<p>foo = %x61</p>
<p>bar = %x62</p>
<p>mumble = foo bar foo</p>
</blockquote>
<p>在上面的示例里规则foo匹配a，bar匹配b，mumble将匹配aba。</p>
<h3 id="2-2-选择-R1-R2"><a href="#2-2-选择-R1-R2" class="headerlink" title="2.2 选择 R1 / R2"></a>2.2 选择 R1 / R2</h3><p>可以通过在规则之间插入/，让规则变成可选。</p>
<blockquote>
<p>ws = %x20 / %x09 / %x0A / %x0D</p>
</blockquote>
<p>在上面的示例里，规则ws会匹配空格、制表符、换行、回车。</p>
<h3 id="2-3-增量选择-R1-R2"><a href="#2-3-增量选择-R1-R2" class="headerlink" title="2.3 增量选择 R1 =/ R2"></a>2.3 增量选择 R1 =/ R2</h3><p>有时候，我们可能希望有一种增量的方式，可以在旧规则里添加新的功能可选项，这个时候增量选择就比较适用，它通过<strong>=/</strong>来将新规则变成旧规则的可选项之一。</p>
<blockquote>
<p>ruleset = alt1 / alt2</p>
<p>ruleset =/ alt3</p>
<p>ruleset =/ alt4 / alt5</p>
</blockquote>
<p>最终ruleset等价于下面所示：</p>
<blockquote>
<p>ruleset = alt1 / alt2 / alt3 / alt4 / alt5</p>
</blockquote>
<h3 id="2-4-值范围"><a href="#2-4-值范围" class="headerlink" title="2.4 值范围"></a>2.4 值范围</h3><p>通过使用连字符(-),ABNF还可以实现指定一个范围的值。</p>
<blockquote>
<p>DIGIT = %x30-39</p>
</blockquote>
<p>上面的示例规则，实际上等价于下面的规则</p>
<blockquote>
<p>DIGIT = “0” / “1” / “2” / “3” / “4” / “5” / “6” / “7” / “8” / “9”</p>
</blockquote>
<h3 id="2-5-序列组合-R1-R2"><a href="#2-5-序列组合-R1-R2" class="headerlink" title="2.5 序列组合 (R1 R2)"></a>2.5 序列组合 (R1 R2)</h3><p>用括号将连个规则包围起来，这样的组合会被当成单个元素，对于一些优先级比较容易混淆的情况尤其推荐使用它。</p>
<blockquote>
<p>group = elem (foo / bar) blat</p>
</blockquote>
<p>上面的示例会匹配 elem foo blat 或者 elem bar blat，但是如果我们不使用括号的话</p>
<blockquote>
<p>group = elem foo / bar blat</p>
</blockquote>
<p>由于操作符优先级的关系，其实group会匹配elem foo或bar blat。</p>
<h3 id="2-6-不定量重复-Rule"><a href="#2-6-不定量重复-Rule" class="headerlink" title="2.6 不定量重复 *Rule"></a>2.6 不定量重复 *Rule</h3><p>我们可以在规则的前面添加*，来表示重复这个规则，完整的形式是m*nRule。其中m和n都是可选的，m表示至少重复多少次，n表示最多重复多少次。两者默认的值分别是0和无穷大，所以*Rule表示允许任意次数的重复包括零次。1*Rule表示规则至少重复一次，1*2Rule表示规则重复一次或两次,3*3Rule表示规则必须且仅允许重复3次。</p>
<h3 id="2-7-定量重复-nRule"><a href="#2-7-定量重复-nRule" class="headerlink" title="2.7 定量重复 nRule"></a>2.7 定量重复 nRule</h3><p>除了不定量重复之外，ABNF也允许指定次数的重复，完整形式是nRule，其实等价于n*nRule。运用这个方式，2DIGIT就表示2位数字，3ALPHA表示长度为3的字符串。</p>
<h3 id="2-8-可选序列-Rule"><a href="#2-8-可选序列-Rule" class="headerlink" title="2.8 可选序列 [Rule]"></a>2.8 可选序列 [Rule]</h3><p>可以使用方括号来圈定一个可选序列</p>
<blockquote>
<p>rule = [foo bar]</p>
</blockquote>
<p>等价于</p>
<blockquote>
<p>rule = *1(foo bar)</p>
</blockquote>
<h3 id="2-9-注释"><a href="#2-9-注释" class="headerlink" title="2.9 注释"></a>2.9 注释</h3><p>对于规则的说明，也提供了注释方式，以分号<strong>;</strong>开始，并到此行的结束。</p>
<blockquote>
<p>false = %x66.61.6c.73.65   ; false</p>
</blockquote>
<h2 id="3-操作优先级"><a href="#3-操作优先级" class="headerlink" title="3.操作优先级"></a>3.操作优先级</h2><p>以下给出了从高(结合最紧密)到低(结合最松散)的优先级:</p>
<ol>
<li>规则名、最终值</li>
<li>注释</li>
<li>值范围</li>
<li>重复</li>
<li>序列组合、可选序列</li>
<li>级联</li>
<li>选择</li>
</ol>
<p>由于级联和选择混用时，往往会让人困惑，建议使用序列组合来消除歧义。</p>
<h2 id="4-核心规则"><a href="#4-核心规则" class="headerlink" title="4.核心规则"></a>4.核心规则</h2><table>
<thead>
<tr>
<th style="text-align:left">规则</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ALPHA</td>
<td style="text-align:left">%x41-5A / %x61-7A</td>
<td style="text-align:left">A-Z / a-z</td>
</tr>
<tr>
<td style="text-align:left">BIT</td>
<td style="text-align:left">“0” / “1”</td>
<td style="text-align:left">二进制字符</td>
</tr>
<tr>
<td style="text-align:left">CHAR</td>
<td style="text-align:left">%x01-7F</td>
<td style="text-align:left">任何7位的US-ASCII字符，不包括Nul(%x00)</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR</td>
<td style="text-align:left">%x21-7E</td>
<td style="text-align:left">可见(可打印)字符</td>
</tr>
<tr>
<td style="text-align:left">CR</td>
<td style="text-align:left">%x0D</td>
<td style="text-align:left">回车</td>
</tr>
<tr>
<td style="text-align:left">LF</td>
<td style="text-align:left">%x0A</td>
<td style="text-align:left">换行</td>
</tr>
<tr>
<td style="text-align:left">CRLF</td>
<td style="text-align:left">CR LF</td>
<td style="text-align:left">回车换行</td>
</tr>
<tr>
<td style="text-align:left">CTL</td>
<td style="text-align:left">%x00-1F / %x7F</td>
<td style="text-align:left">控制字符</td>
</tr>
<tr>
<td style="text-align:left">DIGIT</td>
<td style="text-align:left">%x30-39</td>
<td style="text-align:left">数字0-9</td>
</tr>
<tr>
<td style="text-align:left">DQUOTE</td>
<td style="text-align:left">%x22</td>
<td style="text-align:left">双引号</td>
</tr>
<tr>
<td style="text-align:left">HEXDIG</td>
<td style="text-align:left">DIGIT / “A” / “B” / “C” / “D” / “E” / “F”</td>
<td style="text-align:left">十六进制字符</td>
</tr>
<tr>
<td style="text-align:left">OCTET</td>
<td style="text-align:left">%x00-FF</td>
<td style="text-align:left">8位数据</td>
</tr>
<tr>
<td style="text-align:left">HTAB</td>
<td style="text-align:left">%x09</td>
<td style="text-align:left">横向制表符</td>
</tr>
<tr>
<td style="text-align:left">SP</td>
<td style="text-align:left">%x20</td>
<td style="text-align:left">空格</td>
</tr>
<tr>
<td style="text-align:left">WSP</td>
<td style="text-align:left">SP / HTAB</td>
<td style="text-align:left">空格或者横向制表符</td>
</tr>
<tr>
<td style="text-align:left">LWSP</td>
<td style="text-align:left">*(WSP / CRLF WSP)</td>
<td style="text-align:left">空白行(不要用于邮件头，另外在其他上下文中使用也需要小心)</td>
</tr>
</tbody>
</table>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://tools.ietf.org/html/rfc5234" target="_blank" rel="external">RFC 5234</a><br><a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%85%85%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F" target="_blank" rel="external">维基百科 扩充巴科斯范式</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/10/25/Hive-VLong-to-Java-long/" class="post-link">RCFile文件格式下的Hive表bigint类型列值读取问题</a></h2><span class="post-time">Oct 25, 2016</span><div class="post-content"><h2 id="背景缘起"><a href="#背景缘起" class="headerlink" title="背景缘起"></a>背景缘起</h2><p>目前在将hive部分列数据采集到hbase时，由于平台将原来hive表的文件格式从SequenceFile调整到RCFile，因此需要对原来的离线数据采集程序进行修改。然而在实际修改开发过程中，却碰到了程序读取hive列字段，值为乱码的问题。</p>
<h2 id="初步诊断"><a href="#初步诊断" class="headerlink" title="初步诊断"></a>初步诊断</h2><p>由于之前的文件格式是SequenceFile，不管列在hive中数据类型是什么，程序都可以以统一的读取String方式来读取。因此在变更为RCFile方式时，仅仅调整了输入部分，转换依然采用了Bytes.toString方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convertHiveBigint</span><span class="params">(BytesRefWritable brw)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    <span class="keyword">return</span> Bytes.toString(brw.getData(),brw.getStart(),brw.getLength());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是针对乱码的字段，查看了hive表对应列的数据类型，发现是Bigint，那么我想可能不仅仅需要调整输入，最终转换的地方也需要调整为Bytes.toLong。于是将代码修改如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">convertHiveBigint</span><span class="params">(BytesRefWritable brw)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    <span class="keyword">return</span> Bytes.toLong(brw.getData(),brw.getStart(),brw.getLength());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="奇怪的-118"><a href="#奇怪的-118" class="headerlink" title="奇怪的-118"></a>奇怪的-118</h2><p>就在我以为上面的修改可以奏效之时，实际运行时却抛出了鲜红的异常</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/exception.png" alt="异常信息"></p>
<p>从异常信息里不难看出，对于Java long来说，已经规定是需要8个字节，然而在上面代码里，最终转换时确变成了7个字节。为此，对程序进行了调试，将原始的brw.getData打印了出来</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/bytesarray.png" alt="原始字节数据"></p>
<p>结合调试得到的offset和length值，获知到程序真实运行时取值为 <strong>-118 1 58 92 103 58 -127</strong>，而我直接通过hive sql查询列原始值，并转换成字节数组为 <strong>0 0 1 58 92 103 58 -127</strong>。观察这两组数据不难发现，不同之处在于前者开头是-118，而后者是0 0。而再仔细观察上面的字节数组，会很惊讶的发现，好像每隔6位，就会出现-118。这个时候，我就猜测假如能够弄明白-118的来源，那么我们的问题有很大概率就可以解决了。</p>
<h2 id="无心插柳"><a href="#无心插柳" class="headerlink" title="无心插柳"></a>无心插柳</h2><p>正当我对这个问题陷入困顿的时候，无意间发现了下图的信息(莫非这个是hive序列化类(⊙o⊙)？)</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/hive.png" alt="hive信息"></p>
<p>于是，我马上翻开了这个类的源码，根据类上面的注释确认了该类确实能将hive column序列化为BytesRefArrayWritable。该类只有initialize和serialize这两个方法，针对序列化过程，不难猜到入口肯定是serialize这个方法，由于需要序列化的列类型是Bigint，因此判定进入如下分支:</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/serialize.png" alt="序列化"></p>
<p>进入此方法后，是一个switch case分支选择，根据bigint和long对应关系，判定进入如下case：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/caselong.png" alt="Long"></p>
<p>最终代码导航下去，你会发现实际的转换过程在方法<strong>LazyBinaryUtils.writeVLongToByteArray</strong>,这也解开了上面-118的问题,不过限于水平目前还不太理解这段代码的含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">writeVLongToByteArray</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">long</span> l)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (l &gt;= -<span class="number">112</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123;</div><div class="line">    bytes[offset] = (<span class="keyword">byte</span>) l;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> len = -<span class="number">112</span>;</div><div class="line">  <span class="keyword">if</span> (l &lt; <span class="number">0</span>) &#123;</div><div class="line">    l ^= -<span class="number">1L</span>; <span class="comment">// take one's complement'</span></div><div class="line">    len = -<span class="number">120</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> tmp = l;</div><div class="line">  <span class="keyword">while</span> (tmp != <span class="number">0</span>) &#123;</div><div class="line">    tmp = tmp &gt;&gt; <span class="number">8</span>;</div><div class="line">    len--;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  bytes[offset] = (<span class="keyword">byte</span>) len;</div><div class="line"></div><div class="line">  len = (len &lt; -<span class="number">120</span>) ? -(len + <span class="number">120</span>) : -(len + <span class="number">112</span>);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = len; idx != <span class="number">0</span>; idx--) &#123;</div><div class="line">    <span class="keyword">int</span> shiftbits = (idx - <span class="number">1</span>) * <span class="number">8</span>;</div><div class="line">    <span class="keyword">long</span> mask = <span class="number">0xFFL</span> &lt;&lt; shiftbits;</div><div class="line">    bytes[offset+<span class="number">1</span>-(idx - len)] = (<span class="keyword">byte</span>) ((l &amp; mask) &gt;&gt; shiftbits);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span> + len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>最后，LazyBinaryUtils不仅提供了VLong序列化成字节数组的过程，同时也提供反序列化的过程，实际程序中只需调用LazyBinaryUtils.readVLongFromByteArray方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">readVLongFromByteArray</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset)</span> </span>&#123;</div><div class="line">  <span class="keyword">byte</span> firstByte = bytes[offset++];</div><div class="line">  <span class="keyword">int</span> len = WritableUtils.decodeVIntSize(firstByte);</div><div class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> firstByte;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">long</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; len-<span class="number">1</span>; idx++) &#123;</div><div class="line">    <span class="keyword">byte</span> b = bytes[offset++];</div><div class="line">    i = i &lt;&lt; <span class="number">8</span>;</div><div class="line">    i = i | (b &amp; <span class="number">0xFF</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (WritableUtils.isNegativeVInt(firstByte) ? ~i : i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结扩展"><a href="#总结扩展" class="headerlink" title="总结扩展"></a>总结扩展</h2><p>序列化和反序列化是相对的，在不了解具体序列化规则的情况下，去进行反序列化，有时候可能碰到问题。而在这个场景里，hive在序列化bigint时，是按照不定长的VLONG形式进行转换，如果我们依然按照原先读取long类型方式，那么就会碰到问题，因此一定要选择对应的反序列化方式才能获取到正确的值。在以后碰到hive不同列类型转换成Java中的类型时，可以参考LazyBinarySerDe.serialize对应类型的序列化方式，来寻找API中对应的反序列化方式，抑或自己动手造轮子。</p>
</div></article></li></ul><div class="paginator"></div></section><footer><div class="social"><a href="mailto:lukc1986@gmail.com" title="email" class="iconfont icon-email"></a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Lucifer</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>