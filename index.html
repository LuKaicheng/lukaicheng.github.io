<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Lucifer"><meta name="description"><title>Way to architect</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="https://lukaicheng.github.io/"><link rel="alternate" href="/atom.xml" title="Way to architect"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Way to architect</a><ul class="nav"><li class="nav-link"><a href="/" class="active">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li></ul></header><section id="container"><ul class="home"><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/08/09/HDFS-HA-Notes/" class="post-link">HDFS学习总结(二)高可用</a></h2><span class="post-time">Aug 9, 2017</span><div class="post-content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在上一篇<a href="https://lukaicheng.github.io/2017/08/02/HDFS-Basic-Notes/">HDFS学习总结(一)基本原理</a>的最后提到，由于名称节点容易成为整个HDFS系统的单点故障，这极大限制了hadoop系统在生产环境的使用场景。在hadoop1.x中，虽然有所谓的<strong>Secondary NameNode</strong>，然而对于它的定位仅仅只是<strong>NameNode</strong>的辅助者，严格来讲连冷备都算不上。幸运的是，在hadoop2.x版本里，经过多次迭代和发展，对于HDFS来说终于有了一套较为成熟可靠的高可用方案：<strong>QJM</strong>(<em>Quorum Journal Manager</em>)。本文将以此为中心，梳理和总结HDFS高可用的相关知识。</p></div><a href="/2017/08/09/HDFS-HA-Notes/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/08/02/HDFS-Basic-Notes/" class="post-link">HDFS学习总结(一)基本原理</a></h2><span class="post-time">Aug 2, 2017</span><div class="post-content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>HDFS(<em>Hadoop Distribute File System</em>)是一个开源的分布式文件系统，源自于Google公司在2003年发表的<a href="https://research.google.com/archive/gfs.html">GFS论文</a>，目前已经成为Hadoop生态圈的基石之一。它是一个高度容错性的系统，能检测和应对硬件故障，被设计可以部署在低成本的通用硬件上。它简化了文件的一致性模型，通过流式数据访问，提供了高吞吐量的数据访问，非常适合那些拥有大规模数据集的应用。</p></div><a href="/2017/08/02/HDFS-Basic-Notes/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/07/29/Reading-ArrayBlockingQueue/" class="post-link">阻塞队列--ArrayBlockingQueue解读分析</a></h2><span class="post-time">Jul 29, 2017</span><div class="post-content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>阻塞队列是一种十分有用的数据结构，其非常适合作为生产者－消费者模式当中的中间容器，这是因为与普通的队列相比，它可以在适当的时候通过阻塞生产者或者消费者线程，在一定程度上调节两者之间速率不匹配的问题，起到缓冲的作用。</p>
<h2 id="阻塞队列方法简介"><a href="#阻塞队列方法简介" class="headerlink" title="阻塞队列方法简介"></a>阻塞队列方法简介</h2><p>阻塞队列接口的全限定名为<code>java.util.concurrent.BlockingQueue</code>，其继承了<code>java.util.Queue</code>接口，声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">//添加元素，如果空间足够就马上插入，否则抛出IllegalStateException，更推荐使用offer</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</div><div class="line">	<span class="comment">//添加元素，功能同add，但是在空间不足时只会返回false，不会抛异常</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</div><div class="line">	<span class="comment">//添加元素，如果队列已满则会阻塞线程进行等待</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">	<span class="comment">//添加元素，如果队列已满则会尝试限时等待，但一旦超时则会放弃操作</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">	<span class="comment">//获取并删除队列头元素，如果队列为空则会进行阻塞等待</span></div><div class="line">	<span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">	<span class="comment">//获取并删除队列头元素，如果队列为空则会尝试限时等待，一旦超时则放弃操作</span></div><div class="line">	<span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">	<span class="comment">//返回队列还可以接受多少个无阻塞插入的元素</span></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</div><div class="line">	<span class="comment">//从队列中移除指定元素</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</div><div class="line">	<span class="comment">//判断队列中是否包含指定元素</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</div><div class="line">  	<span class="comment">//将队列中的所有元素移除并加入到传入的集合</span></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</div><div class="line">	<span class="comment">//移除队列中最多指定数量的元素并将其加入到传入的集合</span></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它提供了好几种不同的元素入队和元素出队方法，当然，在实际工程中，<code>offer</code>、<code>put</code>、<code>take</code>、<code>poll</code>方法可能使用较多，下面我将以<code>ArrayBlockingQueue</code>这个较为常用的阻塞队列实现为例，分析一下实现阻塞的基本思路，其中主要分析以上几个常用方法。</p></div><a href="/2017/07/29/Reading-ArrayBlockingQueue/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/07/27/ConcurrentHashMap-JDK7-comprehension/" class="post-link">并发容器－理解ConcurrentHashMap(JDK7版本)</a></h2><span class="post-time">Jul 27, 2017</span><div class="post-content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>HashMap</code>是程序开发中经常被使用到的一个哈希表实现，然而在多线程情况下，使用<code>HashMap</code>却可能引发程序异常，这是因为它被设计为非线程安全。如果想要确保在多线程场景下的正确性，那么早些时候可能除了使用<code>sychronized</code>或者<code>HashTable</code>之外，并没有太好的选择。但是当1.5版本引入JUC包之后，在你的工具库里就多了一个更好的选择：<code>ConcurrentHashMap</code>。 </p></div><a href="/2017/07/27/ConcurrentHashMap-JDK7-comprehension/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/07/23/Comprehend-volatile/" class="post-link">Java并发基础--理解volatile</a></h2><span class="post-time">Jul 23, 2017</span><div class="post-content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>众所周知，Java语言是通过共享内存的方式，来实现多线程之间的通信行为。为了保证共享变量的值能在不同线程之间得到一致地更新，可以考虑使用<code>synchronized</code>来确保共享变量的可见性。除此之外，Java语言还提供了另一种机制：<code>volatile</code>。使用<code>volatile</code>同样也提供对共享变量内存可见性的保证，并且它的运行时开销相比<code>sychronized</code>会更少，这种行为是由Java内存模型所确保的。下面就以<code>volatile</code>为中心，梳理并总结一下对内存可见性、重排序、Java内存模型、happens-before规则、内存屏障等一系列概念的理解。</p></div><a href="/2017/07/23/Comprehend-volatile/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/07/19/ThreadPoolExecutor-summary/" class="post-link">Java线程池总结</a></h2><span class="post-time">Jul 19, 2017</span><div class="post-content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>java.util.concurrent.ThreadPoolExecutor</code>是JDK提供的一个线程池实现，在实际项目中是最 常用的JUC组件之一。通过合理使用线程池，可以复用已创建的线程，这不仅能够降低创建和销毁线程的整体消耗，还能够更快速地响应任务，并且通过线程池统一分配、管理、监控，也可以避免无限制地创建线程而造成的系统故障。</p></div><a href="/2017/07/19/ThreadPoolExecutor-summary/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/06/30/CGlib-tutorial-translate/" class="post-link">CGlib教程[译]</a></h2><span class="post-time">Jun 30, 2017</span><div class="post-content"><p><a href="https://github.com/cglib/cglib/wiki/Tutorial">原文链接</a></p>
<p>原始文章：<a href="http://mydailyjava.blogspot.no/2013/11/cglib-missing-manual.html">http://mydailyjava.blogspot.no/2013/11/cglib-missing-manual.html</a></p>
<h2 id="增强器"><a href="#增强器" class="headerlink" title="增强器"></a>增强器</h2><p>让我们从<code>Enhancer</code>类开始，这可能是cglib库中最常被使用的类。一个增强器允许为没有接口的类型创建一个Java代理。<code>Enhancer</code>可以与java标准库的<code>Proxy</code>类做对比，后者是在Java 1.3时引入的。<code>Enhancer</code>动态地创建给定类型的子类而拦截所有的方法调用。与<code>Proxy</code>类不同的是，它对于类和接口都适用。接下来的例子和后续的一些例子都是基于这个简单的Java POJO：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String input)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello world!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><a href="/2017/06/30/CGlib-tutorial-translate/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/06/25/Delay-task-practice/" class="post-link">延迟任务实践总结</a></h2><span class="post-time">Jun 25, 2017</span><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在实际开发项目过程中，可能会碰到类似这样的需求：期望一个任务不是马上执行，而是可以在给定的时间段之后才执行，通常这被称为<strong>延迟任务</strong>。解决这个问题的方案已经有不少，最直接的是采用定时任务的方式扫描数据库，或者考虑使用时间轮算法，或者基于RabbitMQ来实现延迟队列。最近我在项目中就碰到了同样的问题：当新内容添加到系统时，会带有一个过期时间，一旦到达此过期时间，那么需要自动下架该内容。对于此问题，在实际项目演变过程中我采用了与上述不同的两种方式来解决。</p></div><a href="/2017/06/25/Delay-task-practice/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/06/24/Java-serialization-mechanism/" class="post-link">Java序列化机制总结</a></h2><span class="post-time">Jun 24, 2017</span><div class="post-content"><h2 id="序列化缘由"><a href="#序列化缘由" class="headerlink" title="序列化缘由"></a>序列化缘由</h2><p>在实际的程序运行过程中，总会有这样的场景：程序可以将本次运行的某些对象或者状态保存下来，以供下次启动时使用；在一个联网环境里，不同节点之间的系统需要进行通信，发送者要将某些对象发送到远程的接收者从而达到沟通协调的目的。序列化正是缘于这些场景而出现的一种技术概念，为了能够序列化Java平台的对象，JDK从很早的版本开始就提供了一种序列化机制，它可以将对象编码成字节流(<em>序列化</em>)，也可以反向从字节流编码中重新构建对象(<em>反序列化</em>)，以用于支持RMI和JavaBean。</p></div><a href="/2017/06/24/Java-serialization-mechanism/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2017/06/09/TagBasedStatistics/" class="post-link">基于标签的人群统计实现分析</a></h2><span class="post-time">Jun 9, 2017</span><div class="post-content"><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>最近在做项目过程中，碰到了这样一个需求：当前台页面勾选偏好标签的时候，后端服务需要快速给出标签对应的人群数量。如果仅仅只是单个标签的话，那么问题是非常简单的，然而现实是残酷的，我必须考虑基于多个标签勾选的交并集统计情况。</p>
<p>在此，先做一个假设，每个标签后面对应的人群数量是一百万，当然有可能人群会有重叠，而后续的讨论都是基于此数量级展开。</p></div><a href="/2017/06/09/TagBasedStatistics/" class="read-more">Read more..</a></article></li></ul><div class="paginator"><a href="/page/2/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div></section><footer><div class="social"><a href="mailto:lukc1986@gmail.com" title="email" class="iconfont icon-email"></a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2017<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Lucifer</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>