<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Way to architect</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lukaicheng.github.io/"/>
  <updated>2017-08-02T03:08:30.959Z</updated>
  <id>https://lukaicheng.github.io/</id>
  
  <author>
    <name>Lucifer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HDFS学习总结(一)基本原理</title>
    <link href="https://lukaicheng.github.io/2017/08/02/HDFS-Basic-Notes/"/>
    <id>https://lukaicheng.github.io/2017/08/02/HDFS-Basic-Notes/</id>
    <published>2017-08-02T03:08:08.000Z</published>
    <updated>2017-08-02T03:08:30.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>HDFS(<em>Hadoop Distribute File System</em>)是一个开源的分布式文件系统，源自于Google公司在2003年发表的<a href="https://research.google.com/archive/gfs.html" target="_blank" rel="external">GFS论文</a>，目前已经成为Hadoop生态圈的基石之一。它是一个高度容错性的系统，能检测和应对硬件故障，被设计可以部署在低成本的通用硬件上。它简化了文件的一致性模型，通过流式数据访问，提供了高吞吐量的数据访问，非常适合那些拥有大规模数据集的应用。</p>
<a id="more"></a>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>HDFS整体架构如下所示(<em>参考官网提供的架构图片</em>)：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/hdfs/HDFS_Architecture.png" alt="HDFS整体架构"></p>
<p>从图中不难发现，HDFS采用了<strong>主从</strong>模式的架构设计，包含一个<strong>NameNode</strong>和多个<strong>DataNode</strong>：</p>
<ul>
<li><strong>NameNode</strong>：名称节点作为主服务管理着整个文件系统的命名空间并接收处理客户端对文件的访问请求，它能执行打开、关闭、重命名文件和目录等操作，同时也决定数据块到数据节点的映射关系。它存储的元数据包括文件/目录名称及相对于其父目录的位置，文件和目录的所有权及权限，各个数据块的文件名，值得注意的是它并不存储每个数据块的位置。</li>
<li><strong>DataNode</strong>：数据节点能够接收来自文件系统客户端的读写请求，另外根据名称节点的指示将会执行数据块的创建、删除和复制行为。当然，最主要的是它负责存储实际的组成文件的数据块数据。</li>
</ul>
<h2 id="备份和机架感知"><a href="#备份和机架感知" class="headerlink" title="备份和机架感知"></a>备份和机架感知</h2><p>每个存储在HDFS上的文件都会被分割为多个数据块(<strong><em>Block</em></strong>)，默认情况下一个数据块大小为128MB(<em>可以通过配置<strong>hdfs-size.xml</strong>的<strong>dfs.blocksize</strong>属性改变</em>)。在上一节曾提到，名称节点并不会保存每个数据块的位置，这是因为名称节点除了会接收数据节点发出的心跳包(<strong><em>Heartbeat</em></strong>)之外，还包括接收数据节点发出的数据块报告(<strong><em>BlockReport</em></strong>)，后者包含了数据节点上所有的数据块信息。</p>
<p>由于HDFS被设计成高容错系统，为了防止节点故障，这些数据块都是有备份的(<em>默认配置的备份数量是3，当然应用程序也可以指定文件的备份数，这可以在文件创建的时候指定，也可以在创建之后改变</em>)。另外，对于备份副本的放置，HDFS引入了<strong>机架感知</strong>的概念，其目的是为了提升数据可靠性，可用性以及网络带宽利用率。假设备份数是3，这个策略可以这样理解：如果写入文件的客户端也是一个数据节点，那么第一个备份就会放在本机上否则会随机挑选一个数据节点；第二个副本会被存放在与第一个副本不同的远程机架的一个数据节点上；第三个副本会被存放在第二个备份的机架上的另一台数据节点上。</p>
<h2 id="写文件流程分析"><a href="#写文件流程分析" class="headerlink" title="写文件流程分析"></a>写文件流程分析</h2><p>假设写入文件被划分成2个数据块，备份因子是3，且HDFS具备机架感知功能，先放图：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/hdfs/HDFS_Write_Process.png" alt="HDFS读文件流程"></p>
<p>现在结合上图大致描述一下整个流程：</p>
<p>一、当客户端希望向HDFS写入文件，一开始是先将文件数据流式读入到本地文件系统中的一个临时文件，当文件数据大小达到一个数据块大小时，客户端才联系名称节点。</p>
<p>二、名称节点收到请求之后，会在HDFS文件系统的层级结构中创建一个文件，然后把数据块的标识符和数据节点的位置信息发送给客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Block1: DN1,DN3,DN4</div><div class="line">Block2: DN5,DN8,DN7</div></pre></td></tr></table></figure>
<p>三、客户端收到数据块信息之后，那么将开始向数据节点发送数据包：</p>
<ol>
<li>客户端首先尝试发送Block1到DN1，Block1会被划分成更小的数据包发送给DN1</li>
<li>当DN1接收到第一个数据包并写入到本地存储之后，它会将数据包传送给DN3</li>
<li>当DN3接收到数据包并将其写入本地存储之后，它会发送给第三个数据节点DN4</li>
<li>最终，DN4会将数据包写入到本地存储，这样文件数据最终以管道的方式保存并备份</li>
<li>当数据包保存成功之后，会反向沿着数据管道返回确认消息(ACK)</li>
<li>当Block1发送成功之后，客户端继续发送Block2，过程类似</li>
</ol>
<p>四、客户端收到数据块保存成功的确认，客户端会发送最终的确认信息给名称节点。最终当文件被关闭时，名称节点会执行一个提交操作，从而使得该文件在集群中为可见状态。</p>
<p>通过整个过程，我们可以意识到：</p>
<ul>
<li>写1T文件，需要3T的存储，3T的网络流量带宽。</li>
<li>在整个写过程中，名称节点和数据节点通过HeartBeat保持通信，一旦发现数据节点故障，感知到文件数据没有备份完成，就会重新执行备份，把数据备份到状态良好的节点。</li>
</ul>
<h2 id="读文件流程分析"><a href="#读文件流程分析" class="headerlink" title="读文件流程分析"></a>读文件流程分析</h2><p>以上一节为基础，再放一张关于读文件的示意图：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/hdfs/HDFS_Read_Process.png" alt="HDFS写文件流程"></p>
<p>结合上图简要分析一下读文件的大致流程：</p>
<p>一、客户端会先向名称节点发送读文件请求。</p>
<p>二、名称节点收到请求之后，会返回组成文件的数据块列表及数据块的位置(包括备份数据块的位置)：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Block1: DN1,DN3,DN4</div><div class="line">Block2: DN5,DN8,DN7</div></pre></td></tr></table></figure>
<p>三、客户端收到数据块信息之后，可以直接访问数据节点获取组成文件的各个数据块，首先从DN1节点获取Block1，然后从DN5节点获取Block5。如果访问的数据节点发生故障或者在计算数据块校验和的时候校验失败，那么会访问存放备份数据块的数据节点(<em>比如DN1发生问题，那么会从DN3获取Block1</em>)。</p>
<h2 id="回收站机制"><a href="#回收站机制" class="headerlink" title="回收站机制"></a>回收站机制</h2><p>HDFS提供了一种回收站的机制，针对意外的删除行为，它给予了用户一次反悔的机会，主要的运行机制大概是这样的：当用户删除文件之后，首先会被移动到<strong>/user/{username}/.Trash/Current/</strong>目录，并且它的原始文件系统路径会被保留，经过一段可配置的时间(<em>通过属性<strong>fs.trash.interval</strong>配置</em>)之后，回收站检查进程会将<strong>Current</strong>目录根据当前时间重命名为<strong>/user/{username}/.Trash/{current_timestamp}/</strong>，并且查找过往检查点的<strong>timestamp</strong>目录，并删除过期的目录，只有到这一步，名称节点才会将文件从命名空间删除，并释放该文件相关的数据块，随后HDFS系统会显示增加了一些空闲空间。</p>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>通过上面的分析中不难看出，名称节点扮演着非常关键的角色，可以说整个HDFS都是围绕着它来运转。正因为如此，在hadoop1.x系统中，名称节点很容易成为单点故障，从而导致整个集群处于不可用状态。另外，由于名称节点维护了整个系统的命名空间，它要负责存储所有的元数据信息，即使HDFS针对的是大文件，随着集群规模和所存储文件的增加，命名节点的容量也将成为整个集群的瓶颈。因此，hadoop2.x在高可用和扩展性这两个方面提出了针对性的补充，这些就留待下一篇再进行总结。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/26684358/" target="_blank" rel="external">深入理解Hadoop</a></p>
<p><a href="https://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" target="_blank" rel="external">HDFS Architecture</a></p>
<p><a href="https://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/RackAwareness.html" target="_blank" rel="external">Rack Awareness</a></p>
<p><a href="http://www.cnblogs.com/laov/p/3434917.html" target="_blank" rel="external">HDFS运行原理</a></p>
<p><a href="https://www.cloudera.com/documentation/enterprise/5-7-x/topics/cm_mc_config_trash.html" target="_blank" rel="external">Configuring HDFS Trash</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;HDFS(&lt;em&gt;Hadoop Distribute File System&lt;/em&gt;)是一个开源的分布式文件系统，源自于Google公司在2003年发表的&lt;a href=&quot;https://research.google.com/archive/gfs.html&quot;&gt;GFS论文&lt;/a&gt;，目前已经成为Hadoop生态圈的基石之一。它是一个高度容错性的系统，能检测和应对硬件故障，被设计可以部署在低成本的通用硬件上。它简化了文件的一致性模型，通过流式数据访问，提供了高吞吐量的数据访问，非常适合那些拥有大规模数据集的应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hadoop" scheme="https://lukaicheng.github.io/tags/Hadoop/"/>
    
      <category term="HDFS" scheme="https://lukaicheng.github.io/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>阻塞队列--ArrayBlockingQueue解读分析</title>
    <link href="https://lukaicheng.github.io/2017/07/29/Reading-ArrayBlockingQueue/"/>
    <id>https://lukaicheng.github.io/2017/07/29/Reading-ArrayBlockingQueue/</id>
    <published>2017-07-29T02:55:27.000Z</published>
    <updated>2017-07-31T12:02:02.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>阻塞队列是一种十分有用的数据结构，其非常适合作为生产者－消费者模式当中的中间容器，这是因为与普通的队列相比，它可以在适当的时候通过阻塞生产者或者消费者线程，在一定程度上调节两者之间速率不匹配的问题，起到缓冲的作用。</p>
<h2 id="阻塞队列方法简介"><a href="#阻塞队列方法简介" class="headerlink" title="阻塞队列方法简介"></a>阻塞队列方法简介</h2><p>阻塞队列接口的全限定名为<code>java.util.concurrent.BlockingQueue</code>，其继承了<code>java.util.Queue</code>接口，声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">//添加元素，如果空间足够就马上插入，否则抛出IllegalStateException，更推荐使用offer</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</div><div class="line">	<span class="comment">//添加元素，功能同add，但是在空间不足时只会返回false，不会抛异常</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</div><div class="line">	<span class="comment">//添加元素，如果队列已满则会阻塞线程进行等待</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">	<span class="comment">//添加元素，如果队列已满则会尝试限时等待，但一旦超时则会放弃操作</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">	<span class="comment">//获取并删除队列头元素，如果队列为空则会进行阻塞等待</span></div><div class="line">	<span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">	<span class="comment">//获取并删除队列头元素，如果队列为空则会尝试限时等待，一旦超时则放弃操作</span></div><div class="line">	<span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">	<span class="comment">//返回队列还可以接受多少个无阻塞插入的元素</span></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</div><div class="line">	<span class="comment">//从队列中移除指定元素</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</div><div class="line">	<span class="comment">//判断队列中是否包含指定元素</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</div><div class="line">  	<span class="comment">//将队列中的所有元素移除并加入到传入的集合</span></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</div><div class="line">	<span class="comment">//移除队列中最多指定数量的元素并将其加入到传入的集合</span></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它提供了好几种不同的元素入队和元素出队方法，当然，在实际工程中，<code>offer</code>、<code>put</code>、<code>take</code>、<code>poll</code>方法可能使用较多，下面我将以<code>ArrayBlockingQueue</code>这个较为常用的阻塞队列实现为例，分析一下实现阻塞的基本思路，其中主要分析以上几个常用方法。</p>
<a id="more"></a>
<h2 id="ArrayBlockingQueue简介"><a href="#ArrayBlockingQueue简介" class="headerlink" title="ArrayBlockingQueue简介"></a>ArrayBlockingQueue简介</h2><p><code>ArrayBlockingQueue</code>是一个FIFO(先进先出)的阻塞队列，从名字中就不难猜到，其底层是由一个数组来存储队列元素，另外它声明了两个指针作用的索引变量，用来指示下一个可插入的位置以及下一个元素的位置，当两者递增到预设的容量上限时，会被重置为0，从而可以循环利用已有的数组空间。因此需要注意一点的是，<code>ArrayBlockingQueue</code>在初始化设定容量之后，就无法再改变其容量大小，而且它不会进行隐式地扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//队列元素</span></div><div class="line"><span class="keyword">final</span> Object[] items;</div><div class="line"><span class="comment">//下一个元素获取的位置</span></div><div class="line"><span class="keyword">int</span> takeIndex;</div><div class="line"><span class="comment">//下一个元素可插入的位置</span></div><div class="line"><span class="keyword">int</span> putIndex;</div><div class="line"><span class="comment">//队列中的实际元素数量</span></div><div class="line"><span class="keyword">int</span> count;</div></pre></td></tr></table></figure>
<p>为了实现线程安全，<code>ArrayBlockingQueue</code>内部声明了<code>ReentrantLock</code>用于守护对其所有的访问。而它本身之所以能实现阻塞的功能，正是得益于锁上的<code>notEmpty</code>和<code>notFull</code>这两个条件。其中，<code>notEmpyt</code>用于表达队列不为空，<code>notFull</code>用于表达队列未满：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//主锁，维护所有的访问</span></div><div class="line"><span class="keyword">final</span> ReentrantLock lock;</div><div class="line"><span class="comment">//队列不为空的条件</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</div><div class="line"><span class="comment">//队列未满的条件</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</div></pre></td></tr></table></figure>
<p>在初始化过程中，除了创建实际存储的元素之外，锁和条件也将被初始化，其中锁可以指定是公平锁还是非公平锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</div><div class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</div><div class="line">    notEmpty = lock.newCondition();</div><div class="line">    notFull =  lock.newCondition();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="阻塞入队实现分析"><a href="#阻塞入队实现分析" class="headerlink" title="阻塞入队实现分析"></a>阻塞入队实现分析</h2><p>首先来分析一下无超时时间的阻塞入队方法<code>put</code>：首先使用主锁进行可中断的锁定，接着判断队列中实际的元素数量是否已经达到数组容量上限，如果判定为真，那么将会触发<code>notFull.await</code>方法，这个方法会导致线程放弃持有的锁转入等待状态(<em>WAITING</em>)，直到有另一个线程在<code>notFull</code>条件上触发<code>signal</code>或<code>signalAll</code>才有可能重新唤醒此线程继续操作。当然如果判断出此时队列未满，那么就会进行元素入队(<code>enqueue</code>)。</p>
<p>(<em>这里需要意识到的一点是，由于<code>ArrayBlockingQueue</code>在元素入列和元素出队都是使用同一把锁进行锁定，所以如果一个线程拿到锁进行插入，那么其他线程不管是插入元素还是弹出元素均需要等待此线程释放锁才能继续操作</em>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    checkNotNull(e);</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count == items.length)</div><div class="line">            notFull.await();</div><div class="line">        enqueue(e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>enqueue</code>的整个逻辑也十分简单直接：首先根据之前提到的<code>putIndex</code> 索引，将新元素赋值到数组中。接着递增<code>putIndex</code>和<code>count</code>，其中如果发现递增的<code>putIndex</code>达到了数组容量，那么会将其重置为0，以便循环利用已空闲的数组位。最后也是很关键的一点，由于外部插入元素的方法进行了锁定，那么可以保证入队之后，队列至少会包含新插入的这个元素，即意味着队列不为空，因此这时候需要触发<code>notEmpty.signal</code>，来唤醒一个等待满足此条件的线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">    items[putIndex] = x;</div><div class="line">    <span class="keyword">if</span> (++putIndex == items.length)</div><div class="line">        putIndex = <span class="number">0</span>;</div><div class="line">    count++;</div><div class="line">    notEmpty.signal();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="阻塞出队实现分析"><a href="#阻塞出队实现分析" class="headerlink" title="阻塞出队实现分析"></a>阻塞出队实现分析</h2><p>阻塞出队的过程与入队的过程极为相似：首先是使用主锁进行可中断锁定，接着判断当前队列是否为空，如果判定成立，那么将会触发<code>notEmpty.await</code>，使得当前操作的线程在这一条件上等待，否则就会进行实际的出入操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">            notEmpty.await();</div><div class="line">        <span class="keyword">return</span> dequeue();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>dequeue</code>的实现并不复杂：首先根据<code>takeIndex</code>找到需要出队的元素，接着递增<code>takeIndex</code>指向下一个元素，此时同<code>putIndex</code>一样，为了循环利用数组，如果判定达到了数组容量上限，那么会被重置为0。<code>itrs.elementDequeued</code>方法和迭代器有关，当出队元素时会触发此方法，由于本文主要关注阻塞实现，因为不做过多分析。最后同样也是最关键的，由于外部锁定保证了只有一个线程进行出队操作，那么此时弹出一个元素之后，队列肯定未满，因此需要触发<code>notFull.signal</code>来唤醒等待此条件满足的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    E x = (E) items[takeIndex];</div><div class="line">    items[takeIndex] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</div><div class="line">        takeIndex = <span class="number">0</span>;</div><div class="line">    count--;</div><div class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</div><div class="line">        itrs.elementDequeued();</div><div class="line">    notFull.signal();</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="限时阻塞实现分析"><a href="#限时阻塞实现分析" class="headerlink" title="限时阻塞实现分析"></a>限时阻塞实现分析</h2><p>了解了阻塞入队和阻塞出入的实现，接下来再来看一下限时等待的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    checkNotNull(e);</div><div class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count == items.length) &#123;</div><div class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            nanos = notFull.awaitNanos(nanos);</div><div class="line">        &#125;</div><div class="line">        enqueue(e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            nanos = notEmpty.awaitNanos(nanos);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dequeue();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看见不论是限时阻塞入队还是限时阻塞出队，其主体流程和不限时的版本高度相似，不同之处在于，限时版本调用的是<code>Condition.awaitNanos</code>方法，这个方法使得线程放弃当前持有的锁转入超时等待状态(<em>TIMED_WAITING</em>)，如果返回值小于等于0，则表明已经超时，对于这种情况，可以看见两个方法都添加了相应判断逻辑，如果已经超时，方法会直接返回而不进行后续的入队或出队操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> <code>ArrayBlockingQueue</code>通过使用全局锁的方法，来确保任何时间点只有一个线程能进行入队和出队操作，从而保证线程安全(<em>当然这种实现方式非常影响吞吐量</em>)。而之所以没有采用<code>synchronized</code>，我猜想应该是由于<code>Object</code>提供的通知机制(<em>wait、notify、notifyAll</em>)无法在一个对象锁上支持多个条件谓词的原因。然而，在<code>ArrayBlockingQueue</code>的设计上，它需要有一种机制能够支持不同操作等待不同条件，因此其使用了<code>ReentrantLock</code>作为全局锁，从而可以创建多个<code>Condition</code>来满足这种需求。其实，这种思路也可以借鉴在我们平时的项目中，当程序需要等待一个条件满足才能进行后续操作的话，可以考虑采用类似的方案来实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;阻塞队列是一种十分有用的数据结构，其非常适合作为生产者－消费者模式当中的中间容器，这是因为与普通的队列相比，它可以在适当的时候通过阻塞生产者或者消费者线程，在一定程度上调节两者之间速率不匹配的问题，起到缓冲的作用。&lt;/p&gt;
&lt;h2 id=&quot;阻塞队列方法简介&quot;&gt;&lt;a href=&quot;#阻塞队列方法简介&quot; class=&quot;headerlink&quot; title=&quot;阻塞队列方法简介&quot;&gt;&lt;/a&gt;阻塞队列方法简介&lt;/h2&gt;&lt;p&gt;阻塞队列接口的全限定名为&lt;code&gt;java.util.concurrent.BlockingQueue&lt;/code&gt;，其继承了&lt;code&gt;java.util.Queue&lt;/code&gt;接口，声明如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BlockingQueue&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Queue&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//添加元素，如果空间足够就马上插入，否则抛出IllegalStateException，更推荐使用offer&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(E e)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//添加元素，功能同add，但是在空间不足时只会返回false，不会抛异常&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(E e)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//添加元素，如果队列已满则会阻塞线程进行等待&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(E e)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//添加元素，如果队列已满则会尝试限时等待，但一旦超时则会放弃操作&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(E e, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timeout, TimeUnit unit)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//获取并删除队列头元素，如果队列为空则会进行阻塞等待&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;E &lt;span class=&quot;title&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//获取并删除队列头元素，如果队列为空则会尝试限时等待，一旦超时则放弃操作&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;E &lt;span class=&quot;title&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timeout, TimeUnit unit)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//返回队列还可以接受多少个无阻塞插入的元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remainingCapacity&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//从队列中移除指定元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object o)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//判断队列中是否包含指定元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object o)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  	&lt;span class=&quot;comment&quot;&gt;//将队列中的所有元素移除并加入到传入的集合&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;drainTo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collection&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; E&amp;gt; c)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//移除队列中最多指定数量的元素并将其加入到传入的集合&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;drainTo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collection&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; E&amp;gt; c, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxElements)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它提供了好几种不同的元素入队和元素出队方法，当然，在实际工程中，&lt;code&gt;offer&lt;/code&gt;、&lt;code&gt;put&lt;/code&gt;、&lt;code&gt;take&lt;/code&gt;、&lt;code&gt;poll&lt;/code&gt;方法可能使用较多，下面我将以&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;这个较为常用的阻塞队列实现为例，分析一下实现阻塞的基本思路，其中主要分析以上几个常用方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JUC" scheme="https://lukaicheng.github.io/tags/JUC/"/>
    
      <category term="BlockingQueue" scheme="https://lukaicheng.github.io/tags/BlockingQueue/"/>
    
      <category term="Java collections framework" scheme="https://lukaicheng.github.io/tags/Java-collections-framework/"/>
    
  </entry>
  
  <entry>
    <title>并发容器－理解ConcurrentHashMap(JDK7版本)</title>
    <link href="https://lukaicheng.github.io/2017/07/27/ConcurrentHashMap-JDK7-comprehension/"/>
    <id>https://lukaicheng.github.io/2017/07/27/ConcurrentHashMap-JDK7-comprehension/</id>
    <published>2017-07-27T03:54:50.000Z</published>
    <updated>2017-07-27T04:09:00.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>HashMap</code>是程序开发中经常被使用到的一个哈希表实现，然而在多线程情况下，使用<code>HashMap</code>却可能引发程序异常，这是因为它被设计为非线程安全。如果想要确保在多线程场景下的正确性，那么早些时候可能除了使用<code>sychronized</code>或者<code>HashTable</code>之外，并没有太好的选择。但是当1.5版本引入JUC包之后，在你的工具库里就多了一个更好的选择：<code>ConcurrentHashMap</code>。 </p>
<a id="more"></a>
<h2 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h2><p>作为一个哈希表实现，<code>ConcurrentHashMap</code>解决冲突的方法采用的是和<code>HashMap</code>一样的链址法(<em>数组+链表</em>)：不同hash值的项位于数组的不同索引位置，相同hash的项在数组同一个索引位置通过链表串联起来。同时为了满足多线程安全且提供比<code>HashTable</code>更好的并发性能，它引入了分段锁，使得锁的粒度更小，以支持更多的线程可以同时对其进行读写操作。其整体的数据结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/ConcurrentHashMap_Jdk7.png" alt="整体数据结构视图"></p>
<p>其中<code>HashEntry</code>代表了实际存储的元素，声明了键值属性以及一个指向冲突节点的next属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">	<span class="keyword">final</span> K key;</div><div class="line">	<span class="keyword">volatile</span> V value;</div><div class="line">	<span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</div><div class="line">	<span class="comment">//省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Segment</code>是整个类的核心，它是<code>ReentrantLock</code>的子类，一个实例代表了一个分段锁，它的内部声明了其负责管理的集合子集<code>table</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="comment">//实际管理的HashEntry数组</span></div><div class="line">	<span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</div><div class="line">	<span class="comment">//HashEntry数组实际包含的元素数量</span></div><div class="line">	<span class="keyword">transient</span> <span class="keyword">int</span> count;</div><div class="line">	<span class="comment">//HashEntry修改次数</span></div><div class="line">	<span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line">	<span class="comment">//元素临届值，当超过这个值需要进行rehash</span></div><div class="line">  	<span class="keyword">transient</span> <span class="keyword">int</span> threshold;</div><div class="line">	<span class="comment">//省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ConcurrentHashMap</code>在类中声明了<code>Segment</code>数组用来分段管理整个集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ConcurrentHashMap声明分段锁集合</span></div><div class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</div></pre></td></tr></table></figure>
<h2 id="Segment的惰性初始化"><a href="#Segment的惰性初始化" class="headerlink" title="Segment的惰性初始化"></a>Segment的惰性初始化</h2><p>为了减少空间的占用，<code>Segment</code>分段锁数组被设计成惰性初始化，除了在构造阶段会创建起始位置的<code>Segment</code>分段锁，剩下的分段锁根据需要才进行创建。(<em>个人猜测应该是考虑到<code>Segment</code>对象里包含了<code>HashEntry</code>数组，后者会占用不少空间</em>)</p>
<p>查看构造器可以看到，尽管创建了<code>Segment</code>分段锁数组，但是其中只有s0被真正赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line">						<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel) &#123;</div><div class="line">	<span class="comment">//省略部分代码</span></div><div class="line">	Segment&lt;K,V&gt; s0 =</div><div class="line">		<span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</div><div class="line">						(HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</div><div class="line">	Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</div><div class="line">	UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></div><div class="line">	<span class="keyword">this</span>.segments = ss;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剩余分段锁的创建会发生在方法<code>ensureSegment</code>中，主要是往<code>ConcurrentHashMap</code>添加数据的时候触发(<em>另外，方法<code>size</code>和<code>containsValue</code>如果碰上需要加锁尝试的情况，也会触发此方法</em>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</div><div class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></div><div class="line">    Segment&lt;K,V&gt; seg;</div><div class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</div><div class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></div><div class="line">        <span class="keyword">int</span> cap = proto.table.length;</div><div class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</div><div class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</div><div class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</div><div class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</div><div class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></div><div class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</div><div class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</div><div class="line">                   == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> seg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建<code>Segment</code>对象并没有使用锁，而是基于volatile+CAS的方式：首先根据索引计算要新创建的<code>Segment</code>对象的偏移位置，通过<code>UNSAFE.getObjectVolatile</code>方法(<em>具有volatile读的内存语义</em>)来获取此位置的最新值，如果返回值为空，则判定还未初始化，那么以构造器阶段创建的<code>Segment</code>对象为原型，创建<code>HashEntry</code>数组，再构造新的<code>Segment</code>对象，最后用CAS的方式尝试赋值。另外需要注意的是，在构建新的<code>Segment</code>过程中之所以需要重新检测，是因为整个过程中并没有加锁，不保证原子性，其他线程也同样有机会抢修改此偏移位置的值，所以需要持续检测最新值。</p>
<h2 id="get方法分析"><a href="#get方法分析" class="headerlink" title="get方法分析"></a>get方法分析</h2><p> 同<code>HashMap</code>相比，<code>ConcurrentHashMap</code>的读操作需要先经历<code>Segment</code>定位的过程，而在<code>Segment</code>内部的查找行为与<code>HashMap</code>类似，另外，对于哈希算法的考虑也有所不同。</p>
<h3 id="元素均匀分布的考虑"><a href="#元素均匀分布的考虑" class="headerlink" title="元素均匀分布的考虑"></a>元素均匀分布的考虑</h3><p>众所周知，实现一个哈希表最重要的一点是<strong>让所有的元素尽可能均匀分布</strong>，由于<code>ConcurrentHashMap</code>引入了<code>Segment</code>数组，那么不仅需要满足元素在<code>Segment</code>数组中能够均匀分布，而且在每个<code>Segment</code>内部的 <code>HashEntry</code>数组中也同样需要如此，所以我们看到<code>ConcurrentHashMap</code>在计算哈希值时，采用了特别的哈希算法，其计算出来的哈希值同时考虑了元素在<code>Segment</code>和<code>HashEntry</code>的均匀分布：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = hashSeed;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</div><div class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    h ^= k.hashCode();</div><div class="line"></div><div class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></div><div class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></div><div class="line">    h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</div><div class="line">    h += (h &lt;&lt;   <span class="number">3</span>);</div><div class="line">    h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</div><div class="line">    h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> (<em>这个算法过于复杂，有兴趣可以找相关资料进一步进行了解</em>)</p>
<h3 id="Segment的定位"><a href="#Segment的定位" class="headerlink" title="Segment的定位"></a>Segment的定位</h3><p>由于在实际运行中，定位<code>Segment</code>是很多方法必须经过的一个步骤，因此为了尽可能优化性能，约定了<code>Segment</code>数组的容量只能是2的倍数，这样一来就可以利用位操作来取代原本需要的取模操作。</p>
<p>(<em>当y是2的幂时，x % y = x &amp; (y - 1)，这个思路其实和取掩码的方式一样，不过我没找到严格的数学证明</em>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</div><div class="line">	++sshift;</div><div class="line"> 	ssize &lt;&lt;= <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</div><div class="line"><span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>在实际初始化阶段，首先会计算出<code>Segment</code>数组的容量：<code>ssize</code>，这个值最终会是一个大于或等于所传入并发级别的数当中最小的2的倍数。而另外一个变量<code>sshift</code>表示实际需要多少位来表示<code>Segment</code>数组的容量，两者之间的关系：<strong>ssize = 1 &lt;&lt; sshift</strong>。</p>
<p>借助这两个临时变量，我们就可以设定全局变量<code>segmentShift</code>和<code>segmentMask</code>的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//段掩码，用于参与与运算以快速定位在Segment数组中的索引位置</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</div><div class="line"><span class="comment">//段偏移量，用于指示哈希值中不需要参与定位的低位位数</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentShift;</div></pre></td></tr></table></figure>
<p>那么实际定位的时候是就可以快速的使用位运算来获取具体的索引，这里需要注意的是由哈希算法计算出来的哈希值，最终会排除<code>segmentShift</code>数量的低位，只使用剩余的高位来参与定位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//计算分段锁的索引</span></div><div class="line"><span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div></pre></td></tr></table></figure>
<h3 id="HashEntry的定位"><a href="#HashEntry的定位" class="headerlink" title="HashEntry的定位"></a>HashEntry的定位</h3><p>同<code>Segment</code>数组类似，<code>HashEntry</code>数组容量也必须是2的倍数，其会根据指定的初始容量和<code>Segment</code>数组的大小，来确定初始情况下每个<code>Segment</code>中包含的<code>HashEntry</code>数组大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</div><div class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</div><div class="line">	++c;</div><div class="line"><span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</div><div class="line"><span class="keyword">while</span> (cap &lt; c)</div><div class="line">	cap &lt;&lt;= <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>最后，结合全部来全面分析一下<code>get</code>方法(<em><code>containsKey</code>方法也是类似思路</em>)：</p>
<ol>
<li>首先，计算出传入键的哈希值，并根据位运算计算出可能负责管理此键的<code>Segment</code>分段锁索引。</li>
<li>接着，需要注意的是这里利用<code>UNSAFE.getObjectVolatile</code>方法提供<code>volatile</code>读的内存语义来实现获取最新的<code>Segment</code>值，并判定其是否为空。</li>
<li>然后，如果获取到的分段锁不为空，进一步再利用位运算定位在<code>HashEntry</code>数组上的索引，和步骤2一样的方式获取最新值，并判定其是否匹配。</li>
<li>最后可以看到，如果步骤3第一次尝试失败，那么还会去检测是否有冲突链，再循着冲突链查看是否有匹配元素，否则返回null。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></div><div class="line">    HashEntry&lt;K,V&gt;[] tab;</div><div class="line">    <span class="keyword">int</span> h = hash(key);</div><div class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</div><div class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</div><div class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</div><div class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            K k;</div><div class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="put方法分析"><a href="#put方法分析" class="headerlink" title="put方法分析"></a>put方法分析</h2><p><code>put</code>方法可能是除了<code>get</code>方法之外另一个出镜率比较高的方法，<code>ConcurrentHashMap</code>对外公开的<code>put</code>方法首先会定位<code>Segment</code>，然后确认是否需要进行<code>Segment</code>的初始化行为，这两个过程在上文已经分析过了，在此不再复述，最后我们看到实际的方法功能是由<code>Segment</code>内部的<code>put</code>方法来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Segment&lt;K,V&gt; s;</div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> hash = hash(key);</div><div class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div><div class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></div><div class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></div><div class="line">        s = ensureSegment(j);</div><div class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么就让我们来详细了解一下<code>Segment</code>内部的<code>put</code>方法，以下是整体流程图：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/ConcurrentHashMap_Jdk7_put.png" alt="put方法处理流程"></p>
<p>从图中可以看出，整个方法由锁确保了在并发情况下的正确性，主要的业务逻辑其实比较简单：根据传入元素的哈希值，判断是否已经存在相同键值的元素，如果没有的话，那么就会新建一个<code>HashEntry</code>对象插入(<em>值得注意的是，这个新节点会成为链条的起始节点</em>)，否则根据参数<code>onlyIfAbsent</code>来确定是否更新旧值。整个流程图中，值得我们关注的有两个方法：一个是锁获取方法<code>scanAndLockForPut</code>，另一个扩容方法<code>rehash</code>。</p>
<h3 id="scanAndLockForPut"><a href="#scanAndLockForPut" class="headerlink" title="scanAndLockForPut"></a>scanAndLockForPut</h3><p><code>scanAndLockForPut</code>方法的逻辑同<code>scanAndLock</code>方法非常相似，两者都是先以非阻塞的方式尝试获取锁，当超过有限次数之后，会进入阻塞方式的锁请求。在这个过程当中，两个方法都会对此节点可能的位置进行定位(<em>根据文档的注释，貌似是一种<strong>代码预热</strong>行为，因为在获取锁之后，接下来的动作也将是对节点的定位</em>)。此外，如果节点定位成功之后发现首节点发生变化的话，那么又会重新进行定位(<em>这其中<code>entryForHash</code>方法内部确保了总是能及时看见最新值，由<code>UNSAFE.getObjectVolatile</code>提供友情支持</em>)。而<code>scanAndLockForPut</code>多出来的一个功能点是，它会根据实际情况推测，在一定的条件下预先创建新节点(<em>熟悉hadoop的同学一定不陌生，专门有关于<strong>推测执行</strong>的配置</em>)。以下是完整的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</div><div class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</div><div class="line">    HashEntry&lt;K,V&gt; e = first;</div><div class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></div><div class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</div><div class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></div><div class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></div><div class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                retries = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</div><div class="line">                retries = <span class="number">0</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                e = e.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</div><div class="line">            lock();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</div><div class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</div><div class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></div><div class="line">            retries = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>扩容的基本思路比较简单：创建一个新数组，容量是当前数组的2倍，然后将旧数组的项经过重新散列赋值到新数组，最终将<code>Segment</code>内部的<code>table</code>属性指向新数组。不过有一点需要注意，<strong>由于扩容采用的是倍数2，那么节点经过重新计算的索引值，要么和原先相同，要么新索引＝原索引＋原数组容量</strong>(<em>美团的<a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">这篇文章</a>对这个问题说明的比较清楚</em>)。利用这一点，在碰到冲突链的时候，会首先寻找冲突链中第一个所有后续节点新索引值和其保持一致的节点，然后直接把这部分链赋值到新数组，这样可以避免一些不必要的节点创建行为，下面我将通过源码和图片结合的方式进行一下说明。</p>
<p>我们假设冲突链有5个节点：A、B、C、D、E，其中A和C新索引值是2保持不变，B、D、E新索引值是18：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/chm_rehash_step1.png" alt="初始状态"></p>
<p>扩容过程如果发现冲突链，那么为了减少不必要的节点创建，首先会循着冲突链寻找可复用的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HashEntry&lt;K,V&gt; lastRun = e;</div><div class="line"><span class="keyword">int</span> lastIdx = idx;</div><div class="line"><span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="keyword">null</span>; last = last.next) &#123;</div><div class="line">	<span class="keyword">int</span> k = last.hash &amp; sizeMask;</div><div class="line">	<span class="keyword">if</span> (k != lastIdx) &#123;</div><div class="line">		lastIdx = k;</div><div class="line">		lastRun = last;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段循环结束之后，<code>lastIdx</code>为18，<code>lastRun</code>指向D，这意味着D节点及其后续所有节点都有相同的索引值：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/chm_rehash_step2.png" alt="循环处理"></p>
<p>找到可复用的链之后，先将其赋值到新数组，然后再处理原先冲突链的前半部分，这里值得注意的是插入到新数组之后，节点的顺序会同原先在旧数组的顺序相反：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">newTable[lastIdx] = lastRun;</div><div class="line"><span class="comment">// Clone remaining nodes</span></div><div class="line"><span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</div><div class="line">	V v = p.value;</div><div class="line">	<span class="keyword">int</span> h = p.hash;</div><div class="line">	<span class="keyword">int</span> k = h &amp; sizeMask;</div><div class="line">	HashEntry&lt;K,V&gt; n = newTable[k];</div><div class="line">	newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终结果如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/chm_rehash_step3.png" alt="迁移完成"></p>
<h2 id="先乐观后悲观的size"><a href="#先乐观后悲观的size" class="headerlink" title="先乐观后悲观的size"></a>先乐观后悲观的size</h2><p>为了避免热点域问题，<code>ConcurrentHashMap</code> 并没有定义一个统一的<code>size</code>属性，而是在每个<code>Segment</code>对象里定义了<code>size</code>属性，这样一来使得获取整个集合的元素总数不是那么的容易。出于性能以及准确性的权衡，实际中采用的是先乐观后悲观的理念：首先尝试三次在不加锁的情况下，对所有<code>Segment</code>的<code>size</code>和<code>modCount</code>进行累加，如果连续两次<code>modCount</code>的累加结果一致，则认定统计的<code>size</code>总和有效，否则所有的<code>Segment</code>分段锁都进行加锁操作，再进行统计。(<em>方法<code>containsValue</code>也采用了类似的策略</em>)</p>
<p>结合源代码，再好好理解一下整个过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></div><div class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></div><div class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></div><div class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></div><div class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></div><div class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</div><div class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></div><div class="line">            &#125;</div><div class="line">            sum = <span class="number">0L</span>;</div><div class="line">            size = <span class="number">0</span>;</div><div class="line">            overflow = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</div><div class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div><div class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</div><div class="line">                    sum += seg.modCount;</div><div class="line">                    <span class="keyword">int</span> c = seg.count;</div><div class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</div><div class="line">                        overflow = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (sum == last)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            last = sum;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</div><div class="line">                segmentAt(segments, j).unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>顺便提一下，查看相关资料的时候，看见有人提到为何去掉了<code>size</code>属性的<code>volatile</code>修饰符。我根据文档注释猜测，应该是出于性能方面的考虑，因为对于<code>size</code>属性的修改一般都是在加锁的情况下(<em>方法<code>put</code>和方法<code>remove</code>都会先加锁</em>)，因此对于写<code>size</code>的情况下即使去掉<code>volatile</code>的修饰也没有影响，关键在于读取<code>size</code>的场景往往不会加锁(<em>方法<code>isEmpty</code>和方法<code>size</code></em>)，然而内存可见性的保证又是必须的，那么我们回头看看上面的代码解决这个场景的思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div></pre></td></tr></table></figure>
<p><code>Segment</code>对象的获取是通过<code>segmentAt</code>方法，那么再深入看一下此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Segment&lt;K,V&gt; <span class="title">segmentAt</span><span class="params">(Segment&lt;K,V&gt;[] ss, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> u = (j &lt;&lt; SSHIFT) + SBASE;</div><div class="line">    <span class="keyword">return</span> ss == <span class="keyword">null</span> ? <span class="keyword">null</span> :</div><div class="line">        (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(ss, u);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以明显看到，在读取具体的<code>Segment</code>使用了<code>UNSAFE.getObjectVolatile</code>来内存可见性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要分析了<code>ConcurrentHashMap</code>基本原理和的几个常用方法，可以看到除了使用分段锁的概念对锁粒度进行拆分，在几个方法内部还包含了不少的优化之处(<em>代码预热、推测执行、先乐观后悲观等</em>)，其中的思想有不少值得我们学习体会和借鉴。另外，JDK从7升级到8之后，除了带来FP、Stream等一系列新概念之外，<code>ConcurrentHashMap</code>也进行了翻天覆地的重构，新的实现方式已经抛弃了目前的分段锁概念，关于对新的<code>ConcurrentHashMap</code>的学习将留待后期有时间再继续总结。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="external">Java并发编程实战</a></p>
<p><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="external">Java并发编程的艺术</a></p>
<p><a href="https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/sun/misc/Unsafe.java" target="_blank" rel="external">Unsafe</a></p>
<p><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;是程序开发中经常被使用到的一个哈希表实现，然而在多线程情况下，使用&lt;code&gt;HashMap&lt;/code&gt;却可能引发程序异常，这是因为它被设计为非线程安全。如果想要确保在多线程场景下的正确性，那么早些时候可能除了使用&lt;code&gt;sychronized&lt;/code&gt;或者&lt;code&gt;HashTable&lt;/code&gt;之外，并没有太好的选择。但是当1.5版本引入JUC包之后，在你的工具库里就多了一个更好的选择：&lt;code&gt;ConcurrentHashMap&lt;/code&gt;。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="JUC" scheme="https://lukaicheng.github.io/tags/JUC/"/>
    
      <category term="ConcurrentHashMap" scheme="https://lukaicheng.github.io/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java并发基础--理解volatile</title>
    <link href="https://lukaicheng.github.io/2017/07/23/Comprehend-volatile/"/>
    <id>https://lukaicheng.github.io/2017/07/23/Comprehend-volatile/</id>
    <published>2017-07-23T15:52:56.000Z</published>
    <updated>2017-07-23T15:59:32.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>众所周知，Java语言是通过共享内存的方式，来实现多线程之间的通信行为。为了保证共享变量的值能在不同线程之间得到一致地更新，可以考虑使用<code>synchronized</code>来确保共享变量的可见性。除此之外，Java语言还提供了另一种机制：<code>volatile</code>。使用<code>volatile</code>同样也提供对共享变量内存可见性的保证，并且它的运行时开销相比<code>sychronized</code>会更少，这种行为是由Java内存模型所确保的。下面就以<code>volatile</code>为中心，梳理并总结一下对内存可见性、重排序、Java内存模型、happens-before规则、内存屏障等一系列概念的理解。</p>
<a id="more"></a>
<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>首先来了解一下什么是内存可见性，以及为什么会发生这个问题。</p>
<h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>可见性问题是造成很多Java多线程程序错误的根源，其主要是指在多线程应用中，不同线程对同一个共享变量分别进行读写时，如果没有采用正确的同步行为，那么可能会出现读线程无法适时的看到其他线程写入共享变量的值。</p>
<p>比如以下这个程序，一个线程重复的调用方法<code>one()</code>，另外一个线程重复调用方法<code>two()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123; i++; j++; &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">" j="</span> + j);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么某些时候方法<code>two()</code>可能打印出来变量<code>j</code>的值大于另一个变量<code>i</code>的值。</p>
<p>而引发这个问题的原因归结起来主要是两个：<strong>CPU高速缓存和重排序行为</strong></p>
<h3 id="CPU高速缓存"><a href="#CPU高速缓存" class="headerlink" title="CPU高速缓存"></a>CPU高速缓存</h3><p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中。因此在某些时刻，CPU上的缓存数据可能与内存中的数据是不一致的，所以极有可能出现某个线程对共享变量设置的新值还保存在高速缓存中且未被写回到内存，而这时候如果有另一个线程读取该共享变量，就会读取到内存中的旧值。</p>
<h3 id="重排序行为"><a href="#重排序行为" class="headerlink" title="重排序行为"></a>重排序行为</h3><p>从编译源程序到运行时CPU执行指令，出于性能方面的考虑，这个过程中常常会对原始程序指令做出重排序行为，主要包括<strong>编译器重排序</strong>和<strong>处理器重排序</strong>：</p>
<ul>
<li><strong>编译器重排序</strong>：编译器在编译阶段可以在不改变程序语义的情况下，对生成的目标代码进行重新排列。</li>
<li><strong>处理器重排序</strong>：现代处理器采用指令级并行技术将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
</ul>
<p>正是由于存在这种情况，如果没有正确的同步机制保证，程序可能出现意想不到的行为。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>明确了可见性问题极其原因，那么是时候了解<code>volatile</code>背后的Java内存模型，以及其如何确保<code>volatile</code>的内存可见性。</p>
<h3 id="Java内存模型概述"><a href="#Java内存模型概述" class="headerlink" title="Java内存模型概述"></a>Java内存模型概述</h3><p>由于Java倡导”一次编写，到处运行“的理念，为了屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果，Java语言为程序员以及JVM实现者提供了一种抽象的内存模型规范，下面是引用自规范的原话：</p>
<blockquote>
<p>A <em>memory model</em> describes, given a program and an execution trace of that program, whether the execution trace is a legal execution of the program. The Java programming language memory model works by examining each read in an execution trace and checking that the write observed by that read is valid according to certain rules.</p>
<p>The memory model describes possible behaviors of a program. An implementation is free to produce any code it likes, as long as all resulting executions of a program produce a result that can be predicted by the memory model.</p>
</blockquote>
<p>简而言之，Java内存模型主要目标就是<strong>确保程序执行可以产生可预期的行为</strong>。</p>
<p>下图先给出其抽象模型：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/java_memory_model.png" alt="Java内存模型"></p>
<p>从抽象角度看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储该线程读写所需的共享变量的副本，线程之间的通信由JMM控制，其决定一个线程对共享变量的写入何时对另一个线程可见。</p>
<p>了解了Java内存模型的基本概念和抽象视图之后，接下来是时候了解<strong>happens-before</strong>概念了。</p>
<h3 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a>Happens-Before</h3><p>JSR-133使用happens-before的概念来指定两个操作之间的执行顺序，其中两个操作可以在一个线程内，也可以在不同线程之间。其主要定义如下：</p>
<ol>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作<strong>可见</strong>，并且第一个操作的执行顺序排在第二个操作之前。(<em>对程序员的承诺</em>)</li>
<li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行，如果重排序之后的执行结果与按照happens-before关系执行的结果一致，那么这种重排序并不非法。(<em>对JMM实现者的约束</em>)</li>
</ol>
<p>java内存模型提供了一套happens-before规则来指导程序员如何定义程序的操作顺序以提供正确的内存可见性，其中就有一条关于<code>volatile</code>的规则：</p>
<p><strong>volatile变量规则 - 对一个volatile域的写，happens-before任意后续对这个volatile域的读。</strong></p>
<p>至此，对于java内存模型如何保证<code>volatile</code>变量的内存可见性，我们终于找到了依据。但是每个程序员内心都应该是充满好奇心，所以接下来，我们再稍微了解一下这条happens-before规则是如何保证<code>volatile</code>的语义。</p>
<h3 id="重排序规则"><a href="#重排序规则" class="headerlink" title="重排序规则"></a>重排序规则</h3><p>前面我们已经知道，引发内存可见性的原因主要之一可能是重排序问题，因此为了实现<code>volatile</code>的内存语义，Java内存模型指定了<code>volatile</code>重排序规则表以禁止某些指令的重排序：</p>
<table>
<thead>
<tr>
<th><strong>是否能重排序</strong></th>
<th><em>第二个操作</em></th>
<th><em>第二个操作</em></th>
<th><em>第二个操作</em></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>第一个操作</em></td>
<td>普通读写</td>
<td>volatile读</td>
<td>volatile写</td>
</tr>
<tr>
<td>普通读写</td>
<td></td>
<td></td>
<td>No</td>
</tr>
<tr>
<td>volatile读</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>volatile写</td>
<td></td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>这个规则表明确规定了针对<code>volatile</code>域的读写和普通读写之间的重排序行为是否被允许，根据这个规则表，编译器就可以在生成字节码时，通过往指令序列中插入特定的内存屏障来禁止关于<code>volatile</code>域的特定类型的重排序行为。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>内存屏障的含义在维基百科里定义如下：</p>
<blockquote>
<p><strong>内存屏障</strong>，也称<strong>内存栅栏</strong>，<strong>内存栅障</strong>，<strong>屏障指令</strong>等，是一类<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C" target="_blank" rel="external">同步屏障</a>指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果</p>
</blockquote>
<p>Java内存模型把内存屏障分为4类：</p>
<ul>
<li><strong>LoadLoad</strong>(<em>Load1;LoadLoad;Load2</em>)：确保Load1数据的装载先于Load2及后续装载指令的装载</li>
<li><strong>StoreStore</strong>(<em>Store1;StoreStore;Store2</em>)：确保Store1数据对其他处理器可见(刷新到内存)先于Store2及 所有后续存储指令的存储</li>
<li><strong>LoadStore</strong>(<em>Load1;LoadStore;Store2</em>)：确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存</li>
<li><strong>StoreLoad</strong>(<em>Store1;StoreLoad;Load2</em>)：确保Store1数据对其他处理变得可见(刷新到内存)先于Load2及所有后续装载指令的装载。使该屏障之前的所有内存访问指令(存储和装载指令)完成之后，才执行该屏障之后的内存访问指令。</li>
</ul>
<p>针对<code>volatile</code>域的读写会依据下表所示插入内存屏障：</p>
<table>
<thead>
<tr>
<th><strong>需要插入的屏障</strong></th>
<th><em>第二个操作</em></th>
<th><em>第二个操作</em></th>
<th><em>第二个操作</em></th>
<th><em>第二个操作</em></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>第一个操作</em></td>
<td>普通读</td>
<td>普通写</td>
<td>volatile读</td>
<td>volatile写</td>
</tr>
<tr>
<td>普通读</td>
<td></td>
<td></td>
<td></td>
<td><code>LoadStore</code></td>
</tr>
<tr>
<td>普通写</td>
<td></td>
<td></td>
<td></td>
<td><code>StoreStore</code></td>
</tr>
<tr>
<td>volatile读</td>
<td><code>LoadLoad</code></td>
<td><code>LoadStore</code></td>
<td><code>LoadLoad</code></td>
<td><code>LoadStore</code></td>
</tr>
<tr>
<td>volatile写</td>
<td></td>
<td></td>
<td><code>StoreLoad</code></td>
<td><code>StoreStore</code></td>
</tr>
</tbody>
</table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，从<code>volatile</code>角度看去，整个因果线条已经相当明显。首先给出内存可见性的定义，进一步分析其可能引发的原因，从而转到了为解决内存可见性问题而提出的Java内存模型，结合<code>volatile</code>引出了该内存模型的核心概念：happens-before，随后分析组成<code>volatile</code>这条happens-before规则背后的重排序规则，最终以内存屏障概念收尾。本文并不强求面面俱到，而是以自己理解<code>volatile</code>的方式来讲诉其中的因果关系，个人感觉对于学习这一块的相关概念是一种比较好的思路，如果需要更深刻了解每一种概念，可以查看参考中的一些文档或者自行搜索。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.4" target="_blank" rel="external">volatile Fields</a></p>
<p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4" target="_blank" rel="external">Memory Model</a></p>
<p><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="external">The JSR-133 Cookbook for Compiler Writers</a></p>
<p><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机</a></p>
<p><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="external">Java并发编程的艺术</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C" target="_blank" rel="external">内存屏障</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;众所周知，Java语言是通过共享内存的方式，来实现多线程之间的通信行为。为了保证共享变量的值能在不同线程之间得到一致地更新，可以考虑使用&lt;code&gt;synchronized&lt;/code&gt;来确保共享变量的可见性。除此之外，Java语言还提供了另一种机制：&lt;code&gt;volatile&lt;/code&gt;。使用&lt;code&gt;volatile&lt;/code&gt;同样也提供对共享变量内存可见性的保证，并且它的运行时开销相比&lt;code&gt;sychronized&lt;/code&gt;会更少，这种行为是由Java内存模型所确保的。下面就以&lt;code&gt;volatile&lt;/code&gt;为中心，梳理并总结一下对内存可见性、重排序、Java内存模型、happens-before规则、内存屏障等一系列概念的理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="volatile" scheme="https://lukaicheng.github.io/tags/volatile/"/>
    
      <category term="JUC" scheme="https://lukaicheng.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池总结</title>
    <link href="https://lukaicheng.github.io/2017/07/19/ThreadPoolExecutor-summary/"/>
    <id>https://lukaicheng.github.io/2017/07/19/ThreadPoolExecutor-summary/</id>
    <published>2017-07-19T09:50:41.000Z</published>
    <updated>2017-07-20T07:14:32.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>java.util.concurrent.ThreadPoolExecutor</code>是JDK提供的一个线程池实现，在实际项目中是最 常用的JUC组件之一。通过合理使用线程池，可以复用已创建的线程，这不仅能够降低创建和销毁线程的整体消耗，还能够更快速地响应任务，并且通过线程池统一分配、管理、监控，也可以避免无限制地创建线程而造成的系统故障。</p>
<a id="more"></a>
<h2 id="线程池构造"><a href="#线程池构造" class="headerlink" title="线程池构造"></a>线程池构造</h2><p>通常情况下，我们会选择使用<code>java.util.concurrent.Executors</code>提供的几个工厂方法来创建线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个可以按需创建线程的线程池</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                     <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建一个固定线程数的线程池</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建一个只包含单个线程的线程池</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">           (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                   <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                   <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除此之外，如果对于<code>ThreadPoolExecutor</code>较为熟悉的话，更加推荐的方式是，通过选定合适的配置参数，直接使用构造器来创建一个线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                          <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                          <span class="keyword">long</span> keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory,</div><div class="line">                          RejectedExecutionHandler handler) &#123;</div><div class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt; corePoolSize ||</div><div class="line">        keepAliveTime &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">    <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造器中每个参数的含义解释如下：</p>
<ul>
<li><strong>corePoolSize</strong>：线程池的基本大小。线程池会保持这个数量的线程，即使其中包含空闲线程。当线程池的线程数量少于此数量，那么提交新任务会创建一个新线程(<em>即使有空闲线程</em>)。</li>
<li><strong>maximumPoolSize</strong>：线程池允许创建的最大线程数量。</li>
<li><strong>keepAliveTime &amp; unit</strong>：当线程池的线程数量超过基本大小时，多余的线程能够维持空闲的时间。</li>
<li><strong>workQueue</strong>：阻塞队列，用于转移或保存已提交的任务。</li>
<li><strong>threadFactory</strong>：线程工厂，用于创建新线程的工厂类。</li>
<li><strong>handler(RejectExecutionHandler)</strong>：饱和策略。当提交新任务时，如果碰到线程池关闭或者线程池的线程数达到了最大线程数且阻塞队列也达到最大容量，那么就会触发饱和策略。</li>
</ul>
<h2 id="合二为一的CTL"><a href="#合二为一的CTL" class="headerlink" title="合二为一的CTL"></a>合二为一的CTL</h2><p><code>ThreadPoolExecutor</code>声明了一个原子整型变量的属性<code>ctl</code>用于表达主要的控制状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</div></pre></td></tr></table></figure>
<p>这是一个二合一的属性，之所以这么说，是因为它实际包装了两个概念：<code>workerCount</code>和<code>runState</code>。</p>
<p>所谓的<code>workerCount</code>是指已经允许运行并且未被允许停止的工作线程数量，由于<code>ctl</code>只有32位，但又要表达两个概念，因此将低位的29位用于<code>workerCount</code>，这限制了工作线程数量最多只能为2<sup>29</sup> -1(<em>后期这个限制如果变成问题，按照Doug Lea的说法会考虑将ctl变更成<code>AtomicLong</code>类型</em>)。</p>
<p><code>runState</code>由<code>ctl</code>的高3位来表示，主要提供对于整个线程池的生命周期的控制，目前有五种状态：</p>
<ul>
<li><strong>RUNNING</strong>：接受新任务，并且会处理已排队任务。</li>
<li><strong>SHUTDOWN</strong>：不接受新任务，但是会处理已排队任务。</li>
<li><strong>STOP</strong>：不接受新任务，也不处理已排队任务，并且会中断正在执行的任务。</li>
<li><strong>TIDYING</strong>：所有的任务都已经终止，工作者线程数量为零，那么会变迁到TIDYING状态，并将运行<code>terminated()</code>方法。</li>
<li><strong>TERMINATED</strong>：<code>terminated()</code>方法调用已经完成。</li>
</ul>
<p>从数值角度看，<code>runState</code>会随着状态的变迁表现出<strong>单调递增</strong>，整体变迁过程如图所示：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/ThreadPoolExecutor_state_transition.png" alt="线程池状态变迁图"></p>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>线程池中的任务队列，主要是用于暂存待执行的任务，本质上它是阻塞队列。一般情况下，如果提交新任务时发现线程池的工作线程数量已经超过<strong>corePoolSize</strong>，那么首先会尝试将新任务入队。当然根据实际任务队列类型的不同，这个行为可能会有不同的表现，通常会有以下三种常用的策略：</p>
<ul>
<li><strong>同步移交</strong>：一般的默认选择是使用<code>SynchronousQueue</code>，比如<code>Executors.newCachedThreadPool</code>就使用了这种策略。当新任务到达时，并不会进行排队行为，而是将其直接移交给工作线程，如果此时没有空闲线程，会尝试进行创建，否则会触发饱和策略。这就意味着使用这种类型的阻塞队列往往需要配合一个非常大甚至是无穷大的<strong>maximumPoolSize</strong>线程池定义。但是这种情况下，如果任务的处理速度跟不上任务达到速度的话，可能导致线程越来越多，进而引发系统问题。采用这种策略的好处是更加高效，因为任务直接移交给执行线程，并且可以避免某些相关依赖的任务可能引发的线程饥饿死锁。</li>
<li><strong>无界队列</strong>：最常见的例子是使用一个未定义容量的<code>LinkedBlockingQueue</code>，当新任务到达时，如果发现所有的基本线程都有任务在执行，那么会将任务入队，而考虑到队列是无界的，那么<strong>maximumPoolSize</strong>会被忽略，整个线程池不会创建超过<strong>corePoolSize</strong>定义的线程数，所以任务只能等待已有的基本线程空闲下来进行处理。因此，如果任务到达速度超过其处理速度，那么工作队列会无限制的增大。</li>
<li><strong>有界队列</strong>：一种更为稳妥的策略是使用类似<code>ArrayBlockingQueue</code>这样的有界阻塞队列，如果配合定义一个合理的<strong>maximumPoolSize</strong>，能够有效的避免资源衰竭的情况，但是这两个参数之间的调节可能并不是那么好把握，这中间需要较好的进行权衡。定义较大的队列容量和较小的线程数量，有助于减少CPU使用率、系统资源以及上下文切换开销，但是付出的代价可能是较低的吞吐量。使用较小的队列和较大的线程数量，可以使CPU保持忙碌，但可能遭遇不可接受的调度开销，其也会降低吞吐量。</li>
</ul>
<p>除此之外，如果你的任务有优先级之分，那么可以考虑使用 <code>PriorityBlockingQueue</code>这样的优先队列，它能够使任务不按照提交的顺序来执行，然而需要警惕的是，在一定条件下，也极有可能引起低优先级任务永远无法执行的情况。</p>
<h2 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h2><p>当我们使用<code>ThreadPoolExecutor.execute</code>提交新任务时，如果碰到线程池已经关闭或者线程池饱和(<em>线程数达到最大允许的线程数量并且工作队列也达到最大容量</em>)的情况，那么就会触发饱和策略的执行。</p>
<p>接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JDK已经预定义了<code>AbortPolicy</code>、<code>CallerRunsPolicy</code>、<code>DiscardPolicy</code>、<code>DiscardOldestPolicy</code>四种饱和策略。如果没有特别指定，默认情况下会启用<code>AbortPolicy</code>，其会抛出<code>RejectedExecutionException</code>的运行时异常。<code>DiscardPolicy</code>则会悄悄忽略新任务，并且什么事也不做。<code>DiscardOldestPolicy</code>会抛弃原本下一个将要执行的任务，并且尝试重新提交新任务(<em>使用这种策略需要注意的是，如果任务队列是优先队列的话，那么被抛弃的会是优先级最高的任务</em>)。<code>CallerRunsPolicy</code>实现了一种调节机制，它会让任务提交者线程自身执行新任务，避免再重新提交任务，从而使得线程池中的工作者线程可以有时间来处理任务。</p>
<p>如果以上几种策略都不满足实际需求，那么你可以通过实现<code>RejectedExecutionHandler</code>接口来进行定制化，并且在创建线程池时，配置你自定义的饱和策略。</p>
<h2 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h2><p>线程池最常被使用的方法就是<code>execute</code>，它接受一个新任务，并尝试执行，大致的处理流程如下所述：</p>
<ol>
<li>判断当前工作线程数量是否小于<strong>corePoolSize</strong>，如果是则会创建一个新线程来处理任务，否则进入下一步判断。</li>
<li>判断任务队列是否未满，如果未满则直接将任务入队等待后续执行，否则进行下一步判断。</li>
<li>判断当前工作线程数量是否小于<strong>maximumPoolSize</strong>，如果是则会创建一个新线程来处理任务，否则(<em>线程池已经达到饱和</em>)将会触发饱和策略。</li>
</ol>
<p>下图展示了整个处理过程：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/ThreadPoolExecutor_task_submit.png" alt="任务提交流程"></p>
<p>当然上面这个过程是较为粗粒度的描述，如果你查看实际的源码，那么会发现其实在这中间还包含了不少细节考虑，下面以源码注释的方式来进行说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">	<span class="keyword">int</span> c = ctl.get();</div><div class="line">	<span class="comment">//判断当前工作线程是否小于基本线程数，如果是则尝试创建工作线程，否则进入后续判断</span></div><div class="line">	<span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">		<span class="comment">//在创建新线程之前，会检查线程池状态，并且重新确认工作线程是否小于基本线程</span></div><div class="line">		<span class="comment">//如果添加成功则直接返回，否则继续后续判断</span></div><div class="line">		<span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		c = ctl.get();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//判定线程池是否还处于运行状态，如果满足，则尝试往队列添加新任务</span></div><div class="line">	<span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">		<span class="comment">//考虑到其他线程对线程池的操作，需要重新对线程池状态进行检测</span></div><div class="line">		<span class="keyword">int</span> recheck = ctl.get();</div><div class="line">		<span class="comment">//如果发现此时线程池已经不在运行状态，那么会尝试将任务从队列删除</span></div><div class="line">		<span class="comment">//这是由于线程关闭之后，不能再接受新任务的提交</span></div><div class="line">		<span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">			<span class="comment">//如果线程池已不在运行状态并且任务删除成功，那么触发饱和策略处理此任务</span></div><div class="line">			reject(command);</div><div class="line">		<span class="comment">//此时可能情况：1.线程池还在运行状态 2.线程池未在运行状态，但往队列删除任务失败</span></div><div class="line">		<span class="comment">//不管是情况1还是情况2，队列此时都不为空，需要判断工作线程是否为零这种可能性</span></div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">			<span class="comment">//确认工作线程为零，而此时队列里还有待执行任务，那么尝试创建线程处理队列中的任务</span></div><div class="line">			<span class="comment">//请注意，如果线程池状态已经越过SHUTDOWN，则不会考虑创建新线程</span></div><div class="line">			addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//如果线程池已不在运行状态或者添加队列失败(队列已满)，那么尝试创建工作线程</span></div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line">		<span class="comment">//此时判定为线程池已关闭或者线程池是饱和状态，需要触发饱和策略</span></div><div class="line">		reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h2><p><code>ThreadPoolExecutor</code>提供了<code>shutdown</code>和<code>shutdownNow</code>两个方法用于关闭线程池。在上面讲述线程池状态时，提到过调用<code>shutdown</code>方法会让线程池的状态变迁到<strong>SHUTDOWN</strong>，而调用<code>shutdownNow</code>会让线程池状态直接变迁到<strong>STOP</strong>。 另外这两个方法之间，差异比较大的一点是，调用<code>shutdown</code>方法只会阻止任务继续提交，但是队列内的任务依然会执行完成，然而调用<code>shutdownNow</code>不仅会阻止任务提交，连队列内的任务也不会执行，甚至还会中断已开始的任务。</p>
<p>结合<code>shutdown</code>方法的源码，再了解一下大致过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">  	<span class="comment">//使用全局锁进行锁定 </span></div><div class="line">	mainLock.lock();</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		checkShutdownAccess();</div><div class="line">		<span class="comment">//修改线程池状态为SHUTDOWN</span></div><div class="line">		advanceRunState(SHUTDOWN);</div><div class="line">		<span class="comment">//中断空闲的工作线程</span></div><div class="line">		interruptIdleWorkers();</div><div class="line">		<span class="comment">//提供的扩展方法，供子类扩展使用</span></div><div class="line">		onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="comment">//释放全局锁</span></div><div class="line">		mainLock.unlock();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//尝试终结线程池</span></div><div class="line">	tryTerminate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着结合<code>shutdownNow</code>方法的源码，了解和<code>shutdownNow</code>方法的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</div><div class="line">	List&lt;Runnable&gt; tasks;</div><div class="line">	<span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">	<span class="comment">//使用全局锁进行锁定 </span></div><div class="line">	mainLock.lock();</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		checkShutdownAccess();</div><div class="line">		<span class="comment">//修改线程池状态为STOP</span></div><div class="line">		advanceRunState(STOP);</div><div class="line">		<span class="comment">//尝试中断所有的工作线程</span></div><div class="line">		interruptWorkers();</div><div class="line">		<span class="comment">//将任务队列排空</span></div><div class="line">		tasks = drainQueue();</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="comment">//释放全局锁</span></div><div class="line">		mainLock.unlock();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//尝试终结线程池</span></div><div class="line">	tryTerminate();</div><div class="line">	<span class="keyword">return</span> tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="线程数配置"><a href="#线程数配置" class="headerlink" title="线程数配置"></a>线程数配置</h2><p>对于计算密集型任务，在拥有N<sub>cpu</sub>个处理器的系统上，可以考虑将线程池大小设为N<sub>cpu</sub>+1。对于IO密集型任务，则可以考虑将线程池设置为2 * N<sub>cpu</sub>。</p>
<p>在Java并发编程实战一书中，还提出了对于一般的情况可以使用的公式：</p>
<p> N<sub>threads</sub> = N<sub>cpu</sub>  *  U<sub>cpu</sub> *   ( 1 + W / C)</p>
<p>其中CPU数目可以通过以下方法获取:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> N_CPUS = Runtime.getRuntime().availableProcessors();</div></pre></td></tr></table></figure>
<p>U<sub>cpu</sub>表示CPU利用率，可能需要在某个基准负载下进行监控。</p>
<p>W/C 是等待时间与计算时间的比值，可能借助分析或监控工具进行粗略估算。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="external">Java并发编程实战</a></p>
<p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html" target="_blank" rel="external">ThreadPoolExecutor Javadocs</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;java.util.concurrent.ThreadPoolExecutor&lt;/code&gt;是JDK提供的一个线程池实现，在实际项目中是最 常用的JUC组件之一。通过合理使用线程池，可以复用已创建的线程，这不仅能够降低创建和销毁线程的整体消耗，还能够更快速地响应任务，并且通过线程池统一分配、管理、监控，也可以避免无限制地创建线程而造成的系统故障。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JUC" scheme="https://lukaicheng.github.io/tags/JUC/"/>
    
      <category term="ThreadPoolExecutor" scheme="https://lukaicheng.github.io/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>CGlib教程[译]</title>
    <link href="https://lukaicheng.github.io/2017/06/30/CGlib-tutorial-translate/"/>
    <id>https://lukaicheng.github.io/2017/06/30/CGlib-tutorial-translate/</id>
    <published>2017-06-30T09:16:18.000Z</published>
    <updated>2017-06-30T09:25:34.879Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/cglib/cglib/wiki/Tutorial" target="_blank" rel="external">原文链接</a></p>
<p>原始文章：<a href="http://mydailyjava.blogspot.no/2013/11/cglib-missing-manual.html" target="_blank" rel="external">http://mydailyjava.blogspot.no/2013/11/cglib-missing-manual.html</a></p>
<h2 id="增强器"><a href="#增强器" class="headerlink" title="增强器"></a>增强器</h2><p>让我们从<code>Enhancer</code>类开始，这可能是cglib库中最常被使用的类。一个增强器允许为没有接口的类型创建一个Java代理。<code>Enhancer</code>可以与java标准库的<code>Proxy</code>类做对比，后者是在Java 1.3时引入的。<code>Enhancer</code>动态地创建给定类型的子类而拦截所有的方法调用。与<code>Proxy</code>类不同的是，它对于类和接口都适用。接下来的例子和后续的一些例子都是基于这个简单的Java POJO：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String input)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello world!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>使用cglib，可以很容易地利用<code>Enhancer</code>和<code>FixedValue</code>回调接口产生的值替换<code>test(String)</code>方法的返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFixedValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">  enhancer.setSuperclass(SampleClass.class);</div><div class="line">  enhancer.setCallback(<span class="keyword">new</span> FixedValue() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">"Hello cglib!"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  SampleClass proxy = (SampleClass) enhancer.create();</div><div class="line">  assertEquals(<span class="string">"Hello cglib!"</span>, proxy.test(<span class="keyword">null</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述示例中，增强器会返回一个额外添加字节码的<code>SampleClass</code>子类(<em>an instrumented subclass of SampleClass</em>)的实例，对其所有的方法调用都会返回由上述匿名<code>FixedValue</code>实现生成的一个固定值。对象是由<code>Enhancer#create(Object...)</code>方法创建，此方法接收任意数量的参数以用于选择增强类中的任意一个构造器。(即使构造器仅仅是java字节码层面的方法，<code>Enhancer</code>也不能添加额外字节码到(<em>instrument</em>)构造器，而且它也不能添加额外字节码到(<em>instrument</em>) <code>static</code>或<code>final</code>的类。)如果你只想要创建一个类而不需要实例，<code>Enhancer#createClass</code>将创建一个可用于动态创建实例的<code>Class</code>实例。增强类中的所有构造器将以动态生成类的构造器作为委托供使用。</p>
<p>请注意，在上述例子中任意的方法调用都会被委托，也包括调用定义在<code>java.lang.Object</code>的方法。结果就是，调用<code>toString()</code>也将返回<code>&quot;Hello cglib!&quot;</code>。相反，对<code>proxy.hashCode()</code>的调用将会导致<code>ClassCastException</code>，这是因为<code>FixedValue</code>拦截器总是返回一个<code>String</code>，即使<code>Object#hashCode</code>签名提示了需要一个原始整型。</p>
<p>可以做出的的另一个观察是最终方法(<em>final method</em>)将不会被拦截。这种方法的一个例子是<code>Object#getClass</code>，当它被调用时会返回类似<code>SampleClass$$EnhancerByCGLIB$$e277c63c</code>的内容。这个类名是为了避免命名冲突而由cglib随机生成的。当你在程序代码里使用明确的类型时，请注意增强实例会有不同的类型。然而，由cglib生成的类会与被增强的类位于相同的包(因此能够覆盖包级私有方法)。同最终方法类似，子类化方法对增强最终类(<em>final class</em>)无能为力，因此像Hibernate这样的框架不能持久化最终类。</p>
<p>接下来，让我们看一个更强大的回调类，<code>InvocationHandler</code>，它也可以用于<code>Enhancer</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInvocationHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">  enhancer.setSuperclass(SampleClass.class);</div><div class="line">  enhancer.setCallback(<span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line">        <span class="keyword">throws</span> Throwable &#123;</div><div class="line">      <span class="keyword">if</span>(method.getDeclaringClass() != Object.class &amp;&amp; method.getReturnType() == String.class) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello cglib!"</span>;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Do not know what to do."</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  SampleClass proxy = (SampleClass) enhancer.create();</div><div class="line">  assertEquals(<span class="string">"Hello cglib!"</span>, proxy.test(<span class="keyword">null</span>));</div><div class="line">  assertNotEquals(<span class="string">"Hello cglib!"</span>, proxy.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个回调接口允许我们对被调用的方法进行应答。然而，当随着<code>InvocationHandler#invoke</code>方法对代理对象调用方法时，你应该要小心。此方法的所有调用都会被分派到同一个<code>InvocationHandler</code>，可能因此导致无限循环。为了避免这种情况，我们可以另一个回调分派器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodInterceptor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">  enhancer.setSuperclass(SampleClass.class);</div><div class="line">  enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span></span></div><div class="line">        <span class="keyword">throws</span> Throwable &#123;</div><div class="line">      <span class="keyword">if</span>(method.getDeclaringClass() != Object.class &amp;&amp; method.getReturnType() == String.class) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello cglib!"</span>;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> proxy.invokeSuper(obj, args);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  SampleClass proxy = (SampleClass) enhancer.create();</div><div class="line">  assertEquals(<span class="string">"Hello cglib!"</span>, proxy.test(<span class="keyword">null</span>));</div><div class="line">  assertNotEquals(<span class="string">"Hello cglib!"</span>, proxy.toString());</div><div class="line">  proxy.hashCode(); <span class="comment">// Does not throw an exception or result in an endless loop.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MethodInterceptor</code>允许对被拦截的方法进行完全控制，并提供一些实用程序来调用处于原始状态的增强类的方法。既然如此，人们为什么还会想使用其他方法呢？因为其他方法更有效率，并且cglib经常用在效率起重要作用的极端情况框架(<em>edge case frameworks</em>)里。例如<code>MethodInterceptor</code>的创建和链接需要生成不同类型的字节代码，并创建一些<code>InvocationHandler</code>不需要的运行时对象。因此，还有其他类可以与<code>Enhancer</code>一同使用：</p>
<p>1.<code>LazyLoader</code>：尽管<code>LayzLoader</code>的唯一方法与<code>FixedValue</code>拥有相同的方法签名，但<code>LazyLoader</code>从根本上与<code>FiexedValue</code>拦截器是不同的。<code>LazyLoader</code>实际上应该返回一个增强类的子类实例。仅当调用增强类的方法时这个实例才会被请求，然后存储下来以供将来对已生成代理的调用。如果你的对象创建代价非常昂贵而且不知道是否会被使用，那么这么做是合理的。请注意，对于代理对象和懒加载对象，增强类的一些构造器都必须被调用。这样的话，需要确认有另一种代价较小的(可能是受保护的)构造器是可用的或者为代理使用接口类型。你可以通过为<code>Enhancer#create(Object...)</code>提供参数来选择被调用的构造器。</p>
<p>2.<code>Dispatcher</code>：<code>Dispatcher</code>和<code>LazyLoader</code>很类似但是它会在每个方法调用时被调用而不需要存储已加载对象。这允许更改类的实现而不用更改对它的引用。再次，请注意 ，对于代理对象和已生成对象，被增强类的一些构造器都必须被调用。</p>
<p>3.<code>ProxyRefDispatcher</code>：这个类在它的签名里携带了一个指向被调用的代理对象的引用。这样允许将一些方法调用委托给代理的另一个方法。请注意，这很容易引发无限循环，并且如果在<code>ProxyRefDispatcher#loadObject(Object)</code>里调用相同的方法，将总会引发无限循环。</p>
<p>4.<code>NoOp</code>：<code>NoOp</code>并不像它的名字所说的一样什么都不做。相反，它会把每个方法调用委托给被增强类的方法实现。 </p>
<p>到目前为止，最后两种拦截器可能对你没有意义。如果总是将方法委托给增强类，那么为什么还想着要增强一个类呢？你是对的，这些拦截器只能与<code>CallbackFilter</code>一起使用，就如下面代码片段所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCallbackFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">  CallbackHelper callbackHelper = <span class="keyword">new</span> CallbackHelper(SampleClass.class, <span class="keyword">new</span> Class[<span class="number">0</span>]) &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getCallback</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span>(method.getDeclaringClass() != Object.class &amp;&amp; method.getReturnType() == String.class) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FixedValue() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"Hello cglib!"</span>;</div><div class="line">          &#125;;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> NoOp.INSTANCE; <span class="comment">// A singleton provided by NoOp.</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  enhancer.setSuperclass(MyClass.class);</div><div class="line">  enhancer.setCallbackFilter(callbackHelper);</div><div class="line">  enhancer.setCallbacks(callbackHelper.getCallbacks());</div><div class="line">  SampleClass proxy = (SampleClass) enhancer.create();</div><div class="line">  assertEquals(<span class="string">"Hello cglib!"</span>, proxy.test(<span class="keyword">null</span>));</div><div class="line">  assertNotEquals(<span class="string">"Hello cglib!"</span>, proxy.toString());</div><div class="line">  proxy.hashCode(); <span class="comment">// Does not throw an exception or result in an endless loop.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Enhancer</code>实例在它的<code>Enhancer#setCallbackFilter(CallbackFilter)</code>方法里接受一个<code>CallbackFilter</code>，并期望增强类的方法映射到<code>Callback</code>实例数组的数组索引。当在已创建的代理上调用一个方法时，<code>Enhancer</code>会选择相应的拦截器，并将被调用的方法分派给对应的<code>Callback</code>(这是至今为止所介绍的所有拦截器的标记接口)。为了使这个API不那么尴尬，cglib提供了一个<code>CallbackHelper</code>，它将代表一个<code>CallbackFilter</code> 并且会为你创建一个<code>Callback</code>的数组。上述增强对象将在功能上等同于<code>MethodInterceptor</code>例子中的对象，但是它允许你编写专门的拦截器，同时将调度逻辑与这些拦截器保持独立。</p>
<h2 id="它是如何工作的"><a href="#它是如何工作的" class="headerlink" title="它是如何工作的?"></a>它是如何工作的?</h2><p>当<code>Enhancer</code>创建一个类并在其创建之后，它将为注册为增强类的<code>Callback</code>的各个拦截器设置<code>private</code>字段。这意味着在由cglib创建的类定义在创建之后不能被重用，这是因为回调的注册没有成为已生成类的初始化阶段的一部分，而是当类已经被JVM初始化之后，由cglib手动准备。这也意味着由cglib创建的类在它们初始化之后从技术上讲并没有准备就绪，例如不能通过线路传送，因为在目标机器上加载的类不会存在回调接口。</p>
<p>依赖于已注册的拦截器，cglib可以注册额外的字段，例如像<code>MethodInterceptor</code>，在增强类或任何它的子类被拦截的每个方法都会注册两个私有静态字段(一个持有反射方法，另一个持有<code>MethodProxy</code>)。请注意，<code>MethodProxy</code>正在过度使用<code>FastClass</code>，其会触发额外的类创建并会在下面进一步描述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFixedValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">  enhancer.setSuperclass(SampleClass.class);</div><div class="line">  enhancer.setCallback(<span class="keyword">new</span> FixedValue() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">"Hello cglib!"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  SampleClass proxy = (SampleClass) enhancer.create();</div><div class="line">  assertEquals(<span class="string">"Hello cglib!"</span>, proxy.test(<span class="keyword">null</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>匿名的<code>FixValue</code>子类将很难从被增强的<code>SampleClass</code>引用，这样不论是匿名的<code>FixValue</code>实例还是持有@Test方法的类都不会被垃圾回收。这会在你的应用程序中引入令人讨厌的内容泄漏。因此，不要将cglib与非静态的内部类一起使用。(我仅在这个概述中这么使用是为了保持例子的简短)</p>
<p>最后，你不应该拦截<code>Object#finalize()</code>。由于cglib的子类化方式，拦截<code>finalize</code>是通过覆盖来实现，这通常是一个坏主意。拦截<code>finalize</code>的增强实例将会被垃圾收集器不同对待，也将会导致这些对象在JVM的终结队列(<em>finalization queue</em>)排队。另外，如果你在对被拦截的<code>finalize</code>调用中(意外地)创建了一个增强类的强引用(<em>a hard reference</em>)，那么你已经有效创建了一个不可回收的实例。这通常不是你想要的，因此需要注意最终方法永远不要被cglib拦截。<code>Object#wait</code>， <code>Object#notify</code> 和<code>Object#notifyAll</code>不会施加相同的问题。然而，请注意<code>Object#clone</code>可以被拦截可能是你不期望的事情。</p>
<h2 id="不可变bean"><a href="#不可变bean" class="headerlink" title="不可变bean"></a>不可变bean</h2><p>cglib的<code>ImmutableBean</code>允许你创建一个类似于像<code>Collections#immutableSet</code>的不可变的包装器。底层bean的所有更改都会被<code>IllegalStateException</code>阻止(然而，并不是被Java API所推荐的<code>UnsupportedOperationException</code>)。看一下bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleBean</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> String value;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = value;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以使得这个bean不可变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>(expected = IllegalStateException.class)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testImmutableBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  SampleBean bean = <span class="keyword">new</span> SampleBean();</div><div class="line">  bean.setValue(<span class="string">"Hello world!"</span>);</div><div class="line">  SampleBean immutableBean = (SampleBean) ImmutableBean.create(bean);</div><div class="line">  assertEquals(<span class="string">"Hello world!"</span>, immutableBean.getValue());</div><div class="line">  bean.setValue(<span class="string">"Hello world, again!"</span>);</div><div class="line">  assertEquals(<span class="string">"Hello world, again!"</span>, immutableBean.getValue());</div><div class="line">  immutableBean.setValue(<span class="string">"Hello cglib!"</span>); <span class="comment">// Causes exception.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从示例中可以看出，不可变的bean通过抛出<code>IllegalStateException</code>来阻止所有的状态更改。然而，bean的状态可以通过更改原始对象而改变。所有这些变化都将由<code>ImmutableBean</code>反映出来。</p>
<h2 id="Bean生成器"><a href="#Bean生成器" class="headerlink" title="Bean生成器"></a>Bean生成器</h2><p><code>BeanGenerator</code>是cgbli的另一个bean实用工具。它会在运行时为你创建一个bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanGenerator</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  BeanGenerator beanGenerator = <span class="keyword">new</span> BeanGenerator();</div><div class="line">  beanGenerator.addProperty(<span class="string">"value"</span>, String.class);</div><div class="line">  Object myBean = beanGenerator.create();</div><div class="line"></div><div class="line">  Method setter = myBean.getClass().getMethod(<span class="string">"setValue"</span>, String.class);</div><div class="line">  setter.invoke(myBean, <span class="string">"Hello cglib!"</span>);</div><div class="line">  Method getter = myBean.getClass().getMethod(<span class="string">"getValue"</span>);</div><div class="line">  assertEquals(<span class="string">"Hello cglib!"</span>, getter.invoke(myBean));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从示例中可以看出，<code>BeanGenerator</code>首先将一些属性作为名值对。在创建的时候，<code>BeanGenerator</code>为你创建访问器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;type&gt; get&lt;name&gt;()</div><div class="line"><span class="keyword">void</span> set&lt;name&gt;(&lt;type&gt;)</div></pre></td></tr></table></figure>
<p>当另一个库希望通过反射解析bean，但在运行时你不知道这些bean，这是非常有用的。(一个例子是Apache Wicket，它有很多bean相关的工作)</p>
<h2 id="Bean复制器"><a href="#Bean复制器" class="headerlink" title="Bean复制器"></a>Bean复制器</h2><p><code>BeanCopier</code>是另一个实用工具，它通过属性值复制bean。考虑另一个与<code>SampleBean</code>有相似属性的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherSampleBean</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> String value;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = value;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在你可以把属性从一个bean复制到另一个bean而不受特定类型的限定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanCopier</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  BeanCopier copier = BeanCopier.create(SampleBean.class, OtherSampleBean.class, <span class="keyword">false</span>);</div><div class="line">  SampleBean bean = <span class="keyword">new</span> SampleBean();</div><div class="line">  bean.setValue(<span class="string">"Hello cglib!"</span>);</div><div class="line">  OtherSampleBean otherBean = <span class="keyword">new</span> OtherSampleBean();</div><div class="line">  copier.copy(bean, otherBean, <span class="keyword">null</span>);</div><div class="line">  assertEquals(<span class="string">"Hello cglib!"</span>, otherBean.getValue()); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>BeanCopier#copy</code>调用一个(最终)可选的转换器，它允许在每个bean属性上做一些进一步操作。如果<code>BeanCopier</code>把第三个构造器参数设置为false而创建的，<code>Converter</code>会被忽略并且可以为空。</p>
<h2 id="批量bean"><a href="#批量bean" class="headerlink" title="批量bean"></a>批量bean</h2><p><code>BulkBean</code>允许通过数组而不是方法调用的方式来使用一组指定的bean访问器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBulkBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  BulkBean bulkBean = BulkBean.create(SampleBean.class,</div><div class="line">      <span class="keyword">new</span> String[]&#123;<span class="string">"getValue"</span>&#125;,</div><div class="line">      <span class="keyword">new</span> String[]&#123;<span class="string">"setValue"</span>&#125;,</div><div class="line">      <span class="keyword">new</span> Class[]&#123;String.class&#125;);</div><div class="line">  SampleBean bean = <span class="keyword">new</span> SampleBean();</div><div class="line">  bean.setValue(<span class="string">"Hello world!"</span>);</div><div class="line">  assertEquals(<span class="number">1</span>, bulkBean.getPropertyValues(bean).length);</div><div class="line">  assertEquals(<span class="string">"Hello world!"</span>, bulkBean.getPropertyValues(bean)[<span class="number">0</span>]);</div><div class="line">  bulkBean.setPropertyValues(bean, <span class="keyword">new</span> Object[] &#123;<span class="string">"Hello cglib!"</span>&#125;);</div><div class="line">  assertEquals(<span class="string">"Hello cglib!"</span>, bean.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>BulkBean</code>将一组getter名称、一组setter名称以及一组属性的类型作为构造器参数。最终生成的添加额外字节码的类(<em>the resulting instrumented class</em>)可以由<code>BulkBean#getPropertyValues(Object)</code>抽取为一个数组。类似的，一个bean的属性可以通过<code>BulkBean#setPropertyValues(Object, Object[])</code>设置。</p>
<h2 id="Bean映射"><a href="#Bean映射" class="headerlink" title="Bean映射"></a>Bean映射</h2><p>这是cglib最后一个bean的实用工具。<code>BeanMap</code>将bean所有的属性都转换成一个字符-对象映射的Java <code>Map</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanGenerator</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  SampleBean bean = <span class="keyword">new</span> SampleBean();</div><div class="line">  BeanMap map = BeanMap.create(bean);</div><div class="line">  bean.setValue(<span class="string">"Hello cglib!"</span>);</div><div class="line">  assertEquals(<span class="string">"Hello cglib"</span>, map.get(<span class="string">"value"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，<code>BeanMap#newInstance(Object)</code>方法允许重用相同的<code>Class</code>来为其他bean创建映射。</p>
<h2 id="Key工厂"><a href="#Key工厂" class="headerlink" title="Key工厂"></a>Key工厂</h2><p><code>KeyFactory</code>工厂允许动态创建由多个值组成的键，可以用在如<code>Map</code>这样的实现。为了做到这一点，<code>KeyFactory</code>需要接口来定义应该在这样的键中使用的值。这个接口必须包含名称为<code>newInstance</code>并且返回一个<code>Object</code>的单个方法。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleKeyFactory</span> </span>&#123;</div><div class="line">  <span class="function">Object <span class="title">newInstance</span><span class="params">(String first, <span class="keyword">int</span> second)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在一个key的实例可以被这样创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKeyFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//Key.class --&gt; SampleKeyFactory.class</span></div><div class="line">  SampleKeyFactory keyFactory = (SampleKeyFactory) KeyFactory.create(Key.class);</div><div class="line">  Object key = keyFactory.newInstance(<span class="string">"foo"</span>, <span class="number">42</span>);</div><div class="line">  Map&lt;Object, String&gt; map = <span class="keyword">new</span> HashMap&lt;Object, String&gt;();</div><div class="line">  map.put(key, <span class="string">"Hello cglib!"</span>);</div><div class="line">  assertEquals(<span class="string">"Hello cglib!"</span>, map.get(keyFactory.newInstance(<span class="string">"foo"</span>, <span class="number">42</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>KeyFactory</code>将会确保<code>Object#equals(Object)</code>和<code>Object#hashCode</code>方法的正确实现，以便最终的键对象能被<code>Map</code>或者<code>Set</code>使用。<code>KeyFactory</code>也在cglib库内部使用了很多。</p>
<h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><p>有些人可能已经从其他编程语言如Ruby或者Scala(其中mixins被叫做traits)知道了<code>Mixin</code>类的概念。cglib的<code>Mixin</code>允许将几个对象组合成一个对象。然而，为了这样做，这些对象必须由接口支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</div><div class="line">  <span class="function">String <span class="title">first</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</div><div class="line">  <span class="function">String <span class="title">second</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class1</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">first</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"first"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class2</span> <span class="keyword">implements</span> <span class="title">Interface2</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">second</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"second"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在类<code>Class1</code>和<code>Class2</code>可以通过额外的接口组合成一个单独的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MixinInterface</span> <span class="keyword">extends</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMixin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  Mixin mixin = Mixin.create(<span class="keyword">new</span> Class[]&#123;Interface1.class, Interface2.class,</div><div class="line">      MixinInterface.class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> Class1(), <span class="keyword">new</span> Class2()&#125;);</div><div class="line">  MixinInterface mixinDelegate = (MixinInterface) mixin;</div><div class="line">  assertEquals(<span class="string">"first"</span>, mixinDelegate.first());</div><div class="line">  assertEquals(<span class="string">"second"</span>, mixinDelegate.second());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>诚然，<code>Mixin</code> API是相当尴尬的，因为它需要用于混合的类来实现一些接口，但这样一来问题也可以通过不添加额外字节码(<em>non-instrumented</em>)的Java来解决。</p>
<h2 id="字符串切换器"><a href="#字符串切换器" class="headerlink" title="字符串切换器"></a>字符串切换器</h2><p><code>StringSwitcher</code>模拟<code>String</code>到<code>int</code>的Java映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringSwitcher</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  String[] strings = <span class="keyword">new</span> String[]&#123;<span class="string">"one"</span>, <span class="string">"two"</span>&#125;;</div><div class="line">  <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</div><div class="line">  StringSwitcher stringSwitcher = StringSwitcher.create(strings, values, <span class="keyword">true</span>);</div><div class="line">  assertEquals(<span class="number">10</span>, stringSwitcher.intValue(<span class="string">"one"</span>));</div><div class="line">  assertEquals(<span class="number">20</span>, stringSwitcher.intValue(<span class="string">"two"</span>));</div><div class="line">  assertEquals(-<span class="number">1</span>, stringSwitcher.intValue(<span class="string">"three"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>StringSwitcher</code>允许在<code>String</code>上模拟一个switch命令就像从Java 7开始可以使用的内置的Java switch语句。如果在Java 6或更低版本中使用<code>StringSwitcher</code>或许仍然能给你的代码增加一些好处，然而我个人不会推荐使用它。</p>
<h2 id="接口制造者"><a href="#接口制造者" class="headerlink" title="接口制造者"></a>接口制造者</h2><p><code>InterfaceMaker</code>就如它名称所说：它能够动态创建一个新接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterfaceMaker</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  Signature signature = <span class="keyword">new</span> Signature(<span class="string">"foo"</span>, Type.DOUBLE_TYPE, <span class="keyword">new</span> Type[]&#123;Type.INT_TYPE&#125;);</div><div class="line">  InterfaceMaker interfaceMaker = <span class="keyword">new</span> InterfaceMaker();</div><div class="line">  interfaceMaker.add(signature, <span class="keyword">new</span> Type[<span class="number">0</span>]);</div><div class="line">  Class iface = interfaceMaker.create();</div><div class="line">  assertEquals(<span class="number">1</span>, iface.getMethods().length);</div><div class="line">  assertEquals(<span class="string">"foo"</span>, iface.getMethods()[<span class="number">0</span>].getName());</div><div class="line">  assertEquals(<span class="keyword">double</span>.class, iface.getMethods()[<span class="number">0</span>].getReturnType());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与其他cglib类的公共API不同，<code>InterfaceMaker</code>依赖于ASM类型。在运行的应用程序中创建接口几乎没有意义，因为接口仅代表一种通过编译器检查的可以使用的类型。然而当你生成将在后续开发中使用的代码时，它是有意义的。</p>
<h2 id="方法委托"><a href="#方法委托" class="headerlink" title="方法委托"></a>方法委托</h2><p><code>MethodDelegate</code>允许通过将一个方法调用绑定到某个接口来模拟一个特定方法的类似c#的委托。例如，下面的代码将<code>SampleBean#getValue</code>绑定到一个委托： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDelegate</span> </span>&#123;</div><div class="line">  <span class="function">String <span class="title">getValueFromDelegate</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodDelegate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  SampleBean bean = <span class="keyword">new</span> SampleBean();</div><div class="line">  bean.setValue(<span class="string">"Hello cglib!"</span>);</div><div class="line">  BeanDelegate delegate = (BeanDelegate) MethodDelegate.create(</div><div class="line">      bean, <span class="string">"getValue"</span>, BeanDelegate.class);</div><div class="line">  assertEquals(<span class="string">"Hello world!"</span>, delegate.getValueFromDelegate());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而有一些事情需要注意：</p>
<ol>
<li>工厂方法<code>MethodDelegate#create</code>只需要一个方法名称，并作为其第二个参数。这就是<code>MethodDelegate</code>将会为你代理的方法。</li>
<li>作为传给工厂方法的第一个参数的对象必须要有一个无参方法。因此，<code>MethodDelegate</code>没有那么强大。</li>
<li>第三个参数必须是只有一个参数的接口。<code>MethodDelegate</code>实现了它，并且可以转换成它。当方法被调用的时候，它会调用第一个参数对象上被代理的方法。</li>
</ol>
<p>此外，要考虑到这些缺点：</p>
<ol>
<li>cglib为每一个代理创建一个新类。最终，这会浪费你的永久代的堆空间。</li>
<li>你不能代理包含参数的方法。</li>
<li>如果你的接口接受参数，方法委托将无法工作，但不抛出异常(返回值始终为空)。如果你的接口需要另一种返回类型(即使是更通用的)，那么你将得到一个<code>IllegalArgumentException</code>。 </li>
</ol>
<h2 id="广播委托"><a href="#广播委托" class="headerlink" title="广播委托"></a>广播委托</h2><p><code>MulticastDelegate</code>与<code>MethodDelegate</code>有所不同，即使它的目的是提供类似功能。为了使用<code>MulticastDelegate</code>，我们需要实现一个接口的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DelegatationProvider</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMulticastBean</span> <span class="keyword">implements</span> <span class="title">DelegatationProvider</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> String value;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = value;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基于这个接口支持的bean，我们可以创建一个<code>MulticastDelegate</code>来将所有对<code>setValue(String)</code>的调用分派给实现了<code>DelegationProvider</code>接口的几个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMulticastDelegate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  MulticastDelegate multicastDelegate = MulticastDelegate.create(</div><div class="line">      DelegatationProvider.class);</div><div class="line">  SimpleMulticastBean first = <span class="keyword">new</span> SimpleMulticastBean();</div><div class="line">  SimpleMulticastBean second = <span class="keyword">new</span> SimpleMulticastBean();</div><div class="line">  multicastDelegate = multicastDelegate.add(first);</div><div class="line">  multicastDelegate = multicastDelegate.add(second);</div><div class="line"></div><div class="line">  DelegatationProvider provider = (DelegatationProvider)multicastDelegate;</div><div class="line">  provider.setValue(<span class="string">"Hello world!"</span>);</div><div class="line"></div><div class="line">  assertEquals(<span class="string">"Hello world!"</span>, first.getValue());</div><div class="line">  assertEquals(<span class="string">"Hello world!"</span>, second.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次，有一些缺点：</p>
<ol>
<li>对象需要实现一个单一方法的接口。这一点对第三方库来说糟透了，并且当你使用CGlib做了一些不可思议的事情并将其暴露给正常代码时会非常尴尬。此外，你也可以轻松实现你自己的代理(而不用修改字节代码，但是我怀疑采用人工委托的方式是否有更大优势)</li>
<li>当你的代理返回一个值时，你将只接收到最后添加的代理的返回值，所有其他的返回值都丢失了(但是会在某个点被<code>MulticastDelegate</code>接收)。</li>
</ol>
<h2 id="构造器委托"><a href="#构造器委托" class="headerlink" title="构造器委托"></a>构造器委托</h2><p><code>ConstructorDelegate</code>允许创建一个字节码编排过的(<em>byte-instrumented</em>)工厂方法。为此，我们首先需要一个带有单个方法newInstance且返回一个Object的接口，并且接收任意数量的参数以用于指定类的构造器调用。例如，为了创建<code>SampleBean</code>的一个<code>ConstructorDelegate</code> ，我们需要以下代码来调用<code>SampleBean</code>的默认(无参)构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleBeanConstructorDelegate</span> </span>&#123;</div><div class="line">  <span class="function">Object <span class="title">newInstance</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConstructorDelegate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  SampleBeanConstructorDelegate constructorDelegate = (SampleBeanConstructorDelegate) ConstructorDelegate.create(</div><div class="line">    SampleBean.class, SampleBeanConstructorDelegate.class);</div><div class="line">  SampleBean bean = (SampleBean) constructorDelegate.newInstance();</div><div class="line">  assertTrue(SampleBean.class.isAssignableFrom(bean.getClass()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="并行排序器"><a href="#并行排序器" class="headerlink" title="并行排序器"></a>并行排序器</h2><p><code>ParallelSorter</code>声称当对数组构成的数组进行排序时，是Java标准库的数组排序器更快的替代：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParallelSorter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  Integer[][] value = &#123;</div><div class="line">    &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>&#125;,</div><div class="line">    &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>&#125;</div><div class="line">  &#125;;</div><div class="line">  ParallelSorter.create(value).mergeSort(<span class="number">0</span>);</div><div class="line">  <span class="keyword">for</span>(Integer[] row : value) &#123;</div><div class="line">    <span class="keyword">int</span> former = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> val : row) &#123;</div><div class="line">      assertTrue(former &lt; val);</div><div class="line">      former = val;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ParallelSorter</code>接收一组数组并且允许对数组的每一行运用归并排序或者快速排序。然而当你使用它的时候需要小心：</p>
<ol>
<li>当使用基本类型的数组，你必须使用明确的排序范围来调用归并排序(例如，在例子里是<code>ParallelSorter.create(value).mergeSort(0, 0, 3)</code>)。否则，<code>ParallelSorter</code>有一个非常明显的错误，它会尝试将基本类型的数组转换成Object[]的数组，这会导致<code>ClassCastException</code>。</li>
<li>如果数组的行是不均匀的，那么第一个参数将决定需要考虑的行的长度。不均匀的行将会导致额外的值不会被排序考虑或者导致<code>ArrayIndexOutOfBoundException</code>。</li>
</ol>
<p>就个人而言，我疑惑<code>ParallelSorter</code>是否真的提供了时间上的优势。诚然，我没有尝试对其进行基准测试。如果你尝试了，我很高兴可以在评论中听到。</p>
<h2 id="快速类和快速成员"><a href="#快速类和快速成员" class="headerlink" title="快速类和快速成员"></a>快速类和快速成员</h2><p><code>FastClass</code>通过包装一个Java类承诺提供比java反射API更快的方法调用并提供类似于反射API的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFastClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  FastClass fastClass = FastClass.create(SampleBean.class);</div><div class="line">  FastMethod fastMethod = fastClass.getMethod(SampleBean.class.getMethod(<span class="string">"getValue"</span>));</div><div class="line">  MyBean myBean = <span class="keyword">new</span> MyBean();</div><div class="line">  myBean.setValue(<span class="string">"Hello cglib!"</span>);</div><div class="line">  assertTrue(<span class="string">"Hello cglib!"</span>, fastMethod.invoke(myBean, <span class="keyword">new</span> Object[<span class="number">0</span>]));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了演示的<code>FastMethod</code>，<code>FastClass</code>还可以创建<code>FastConstructor</code>，不过不能创建快速字段(<em>fast field</em>)。但是<code>FastClass</code>是如何比正常反射更快的？Java反射是由<strong>JNI</strong>通过调用一些C代码来执行方法调用。另一方面，<code>FastClass</code>创建了一些可以直接在JVM内调用方法的字节码。然而，较新版本的HotSpot JVM(以及可能许多其他现代JVM)知道了一种膨胀(<em>inflation</em>)的概念，当一个反射方法被执行足够频繁，JVM会将本地方法调用转换成本机版本的<code>FastClass</code>。你甚至可以通过将<code>sun.reflect.inflationThreshold</code>属性(默认值是15)设置为一个较小的值来控制这个行为(至少是在HotSpot JVM)。该属性决定了经过多少次反射调用一个JNI调用可以被一个额外添加字节码(<em>byte code instrumented</em>)的版本所代替。因此，我建议不要在现代JVM上使用<code>FastClass</code>，然而在较旧版本的Java虚拟机可以微调性能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/cglib/cglib/wiki/Tutorial&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原始文章：&lt;a href=&quot;http://mydailyjava.blogspot.no/2013/11/cglib-missing-manual.html&quot;&gt;http://mydailyjava.blogspot.no/2013/11/cglib-missing-manual.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;增强器&quot;&gt;&lt;a href=&quot;#增强器&quot; class=&quot;headerlink&quot; title=&quot;增强器&quot;&gt;&lt;/a&gt;增强器&lt;/h2&gt;&lt;p&gt;让我们从&lt;code&gt;Enhancer&lt;/code&gt;类开始，这可能是cglib库中最常被使用的类。一个增强器允许为没有接口的类型创建一个Java代理。&lt;code&gt;Enhancer&lt;/code&gt;可以与java标准库的&lt;code&gt;Proxy&lt;/code&gt;类做对比，后者是在Java 1.3时引入的。&lt;code&gt;Enhancer&lt;/code&gt;动态地创建给定类型的子类而拦截所有的方法调用。与&lt;code&gt;Proxy&lt;/code&gt;类不同的是，它对于类和接口都适用。接下来的例子和后续的一些例子都是基于这个简单的Java POJO：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SampleClass&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String input)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="CGlib" scheme="https://lukaicheng.github.io/tags/CGlib/"/>
    
  </entry>
  
  <entry>
    <title>延迟任务实践总结</title>
    <link href="https://lukaicheng.github.io/2017/06/25/Delay-task-practice/"/>
    <id>https://lukaicheng.github.io/2017/06/25/Delay-task-practice/</id>
    <published>2017-06-25T07:41:52.000Z</published>
    <updated>2017-06-25T12:56:58.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在实际开发项目过程中，可能会碰到类似这样的需求：期望一个任务不是马上执行，而是可以在给定的时间段之后才执行，通常这被称为<strong>延迟任务</strong>。解决这个问题的方案已经有不少，最直接的是采用定时任务的方式扫描数据库，或者考虑使用时间轮算法，或者基于RabbitMQ来实现延迟队列。最近我在项目中就碰到了同样的问题：当新内容添加到系统时，会带有一个过期时间，一旦到达此过期时间，那么需要自动下架该内容。对于此问题，在实际项目演变过程中我采用了与上述不同的两种方式来解决。</p>
<a id="more"></a>
<h2 id="基于DelayQueue实现延迟队列"><a href="#基于DelayQueue实现延迟队列" class="headerlink" title="基于DelayQueue实现延迟队列"></a>基于DelayQueue实现延迟队列</h2><p>由于项目最开始服务器资源较为紧张，初步预估先采用单实例部署，故最初想到的方案是使用JDK自带的<code>java.util.concurrent.DelayQueue</code>来实现。<code>DelayQueue</code>实质上是一个<strong>无界的带有优先级的阻塞队列</strong>，其包含的元素必须实现<code>java.util.concurrent.Delayed</code>接口(<em>实际由内部的<code>PriorityQueue</code>持有元素</em>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合实际问题，创建出具体的<code>DelayTask</code>类，它包含过期时间和任务唯一标识，其中，过期时间会参与到方法<code>compareTo</code>和<code>getDelay</code>的实现，而任务唯一标识除了用于表达任务的唯一性，还用于后续获取该任务的相关信息，从而进行实际的业务处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</div><div class="line">    <span class="comment">//任务唯一标识</span></div><div class="line">    <span class="keyword">private</span> String uniqueIdentity;</div><div class="line">    <span class="comment">//过期时间</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTime;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedTask</span><span class="params">(String uniqueIdentity, <span class="keyword">long</span> expireTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.uniqueIdentity = uniqueIdentity;</div><div class="line">        <span class="keyword">this</span>.expireTime = expireTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//在插入优先队列时被调用，以决定元素具体的插入位置</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.expireTime &lt; ((DelayedTask) o).expireTime)</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.expireTime &gt; ((DelayedTask) o).expireTime)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//当前时间减去过期时间，假如小于等于零，则表示该任务已过去</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> unit.convert(expireTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUniqueIdentity</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> uniqueIdentity;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来基于生产者-消费者模式，使用Spring的<code>@Service</code>注解来定义一个延迟队列的单例，这样可以方便我们在多个生产者和消费者之间共享同一个延迟队列。这个类里我们定义了一个任务入队方法<code>enqueue</code>和任务出队<code>dequeue</code>方法，其中后者实际使用<code>DelayQueue.take</code>获取超时任务，如果队列暂时没有任务超时将会导致线程阻塞，因此实际消费者必须在单独线程中获取任务以免影响主线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentDelayQueue</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//延迟队列</span></div><div class="line">    <span class="keyword">private</span> DelayQueue&lt;DelayedTask&gt; queue = <span class="keyword">new</span> DelayQueue&lt;DelayedTask&gt;();</div><div class="line"></div><div class="line">    <span class="comment">//将需要延迟处理的对象放入队列</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(DelayedTask task)</span> </span>&#123;</div><div class="line">        queue.offer(task);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//返回将要超时的对象，如果暂时没有，则会进行阻塞，因此建议在一个独立的线程中进行处理</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DelayedTask <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.take();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后还有一点需要注意，使用这种方式实现的延迟队列，当程序运行时数据存在于内存之中，一旦程序停止，整个队列的数据就会消失，因此需要有一个初始化行为保证在程序重启之后可以从数据库获取信息恢复原来的延迟队列。如果使用了Spring的话，可以考虑实现<code>InitializingBean</code>接口，把初始化行为放在<code>afterPropertiesSet</code>方法里实现。</p>
<h2 id="基于Redis实现延迟队列"><a href="#基于Redis实现延迟队列" class="headerlink" title="基于Redis实现延迟队列"></a>基于Redis实现延迟队列</h2><p>尽管采用<code>DelayQueue</code>可以实现延迟任务的处理，然而如果需要部署多个程序实例，不经过修改是无法满足需求的，但是如果要修改可能并不是一件简单的事情。于是随着项目推进，分布式环境下实现延迟队列这个问题摆在了我的面前。由于之前没有引入RabbitMQ，现有组件只有Redis和Kafka，经过研究，最终决定利用Redis实现分布式环境下的的延迟队列方案。</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>参考网上已有的方案(<a href="https://redislabs.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-4-task-queues/6-4-2-delayed-tasks/" target="_blank" rel="external">Delayd tasks</a>)，并结合项目实际情况，确定了最终的总体设计思路，如下所述：</p>
<ol>
<li>以任务过期时间毫秒数作为分值，将延迟任务添加到Redis Sorted Set，从而使得任务可以根据过期时间的先后顺序进行排序。</li>
<li>利用Redis Sorted Set的<code>ZRANGEBYSCORE</code>命令，获取分值在零至当前时间之间的任务(即已经到期的延迟任务)，接着将其插入到Redis Set。</li>
<li>利用Redis Set的<code>SPOP</code>命令可以获取并移除Set上的一个到期的延迟任务，处理完业务逻辑之后，再使用Redis Sorted Set的<code>ZREM</code>命令移除原始的延迟任务。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>对于延迟任务的定义，依然沿用上一节的思路，只不过这次不需要实现<code>Delayed</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//任务唯一标识</span></div><div class="line">    <span class="keyword">private</span> String uniqueIdentity;</div><div class="line">    <span class="comment">//过期时间毫秒数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTime;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedTask</span><span class="params">(String uniqueIdentity, <span class="keyword">long</span> expireTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.uniqueIdentity = uniqueIdentity;</div><div class="line">        <span class="keyword">this</span>.expireTime = expireTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUniqueIdentity</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> uniqueIdentity;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpireTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> expireTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExpireTime</span><span class="params">(<span class="keyword">long</span> expireTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.expireTime = expireTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先实现步骤1，将任务添加到Redis有序集合。由于项目使用的Redis是集群方式配置，因此这里连接Redis的API使用的是Jedis库的<code>JedisCluster</code>，注意分值是过期时间，对应内容是延迟任务对象格式化成JSON之后的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTaskProducer</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(DelayedTaskProducer.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SORTED_SET = <span class="string">"SortedSetForDelayedTask"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SET = <span class="string">"SetForDelayedTask"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JedisCluster client;</div><div class="line">    <span class="comment">//用于将对象格式化成JSON字符串</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDelayedTask</span><span class="params">(String uniqueIdentitfy, <span class="keyword">long</span> expireTime)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//构建延迟任务</span></div><div class="line">        DelayedTask task = <span class="keyword">new</span> DelayedTask(uniqueIdentitfy, expireTime);</div><div class="line">        <span class="comment">//以过期时间为分值，将延迟任务添加到Redis有序集合</span></div><div class="line">        client.zadd(KEY_SORTED_SET, expireTime, mapper.writeValueAsString(task));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TransferWorker(), <span class="string">"DelayTaskTransferThread"</span>);</div><div class="line">        t1.start();</div><div class="line">        LOGGER.info(<span class="string">"DelayTaskTransferThread Start"</span>);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FinishWorker(), <span class="string">"DelayTaskFinishThread"</span>);</div><div class="line">        t2.start();</div><div class="line">        LOGGER.info(<span class="string">"DelayTaskFinishThread Start"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着是步骤2的实现代码，在实际项目实现中，我定义了一个内部类<code>TransferWorker</code>，它实现了<code>Runnable</code>接口，可以单独运行在一个线程中。主要工作就是根据<code>zrangeByScore</code>命令获取已经到期的延迟任务，并将它们转移到另外一个Redis集合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//从Redis Sorted Set获取已经过去的延迟任务</span></div><div class="line">                Set&lt;String&gt; set = client.zrangeByScore(KEY_SORTED_SET, <span class="number">0</span>,</div><div class="line">                        System.currentTimeMillis());</div><div class="line">                <span class="keyword">if</span> (set.isEmpty()) &#123;</div><div class="line">                    <span class="comment">//可以做成配置</span></div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">30</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                String[] members = <span class="keyword">new</span> String[set.size()];</div><div class="line">                set.toArray(members);</div><div class="line">                <span class="comment">//将过去的延迟任务添加到Redis Set</span></div><div class="line">                client.sadd(KEY_SET, members);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                LOGGER.error(e.getMessage(), e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后是步骤3的代码实现，同步骤2的做法一样，我也将<code>FinishWorker</code>定义为内部类，并实现了<code>Runnable</code>接口。它会从Redis集合中获取延迟任务，并将其移除，随后根据任务信息进行业务处理，最终如果一切顺利，那么会把原始任务从Redis有序集合中移除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FinishWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//从Redis Set获取一个延迟任务，并将其从Set中移除</span></div><div class="line">                String any = client.spop(KEY_SET);</div><div class="line">                <span class="keyword">if</span> (any == <span class="keyword">null</span> || any.trim().isEmpty()) &#123;</div><div class="line">                    <span class="comment">//可以做成配置</span></div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                DelayedTask task = mapper.readValue(any, DelayedTask.class);</div><div class="line">                <span class="comment">//省略业务处理代码...</span></div><div class="line">                </div><div class="line">                <span class="comment">//将原始的延迟任务从Redis Sorted Set中移除</span></div><div class="line">                client.zrem(KEY_SORTED_SET, any);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                LOGGER.error(e.getMessage(), e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我让<code>DelayedTaskProducer</code>实现<code>InitializingBean</code>接口，这样在初始化时，可以启动<code>TransferWork</code>和<code>FinishWorker</code>这两个线程任务。当然也可以将<code>TransferWork</code>和<code>FinishWorkder</code>提取出来，声明成非内部类，并在另外的地方启动它们。另外，由于这仅仅只是示例，所以在代码里只各启动了一个线程，然而在实际情况下，需要根据任务量来最终确定两种任务启动的线程数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TransferWorker(), <span class="string">"DelayTaskTransferThread"</span>);</div><div class="line">    t1.start();</div><div class="line">    LOGGER.info(<span class="string">"DelayTaskTransferThread Start"</span>);</div><div class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FinishWorker(), <span class="string">"DelayTaskFinishThread"</span>);</div><div class="line">    t2.start();</div><div class="line">    LOGGER.info(<span class="string">"DelayTaskFinishThread Start"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="背后考虑"><a href="#背后考虑" class="headerlink" title="背后考虑"></a>背后考虑</h3><p>最后再来总结一下整个设计过程中的一些考虑：</p>
<ul>
<li>最重要的一点是业务处理过程需要满足<strong>幂等性</strong>。</li>
<li>对程序异常有一定容忍，允许重试。</li>
<li>由于将移除有序集合的原始任务放在最后，因此即使前面的步骤发生异常，也可以通过重新加载有序集合的原始任务进行重试。</li>
<li>使用Set作为中转的原因是期望同一个任务只被一个线程消费，用<code>SPOP</code>命令可以实现。当然List也能满足这一点，但最终使用Set的原因是为了避免步骤2中多个程序实例的线程插入相同的任务。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://redislabs.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-4-task-queues/6-4-2-delayed-tasks/" target="_blank" rel="external">Delayd tasks</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在实际开发项目过程中，可能会碰到类似这样的需求：期望一个任务不是马上执行，而是可以在给定的时间段之后才执行，通常这被称为&lt;strong&gt;延迟任务&lt;/strong&gt;。解决这个问题的方案已经有不少，最直接的是采用定时任务的方式扫描数据库，或者考虑使用时间轮算法，或者基于RabbitMQ来实现延迟队列。最近我在项目中就碰到了同样的问题：当新内容添加到系统时，会带有一个过期时间，一旦到达此过期时间，那么需要自动下架该内容。对于此问题，在实际项目演变过程中我采用了与上述不同的两种方式来解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DelayQueue" scheme="https://lukaicheng.github.io/tags/DelayQueue/"/>
    
      <category term="Redis" scheme="https://lukaicheng.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化机制总结</title>
    <link href="https://lukaicheng.github.io/2017/06/24/Java-serialization-mechanism/"/>
    <id>https://lukaicheng.github.io/2017/06/24/Java-serialization-mechanism/</id>
    <published>2017-06-24T00:42:31.000Z</published>
    <updated>2017-06-25T07:35:43.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列化缘由"><a href="#序列化缘由" class="headerlink" title="序列化缘由"></a>序列化缘由</h2><p>在实际的程序运行过程中，总会有这样的场景：程序可以将本次运行的某些对象或者状态保存下来，以供下次启动时使用；在一个联网环境里，不同节点之间的系统需要进行通信，发送者要将某些对象发送到远程的接收者从而达到沟通协调的目的。序列化正是缘于这些场景而出现的一种技术概念，为了能够序列化Java平台的对象，JDK从很早的版本开始就提供了一种序列化机制，它可以将对象编码成字节流(<em>序列化</em>)，也可以反向从字节流编码中重新构建对象(<em>反序列化</em>)，以用于支持RMI和JavaBean。</p>
<a id="more"></a>
<h2 id="序列化实现"><a href="#序列化实现" class="headerlink" title="序列化实现"></a>序列化实现</h2><p>想要一个类的实例能被序列化，只要让类实现<code>java.io.Serializable</code>或者<code>java.io.Externalizable</code>接口即可。其中，<code>java.io.Serializable</code>仅仅只是一个标记接口，系统通过判断是否是此接口的子类来确定对象能否被序列化，而整个序列化过程对于应用开发者来说完全是透明的。<code>java.io.Externalizable</code>不同于前者，开发者必须通过实现<code>writeExternal</code>和<code>readExternal</code>这两个方法，来决定如何保存和恢复对象的内容，另外需要注意的是<code>Externalizable</code>子类要有一个<strong>公共的无参构造器</strong>，否则会导致反序列化失败。</p>
<p>下面的例子展示了一个<code>Person</code>类，其继承<code>Serializable</code>接口，表示能被序列化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> String birth;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String birth, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.birth = birth;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(<span class="string">"My name is %s, My birthDay is %s,My age is %d"</span>, name, birth, age);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当实际进行序列化操作时，可以创建<code>ObjectOutputStream</code>，调用相应的<strong>writeXXX</strong>方法就可以将对象序列化成字节流。当需要进行反序列化操作时，可以创建<code>ObjectInputStream</code>，调用相应的<strong>readXXX</strong>方法就可以从字节流中还原对象信息。下面的例子展示了如何将对象序列化到文件，并从文件反序列化成对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialiazationTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String file = <span class="string">"D:/extern.out"</span>;</div><div class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file))) &#123;</div><div class="line">            oos.writeObject(<span class="keyword">new</span> Person(<span class="string">"Lucifer"</span>, <span class="string">"1986-01-01"</span>, <span class="number">30</span>));</div><div class="line">            oos.flush();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file))) &#123;</div><div class="line">            Person p = (Person) ois.readObject();</div><div class="line">            System.out.println(p);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="序列化字段修饰"><a href="#序列化字段修饰" class="headerlink" title="序列化字段修饰"></a>序列化字段修饰</h3><p>默认情况下，除了用<strong>transient</strong>或<strong>static</strong>声明的字段，本类中所声明的其他字段都会被序列化。在实际序列化过程中，会创建实例类对应的<code>ObjectStreamClass</code>，它会探测实例类中哪些字段需要进行序列化，具体细节可参考<code>ObjectStreamClass.getDefaultSerialFields</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) &#123;</div><div class="line">    Field[] clFields = cl.getDeclaredFields();</div><div class="line">    ArrayList&lt;ObjectStreamField&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> mask = Modifier.STATIC | Modifier.TRANSIENT;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clFields.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> ((clFields[i].getModifiers() &amp; mask) == <span class="number">0</span>) &#123;</div><div class="line">            list.add(<span class="keyword">new</span> ObjectStreamField(clFields[i], <span class="keyword">false</span>, <span class="keyword">true</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> size = list.size();</div><div class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? NO_FIELDS :</div><div class="line">        list.toArray(<span class="keyword">new</span> ObjectStreamField[size]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="序列化字段声明"><a href="#序列化字段声明" class="headerlink" title="序列化字段声明"></a>序列化字段声明</h3><p>除了使用修饰符来控制字段是否需要被序列化，还有一种方式可以显式的声明需要进行序列化的字段，并且会<strong>覆盖默认使用修饰符的方式</strong>，那就是声明特殊的<code>serialPersistentFields</code>字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</div><div class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">"name"</span>, String.class),</div><div class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">"birth"</span>, String.class) &#125;;</div></pre></td></tr></table></figure>
<p>需要注意的是<code>serialPersistentFields</code>字段的修饰符必须包含<code>private</code> <code>static</code> <code>final</code>，而且类型必须是<code>ObjectStreamField[]</code>。使用这种方式也可以使得类中的字段在后续版本中可以发生变化，个人理解为这个字段声明了在类版本演化过程中需要维持兼容性的一个边界。想要了解更详细的情况，可以查看<code>ObjectStream.getDeclaredSerialFields</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectStreamField[] getDeclaredSerialFields(Class&lt;?&gt; cl)</div><div class="line">    <span class="keyword">throws</span> InvalidClassException</div><div class="line">&#123;</div><div class="line">    ObjectStreamField[] serialPersistentFields = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Field f = cl.getDeclaredField(<span class="string">"serialPersistentFields"</span>);</div><div class="line">        <span class="keyword">int</span> mask = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;</div><div class="line">        <span class="keyword">if</span> ((f.getModifiers() &amp; mask) == mask) &#123;</div><div class="line">            f.setAccessible(<span class="keyword">true</span>);</div><div class="line">            serialPersistentFields = (ObjectStreamField[]) f.get(<span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (serialPersistentFields == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serialPersistentFields.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NO_FIELDS;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ObjectStreamField[] boundFields =</div><div class="line">        <span class="keyword">new</span> ObjectStreamField[serialPersistentFields.length];</div><div class="line">    Set&lt;String&gt; fieldNames = <span class="keyword">new</span> HashSet&lt;&gt;(serialPersistentFields.length);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; serialPersistentFields.length; i++) &#123;</div><div class="line">        ObjectStreamField spf = serialPersistentFields[i];</div><div class="line"></div><div class="line">        String fname = spf.getName();</div><div class="line">        <span class="keyword">if</span> (fieldNames.contains(fname)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(</div><div class="line">                <span class="string">"multiple serializable fields named "</span> + fname);</div><div class="line">        &#125;</div><div class="line">        fieldNames.add(fname);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Field f = cl.getDeclaredField(fname);</div><div class="line">            <span class="keyword">if</span> ((f.getType() == spf.getType()) &amp;&amp;</div><div class="line">                ((f.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>))</div><div class="line">            &#123;</div><div class="line">                boundFields[i] =</div><div class="line">                    <span class="keyword">new</span> ObjectStreamField(f, spf.isUnshared(), <span class="keyword">true</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException ex) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (boundFields[i] == <span class="keyword">null</span>) &#123;</div><div class="line">            boundFields[i] = <span class="keyword">new</span> ObjectStreamField(</div><div class="line">                fname, spf.getType(), spf.isUnshared());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> boundFields;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义序列化行为"><a href="#自定义序列化行为" class="headerlink" title="自定义序列化行为"></a>自定义序列化行为</h2><p>除了使用修饰符或者特殊字段的方式之外，Java序列化机制还提供了<code>writeObject</code>和<code>readObject</code>这两个特殊的方法，可以让我们覆盖默认的序列化方式，实现自定义序列化行为，下面是完整的方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//自定义序列化行为</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="comment">//自定义反序列化行为</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</div></pre></td></tr></table></figure>
<p>需要自定义序列化行为的<code>Serializable</code>子类可以通过实现这两个方法来自定义整个序列化过程。以<code>LinkedList</code>为例，其内部就定义实现了这两个方法，之所以如此，这是由于其内部实现目前采用了双端链表的形式，假如采用默认的序列化方式，那么不仅会镜像链表中的所有项，整个链表的拓扑结构也会被镜像，这不但会导致不必要的空间消耗，也会使得类永远被束缚其内部表示法，因此<code>Linked</code>实现了自定义的序列化方式，仅仅序列化数据项的数量以及实际数据项，而拓扑结构是在反序列化过程中重新组织：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">    <span class="keyword">throws</span> java.io.IOException &#123;</div><div class="line">    <span class="comment">// Write out any hidden serialization magic</span></div><div class="line">    s.defaultWriteObject();</div><div class="line"></div><div class="line">    <span class="comment">// Write out size</span></div><div class="line">    s.writeInt(size);</div><div class="line"></div><div class="line">    <span class="comment">// Write out all elements in the proper order.</span></div><div class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</div><div class="line">        s.writeObject(x.item);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></div><div class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</div><div class="line">    <span class="comment">// Read in any hidden serialization magic</span></div><div class="line">    s.defaultReadObject();</div><div class="line"></div><div class="line">    <span class="comment">// Read in size</span></div><div class="line">    <span class="keyword">int</span> size = s.readInt();</div><div class="line"></div><div class="line">    <span class="comment">// Read in all elements in the proper order.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">        linkLast((E)s.readObject());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有两点需要注意：首先，即使你需要实现自定义的序列化过程，也请在序列化时优先调用<code>defaultWriteObject</code>方法以及在反序列化时优先调用<code>defaultReadObject</code>方法，这可以使类保持更大的灵活性，即使以后类增加了非<strong>transient</strong>字段，也能保持向前和向后兼容性；其次，在反序列化过程中，对于类的约束关系也需要进行保证，这是因为反序列化其实也是一种对象创建机制，是一种<strong>隐藏的构造器</strong>，否则类的约束关系就容易遭到破坏，从而可能遭受非法访问。</p>
<h2 id="序列化版本号"><a href="#序列化版本号" class="headerlink" title="序列化版本号"></a>序列化版本号</h2><p>当然不管最终采用默认的抑或自定义的序列化行为，显式声明<code>serialVersionUID</code> 都是一种较好的编程习惯。首先，如果不提供显式的<code>serialVersionUID</code> ，那么需要在运行时通过一个高开销的计算过程(<a href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/class.html#4100" target="_blank" rel="external">Stream Unique Identifiers</a>)产生一个<code>serialVersionUID</code>，这会导致一些性能损失。其次，<code>serialVersionUID</code>计算会综合考虑类、接口、方法以及字段，随着类的演进，这可能导致旧版本和新版本计算出来的<code>serialVersionUID</code>不一致，从而导致现有类与原有类的不兼容(<em>即使两者实际上可以兼容</em>)。基于以上考虑，显式声明<code>serialVersionUID</code>，可以让我们明确是否需要为类创建新版本。</p>
<h3 id="不可兼容变更"><a href="#不可兼容变更" class="headerlink" title="不可兼容变更"></a>不可兼容变更</h3><p>当类演进过程中，碰到如下情况，可以考虑为不兼容，需要创建新版本：</p>
<ul>
<li>删除字段</li>
<li>提升或降低类层级</li>
<li>将一个非<strong>transient</strong>字段变成<strong>transient</strong>或者将一个非<strong>static</strong>字段变成<strong>static</strong></li>
<li>改变一个基本类型字段的原有声明类型</li>
<li>修改<code>writeObject</code>或<code>readObject</code>方法使得与原有版本在处理默认字段时方式不同</li>
<li>将类从实现<code>Serializable</code>接口 变成实现<code>Externalizable</code>接口或者相反情况</li>
<li>将类从非枚举类型变成枚举类型或者相反情况</li>
<li>移除<code>Serializable</code>接口或<code>Externalizable</code>接口</li>
<li>为类增加<code>writeReplace</code>或者<code>readResolve</code>方法</li>
</ul>
<h3 id="可兼容变更"><a href="#可兼容变更" class="headerlink" title="可兼容变更"></a>可兼容变更</h3><p>当类演进过程中，碰到如下情况，可以考虑为兼容情况：</p>
<ul>
<li>增加字段</li>
<li>增加类</li>
<li>删除类</li>
<li>增加<code>writeObject</code>和<code>readObject</code>方法</li>
<li>移除<code>writeObject</code>和<code>readObject</code>方法</li>
<li>增加<code>java.io.Serializable</code>接口</li>
<li>改变字段的访问权限</li>
<li>将一个字段从<strong>static</strong>变成非<strong>static</strong>或者从<strong>transient</strong>变成非<strong>transient</strong></li>
</ul>
<h2 id="序列化代理模式"><a href="#序列化代理模式" class="headerlink" title="序列化代理模式"></a>序列化代理模式</h2><p>由于序列化机制会利用普通构造器之外的机制来创建对象，增加了出错和出现安全问题的可能性，于是JDK设计人员提出了所谓的序列化代理模式，这种模式大概的思路是为可序列化的类设计一个私有的静态嵌套类，其被称作序列化代理，它有一个单独的构造器来接收外围类，从而复制外围类的数据，这个复制过程不需要一致性检查和保护性拷贝。接着利用两个特殊方法<code>writeReplace</code>和<code>readResolve</code>来实现外围类实例和序列化代理类实例之间的互相转换，从而最终序列化目的。</p>
<p>两个方法的完整签名以及简要说明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//类通过实现此方法，可以使得其实例在序列化写入流时替换成此方法返回的对象</span></div><div class="line">ANY-ACCESS-<span class="function">MODIFIER Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</div><div class="line"><span class="comment">//类通过实现此方法，可以使得反序列化读取到其实例之后，并在返回调用者之前，替换成此方法的返回对象</span></div><div class="line">ANY-ACCESS-<span class="function">MODIFIER Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</div></pre></td></tr></table></figure>
<p><code>EnumSet</code>内部就实现了序列化代理，它定义了静态内部类<code>SerializationProxy</code>并实现了<code>writeReplace</code>方法。当对<code>EnumSet</code>实例进行序列化时，会调用<code>writeReplace</code>方法，这会返回一个<code>SerializationProxy</code>实例并替换<code>EnumSet</code>实例写入字节流；当反序列化时，读取出来的首先是<code>SerializationProxy</code>实例，由于该实例的类定义了<code>readResolve</code>方法，因此在返回给调用者之前，此方法会被调用，从而利用已有的工厂方法重建回<code>EnumSet</code>实例。另外需要注意的是<code>EnumSet</code>定义<code>readObject</code>方法是为了防止可能的攻击。以下是<code>EnumSet</code>类的部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Class&lt;E&gt; elementType;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Enum[] universe;</div><div class="line">  </div><div class="line">    <span class="comment">//省略部分代码</span></div><div class="line">   	<span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Enum&lt;E&gt;&gt; <span class="function">EnumSet&lt;E&gt; <span class="title">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span> </span>&#123;</div><div class="line">        Enum[] universe = getUniverse(elementType);</div><div class="line">        <span class="keyword">if</span> (universe == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(elementType + <span class="string">" not an enum"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (universe.length &lt;= <span class="number">64</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RegularEnumSet&lt;&gt;(elementType, universe);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JumboEnumSet&lt;&gt;(elementType, universe);</div><div class="line">    &#125;</div><div class="line">  	<span class="comment">//省略部分代码</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationProxy</span> &lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;E&gt; elementType;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Enum[] elements;</div><div class="line"></div><div class="line">        SerializationProxy(EnumSet&lt;E&gt; set) &#123;</div><div class="line">            elementType = set.elementType;</div><div class="line">            elements = set.toArray(ZERO_LENGTH_ENUM_ARRAY);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</div><div class="line">            EnumSet&lt;E&gt; result = EnumSet.noneOf(elementType);</div><div class="line">            <span class="keyword">for</span> (Enum e : elements)</div><div class="line">                result.add((E)e);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362491234563181265L</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">Object <span class="title">writeReplace</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SerializationProxy&lt;&gt;(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream stream)</span></span></div><div class="line">        <span class="keyword">throws</span> java.io.InvalidObjectException &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Proxy required"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/serialTOC.html" target="_blank" rel="external">Java Object Serialization Specification</a></p>
<p><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="external">Effective Java中文版(第2版)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序列化缘由&quot;&gt;&lt;a href=&quot;#序列化缘由&quot; class=&quot;headerlink&quot; title=&quot;序列化缘由&quot;&gt;&lt;/a&gt;序列化缘由&lt;/h2&gt;&lt;p&gt;在实际的程序运行过程中，总会有这样的场景：程序可以将本次运行的某些对象或者状态保存下来，以供下次启动时使用；在一个联网环境里，不同节点之间的系统需要进行通信，发送者要将某些对象发送到远程的接收者从而达到沟通协调的目的。序列化正是缘于这些场景而出现的一种技术概念，为了能够序列化Java平台的对象，JDK从很早的版本开始就提供了一种序列化机制，它可以将对象编码成字节流(&lt;em&gt;序列化&lt;/em&gt;)，也可以反向从字节流编码中重新构建对象(&lt;em&gt;反序列化&lt;/em&gt;)，以用于支持RMI和JavaBean。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Serialization" scheme="https://lukaicheng.github.io/tags/Serialization/"/>
    
  </entry>
  
  <entry>
    <title>基于标签的人群统计实现分析</title>
    <link href="https://lukaicheng.github.io/2017/06/09/TagBasedStatistics/"/>
    <id>https://lukaicheng.github.io/2017/06/09/TagBasedStatistics/</id>
    <published>2017-06-09T12:15:41.000Z</published>
    <updated>2017-07-20T07:14:32.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>最近在做项目过程中，碰到了这样一个需求：当前台页面勾选偏好标签的时候，后端服务需要快速给出标签对应的人群数量。如果仅仅只是单个标签的话，那么问题是非常简单的，然而现实是残酷的，我必须考虑基于多个标签勾选的交并集统计情况。</p>
<p>在此，先做一个假设，每个标签后面对应的人群数量是一百万，当然有可能人群会有重叠，而后续的讨论都是基于此数量级展开。</p>
<a id="more"></a>
<h2 id="初始想法"><a href="#初始想法" class="headerlink" title="初始想法"></a>初始想法</h2><p>考虑到在实际业务场景中用户标识是手机号码，这是一个数字，而且每个用户之间互不相同，为了尽可能满足快速响应以及节省空间的原则，我首先想到了利用<strong>位图</strong>的思想来实现这个需求。在Java中就提供了这样一个类来实现位图操作，它就是<strong>BitSet</strong>，下面是简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitSetDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        BitSet bs1 = <span class="keyword">new</span> BitSet();</div><div class="line">        bs1.set(<span class="number">14</span>);</div><div class="line">        bs1.set(<span class="number">20</span>);</div><div class="line">        bs1.set(<span class="number">43</span>);</div><div class="line">        <span class="comment">//输出bs1中设置为true的位数</span></div><div class="line">        System.out.println(bs1.cardinality());</div><div class="line">        BitSet bs2 = <span class="keyword">new</span> BitSet();</div><div class="line">        bs2.set(<span class="number">7</span>);</div><div class="line">        bs2.set(<span class="number">20</span>);</div><div class="line">        bs2.set(<span class="number">33</span>);</div><div class="line">        bs2.set(<span class="number">45</span>);</div><div class="line">        <span class="comment">//输出bs2中设置为true的位数</span></div><div class="line">        System.out.println(bs2.cardinality());</div><div class="line">        <span class="comment">//bs1和bs2进行交集操作</span></div><div class="line">        bs1.and(bs2);</div><div class="line">        <span class="comment">//输出bs1和bs2进行交集操作之后设置为true的位数</span></div><div class="line">        System.out.println(bs1.cardinality());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BitSet可以通过设置具体索引位的值为true来代表存在此数字，而且它还提供了基于位的交、并、差等操作(需要值得注意的是<strong>这些操作会对原有位图进行修改</strong>)。</p>
<p>映射到实际的业务问题，如果把用户标识(将手机号码看成数字)对应的位设置成true来代表存在此用户，那么似乎可以通过操作不同标签对应的位图，从而实现所期望的功能。然而这里还遗漏了一个问题，那就是位图持久化。</p>
<h2 id="Redis-bitmap"><a href="#Redis-bitmap" class="headerlink" title="Redis bitmap"></a>Redis bitmap</h2><p>正当我苦恼持久化的问题时，无意中翻到Redis居然提供了类似位图操作的命令：<strong>SETBIT</strong>、<strong>BITCOUNT</strong>、<strong>BITOP</strong>， 而且它还提供了RDB和AOF两种持久化机制，另外由于Redis是内存数据库，在命令响应方面也是非常迅速，可以说非常符合我这个问题的场景。</p>
<p>不过，当真正用Redis去实现的时候，又碰到了之前忽视的一个细节：手机号是11号数字，超过了Redis位图所能表示的范围，这一点在<strong>SETBIT</strong>命令的文档中有如下说明：</p>
<blockquote>
<p>The <em>offset</em> argument is required to be greater than or equal to 0, and smaller than 2<sup>32</sup> (this limits bitmaps to 512MB)</p>
</blockquote>
<p>为了解决这个细节问题，我想出了一个方案：将手机号前两位作为key的一部分，剩下的9位作为值插入到位图里面，由于手机号第一位是1，那么实际上一个标签最多需要10个位图来表示。为了避免用<strong>KEYS</strong>命令扫描获取某个标签所有的key，可以把这些key放到Redis Set中，每次可以先使用<strong>SMEMEBERS</strong>命令获取到所有key。</p>
<h2 id="Bitmap-VS-Set"><a href="#Bitmap-VS-Set" class="headerlink" title="Bitmap VS Set"></a>Bitmap VS Set</h2><p>在给他人讲述了我的方案之后，由于此设计在实现上确实有些繁琐复杂，有人提出是否考虑直接使用Set来存储所有的用户号码(他用两个百万随机用户号码的Set做交并操作，效率可以接受)。</p>
<p>于是，我开始对Set方案进行验证，除了处理速度之外，主要关注容量消耗，最终经过测试发现，一百万随机手机号码用Redis Set存储会消耗大概<strong>90MB</strong>内存。回过头来，分析我的Bitmap方案，如果要表达9位数字，那么需要2<sup>30</sup>，即128MB(实际测试下来发现也大致符合这个值)，而一个标签最多需要分10个key，所以最大占据<strong>1280MB</strong>。 </p>
<p>诚然Set方案会随着标签下用户群的数量增加容量会随之增加，Bitmap方案的容量较为恒定，然而在这个场景下(最开始假设了一百万的量级，真实场景也大致如此甚至更少)，确实是采用Set会优于Bitmap。</p>
<h2 id="Cluster-amp-hash-tags"><a href="#Cluster-amp-hash-tags" class="headerlink" title="Cluster &amp; hash tags"></a>Cluster &amp; hash tags</h2><p>尽管决定采用Set方案，在实际编码以及调试过程中，又碰到了Redis的一个限制：如果Redis是采用集群方式部署，假设Set对应的key不属于同个节点，那么就无法透明的支持Set的交并操作。</p>
<p>引用自Redis Cluster规范：</p>
<blockquote>
<p>Redis Cluster implements all the single key commands available in the non-distributed version of Redis. Commands performing complex multi-key operations like Set type unions or intersections are implemented as well as long as the keys all belong to the same node.</p>
</blockquote>
<p>这样一来，就需要通过调用者来处理不同标签对应的key分配在不同节点的情况，每次进行多个标签交并操作时，首先需要从多个节点获取到对应标签的用户集合，然后在调用者的程序当中进行实际的集合交并，这样一来会大大增加网络传输量。</p>
<p>幸运的是，Redis提供了一种技巧，可以强制让多个key分配到相同的节点，这种技巧叫做<strong>hash tags</strong>。众所周知，Redis在执行key有关的命令前，先会计算key所对应的slot，不同的key由于计算出来的slot不同，往往就会位于不同的节点。而这个计算有一个短路的地方，假设碰到一个key包含<strong>“{“</strong>和<strong>“}”</strong>，那么只会使用花括号内的子字符串(<em>第一个花括号内的字符串</em>)进行slot的计算，这意味着{foo}bar1和{foo}bar2将会位于同一个节点。想要对这个概念有更详细的了解，可以查看<a href="https://redis.io/topics/cluster-spec#keys-hash-tags" target="_blank" rel="external">Keys hash tags</a>。 </p>
<p>考虑到可能出现的数据倾斜问题，我们可以将同一大类的标签都指派到相同节点，不同大类的标签指派到不同节点。由于交并操作符合交换律和结合律，那么可以优先计算出相同大类的交并集合，最终通过程序汇总，计算出不同大类的交并集合。这样一来，在考虑数据平衡的情况下，也相应减少网络传输。</p>
<h2 id="打破原有思维"><a href="#打破原有思维" class="headerlink" title="打破原有思维"></a>打破原有思维</h2><p>到此为止，这似乎是比较可取的方案了，然而当我跳出目前的思路，再重新去回顾整个问题的时候，猛然有一个念头在我脑海里闪过：一定要用手机号对应的数字来设置位图值吗？意识到这一点，我想到整个问题可以从一个新的角度来解决。</p>
<p>最开始想到采用手机号对应的数字来设置位图信息，是因为在整个系统里手机号可以唯一标识一个用户，然而对此问题而言，本质是关注具体标签下包含哪些用户，至于这些用户是如何确定唯一的，其实并不重要。那么，其实我可以预先做一个映射，将系统中所有的用户号码和一个自增序列进行映射，由于整个系统用户量仅仅只有千万级(且离亿级差距较大)，那么自增序列最大值不会超过100000000(其小于2<sup>27</sup>，2<sup>27</sup> bit = 16MB)。如此一来，通过手机号码对应的自增序列数字设置redis位图值，一个key对应的位图就可以存储一个标签所包含的所有用户，且容量仅<strong>16MB</strong>左右，即使标签下用户量从百万级增长到千万级，容量也是恒定的。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>通过对整个问题持续的思考、同其他人的交流以及自我反思，让我更加深刻意识到分析问题要综合考虑项目实际情况、业务细节以及技术限制，任何好的方案都是通过不断权衡和取舍而做出的选择，这个世界上没有银弹。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://redis.io/commands/setbit" target="_blank" rel="external">Redis SETBIT 命令</a></p>
<p><a href="https://redis.io/commands/bitcount" target="_blank" rel="external">Redis BITCOUNT 命令</a></p>
<p><a href="https://redis.io/commands/bitop" target="_blank" rel="external">Redis BITOP 命令</a></p>
<p><a href="https://redis.io/topics/cluster-spec#keys-hash-tags" target="_blank" rel="external">Redis hash tags</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;最近在做项目过程中，碰到了这样一个需求：当前台页面勾选偏好标签的时候，后端服务需要快速给出标签对应的人群数量。如果仅仅只是单个标签的话，那么问题是非常简单的，然而现实是残酷的，我必须考虑基于多个标签勾选的交并集统计情况。&lt;/p&gt;
&lt;p&gt;在此，先做一个假设，每个标签后面对应的人群数量是一百万，当然有可能人群会有重叠，而后续的讨论都是基于此数量级展开。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://lukaicheng.github.io/tags/Redis/"/>
    
      <category term="BitSet" scheme="https://lukaicheng.github.io/tags/BitSet/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础 - BeanPostProcessor</title>
    <link href="https://lukaicheng.github.io/2017/05/15/Spring-BeanPostProcessor/"/>
    <id>https://lukaicheng.github.io/2017/05/15/Spring-BeanPostProcessor/</id>
    <published>2017-05-15T12:40:40.000Z</published>
    <updated>2017-05-17T02:17:29.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h1><p><strong>BeanPostProcessor</strong>是Spring提供的一个钩子(<em>Hook</em>)接口，可用于实现对新的bean实例进行自定义修改，比如说，检测bean是否实现了某些特定接口从而可以对其进行进一步操作，或者可以将原实例进行包装而实际返回代理对象。其内部主要声明了<em>postProcessBeforeInitialization</em>和<em>postProcessAfterInitialization</em>两个回调方法，具体的接口声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line">  	<span class="comment">//在bean进行初始化行为之前被调用</span></div><div class="line">	<span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">  	<span class="comment">//在bean进行初始化行为之后被调用</span></div><div class="line">	<span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是这里所说的bean初始化行为主要是指调用<strong>InitializingBean</strong>的<em>afterPropertiesSet</em>或者一个自定义的<em>init-method</em>。</p>
<a id="more"></a>
<h1 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h1><p>根据Spring提供的文档注释，不难获知<strong>BeanPostProcessor</strong>提供的两个方法会分别在bean进行初始化的前后被触发调用。抱着好奇心，也是为了更深入的理解，我通过IDE查看这两个方法的调用链，然后发现原来抽象类<strong>AbstractAutowireCapableBeanFactory</strong>的<em>initializeBean</em>方法会间接调用这两者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</div><div class="line">		AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				invokeAwareMethods(beanName, bean);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;, getAccessControlContext());</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		invokeAwareMethods(beanName, bean);</div><div class="line">	&#125;</div><div class="line">	Object wrappedBean = bean;</div><div class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</div><div class="line">		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		invokeInitMethods(beanName, wrappedBean, mbd);</div><div class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</div><div class="line">          (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</div><div class="line">          	beanName, <span class="string">"Invocation of init method failed"</span>, ex);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</div><div class="line">    	wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> wrappedBean;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法<em>applyBeanPostProcessorsBeforeInitialization</em>和<em>applyBeanPostProcessorsAfterInitialization</em>最终会分别调用已经注册的<strong>BeanPostProcessor</strong>的这两个方法，而且是在方法<em>invokeInitMethods</em>调用的前后。而方法<em>invokeInitMethods</em>实质就是对bean进行判定，来确定是否可以转换成<strong>InitializingBean</strong>进而调用接口方法<em>afterPropertiesSet</em>或者是否存在自定义的<em>init-method</em>进行调用。 </p>
<h1 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h1><p>通过<strong>ApplicationContext</strong>和<strong>BeanFactory</strong>进行注册的方式稍微有些不同。对于<strong>ApplicationContext</strong>来说，只要定义在其配置文件里(或注解方式)，它就会自动检测到<strong>BeanPostProcessor</strong>实现类 ，并将其注册；对于普通的<strong>BeanFactory</strong>来说，那么就需要显式以编程方式来调用方法<em>addBeanPostProcessor</em>进行注册。</p>
<p>假设项目开启了注解扫描，那么只需加上注解，就能实现<strong>ApplicationContext</strong>方式的自动注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out.println(<span class="string">"Enter MyBeanPostProcessor postProcessBeforeInitialization"</span>);</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out.println(<span class="string">"Enter MyBeanPostProcessor postProcessAfterInitialization"</span>);</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h1><p>在实际项目中，我们可能需要注册不止一个<strong>BeanPostProcessor</strong>的实现类，而不管是采用<strong>BeanFactory</strong>还是<strong>ApplicationContext</strong>，实际调用顺序都是取决于注册顺序。由于<strong>BeanFactory</strong>是显式编程方式调用，因此可以人为决定注册顺序；而采用<strong>ApplicationContext</strong>的自动检测方式，其注册顺序由以下的规则确定：</p>
<ol>
<li>首先调用实现了<strong>PriorityOrdered</strong>接口的<strong>BeanPostProcessor</strong>实现类，如果不止一个类实现了<strong>PriorityOrdered</strong>接口，那么会按照方法<em>getOrder</em>返回的值的大小，越大就会优先调用。</li>
<li>接着调用实现了<strong>Ordered</strong>接口的<strong>BeanPostProcessor</strong>实现类，如果不止一个类实现了<strong>Ordered</strong>接口，那么会按照<em>getOrder</em>返回的值的大小，值越大就会优先调用。</li>
<li>然后调用既没有实现<strong>PriorityOrdered</strong>也没有实现<strong>Ordered</strong>的<strong>BeanPostProcessor</strong>实现类，这个调用顺序往往是无序的，因为由于没有在注册之前进行排序操作。</li>
<li>最后是调用实现<strong>MergedBeanDefinitionPostProcessor</strong>(通常供框架内部使用)的实现类。</li>
</ol>
<p>感兴趣的话，可以看一下<strong>PostProcessorRegistrationDelegate</strong>的<em>registerBeanPostProcessors</em>方法，其内部实现了对<strong>BeanPostProcessor</strong>的注册(这也是<strong>AbstractApplicationContext</strong>的<em>refresh</em>过程之一)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></div><div class="line">		ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</div><div class="line"></div><div class="line">	String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></div><div class="line">	<span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></div><div class="line">	<span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></div><div class="line">	<span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</div><div class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</div><div class="line"></div><div class="line">	<span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></div><div class="line">	<span class="comment">// Ordered, and the rest.</span></div><div class="line">	List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</div><div class="line">	List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</div><div class="line">	List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</div><div class="line">		<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</div><div class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">			priorityOrderedPostProcessors.add(pp);</div><div class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">				internalPostProcessors.add(pp);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</div><div class="line">			orderedPostProcessorNames.add(ppName);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			nonOrderedPostProcessorNames.add(ppName);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></div><div class="line">	sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</div><div class="line">	registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</div><div class="line"></div><div class="line">	<span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></div><div class="line">	List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</div><div class="line">	<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</div><div class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">		orderedPostProcessors.add(pp);</div><div class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">			internalPostProcessors.add(pp);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	sortPostProcessors(beanFactory, orderedPostProcessors);</div><div class="line">	registerBeanPostProcessors(beanFactory, orderedPostProcessors);</div><div class="line"></div><div class="line">	<span class="comment">// Now, register all regular BeanPostProcessors.</span></div><div class="line">	List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</div><div class="line">	<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</div><div class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">		nonOrderedPostProcessors.add(pp);</div><div class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">			internalPostProcessors.add(pp);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</div><div class="line"></div><div class="line">	<span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></div><div class="line">	sortPostProcessors(beanFactory, internalPostProcessors);</div><div class="line">	registerBeanPostProcessors(beanFactory, internalPostProcessors);</div><div class="line"></div><div class="line">	<span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></div><div class="line">	<span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></div><div class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="简单实践"><a href="#简单实践" class="headerlink" title="简单实践"></a>简单实践</h1><p>现在考虑项目中有这样一个配置，它通过读取配置文件<strong>app.properties</strong>，可以设置规则属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:app.properties"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;app.rule&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String rule;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRule</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> rule;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们需要对设置的规则进行校验，可以通过实现自定义的<strong>BeanPostProcessor</strong>来解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleNameBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; rules = Arrays.asList(<span class="string">"ruleA"</span>, <span class="string">"ruleB"</span>, <span class="string">"ruleC"</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MyConfig) &#123;</div><div class="line">            MyConfig config = (MyConfig) bean;</div><div class="line">            <span class="keyword">if</span> (!rules.contains(config.getRule())) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Invalid rule"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们在<strong>app.properties</strong>文件中配置了预定义规则之外的规则，那么程序在启动的时候就会抛出异常</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/BeanInitializationException.png" alt="异常信息"></p>
<p>通过启动阶段的检测机制，我们能够快速发现可能存在的问题，从而避免在程序运行期间发现错误。当然<strong>BeanPostProcessor</strong>在实际项目中肯定可以发挥更多的作用，这有待于我们进一步去挖掘。另外，如果对于Spring源码感兴趣的话，这个接口以及框架内部已有的实现类也是我们必须要了解的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html" target="_blank" rel="external">BeanPostProcessor javadoc</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;接口简介&quot;&gt;&lt;a href=&quot;#接口简介&quot; class=&quot;headerlink&quot; title=&quot;接口简介&quot;&gt;&lt;/a&gt;接口简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;BeanPostProcessor&lt;/strong&gt;是Spring提供的一个钩子(&lt;em&gt;Hook&lt;/em&gt;)接口，可用于实现对新的bean实例进行自定义修改，比如说，检测bean是否实现了某些特定接口从而可以对其进行进一步操作，或者可以将原实例进行包装而实际返回代理对象。其内部主要声明了&lt;em&gt;postProcessBeforeInitialization&lt;/em&gt;和&lt;em&gt;postProcessAfterInitialization&lt;/em&gt;两个回调方法，具体的接口声明如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BeanPostProcessor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  	&lt;span class=&quot;comment&quot;&gt;//在bean进行初始化行为之前被调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;Object &lt;span class=&quot;title&quot;&gt;postProcessBeforeInitialization&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  	&lt;span class=&quot;comment&quot;&gt;//在bean进行初始化行为之后被调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;Object &lt;span class=&quot;title&quot;&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是这里所说的bean初始化行为主要是指调用&lt;strong&gt;InitializingBean&lt;/strong&gt;的&lt;em&gt;afterPropertiesSet&lt;/em&gt;或者一个自定义的&lt;em&gt;init-method&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://lukaicheng.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 5 验证、数据绑定和类型转换[译]</title>
    <link href="https://lukaicheng.github.io/2017/05/13/Spring5-validation-translate/"/>
    <id>https://lukaicheng.github.io/2017/05/13/Spring5-validation-translate/</id>
    <published>2017-05-13T13:15:12.000Z</published>
    <updated>2017-06-30T09:24:11.508Z</updated>
    
    <content type="html"><![CDATA[<p>发布于并发编程网，文章<a href="http://ifeve.com/spring-5-validation/" target="_blank" rel="external">链接</a></p>
<h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><blockquote>
<p>JSR-303/JSR-349 Bean Validation</p>
<p>在设置支持方面，Spring Framework 4.0支持Bean Validation 1.0(JSR-303)和Bean Validation 1.1(JSR-349)，也将其改写成了Spring的<code>Validator</code>接口。</p>
<p>正如<a href="#5.8 Spring Validation">5.8 Spring验证</a>所述，应用程序可以选择一次性全局启用Bean验证，并使其专门用于所有的验证需求。</p>
<p>正如<a href="#5.8.3 Configuring a DataBinder">5.8.3 配置DataBinder</a>所述，应用程序也可以为每个<code>DataBinder</code>实例注册额外的Spring <code>Validator</code>实例，这可能有助于不通过使用注解而插入验证逻辑。</p>
</blockquote>
<a id="more"></a>
<p>考虑将验证作为业务逻辑是有利有弊的，Spring提供了一种不排除利弊的用于验证(和数据绑定)的设计。具体的验证不应该捆绑在web层，应该容易本地化并且它应该能够插入任何可用的验证器。考虑到以上这些，Spring想出了一个<code>Validator</code>接口，它在应用程序的每一层基本都是可用的。数据绑定对于将用户输入动态绑定到应用程序的领域模型上(或者任何你用于处理用户输入的对象)是非常有用的。Spring提供了所谓的<code>DataBinder</code>来处理这个。<code>Validator</code>和<code>DataBinder</code>组成了<code>validation</code>包，其主要用于但并不局限于MVC框架。</p>
<p><code>BeanWrapper</code>是Spring框架中的一个基本概念且在很多地方使用。然而，你可能并不需要直接使用<code>BeanWrapper</code>。尽管这是参考文档，我们仍然觉得有一些说明需要一步步来。我们将会在本章中解释<code>BeanWrapper</code>，因为你极有可能会在尝试将数据绑定到对象的时候使用它。</p>
<p>Spring的DataBinder和底层的BeanWrapper都使用PropertyEditor来解析和格式化属性值。<code>PropertyEditor</code>概念是JavaBeans规范的一部分，并会在本章进行说明。Spring 3不仅引入了”core.convert”包来提供一套通用类型转换工具，还有一个高层次的”format”包用于格式化UI字段值。可以将这些新包视作更简单的PropertyEditor替代方式来使用，本章还会对此进行讨论。</p>
<h2 id="5-2-使用Spring的验证器接口进行验证"><a href="#5-2-使用Spring的验证器接口进行验证" class="headerlink" title="5.2 使用Spring的验证器接口进行验证"></a>5.2 使用Spring的验证器接口进行验证</h2><p>Spring具有一个<code>Validator</code>接口可以让你用于验证对象。<code>Validator</code>接口在工作时需要使用一个<code>Errors</code>对象，以便于在验证过程中，验证器可以将验证失败的信息报告给这个<code>Errors</code>对象。</p>
<p>让我们考虑一个小的数据对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    </div><div class="line">    <span class="comment">// the usual getters and setters...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过实现<code>org.springframework.validation.Validator</code>的下列两个接口，我们打算为<code>Person</code>类提供验证行为：</p>
<ul>
<li><code>support(Class)</code> - 这个<code>Validator</code>是否可以验证给定<code>Class</code>的实例</li>
<li><code>validate(Object,org.springframework.validation.Errors)</code> - 验证给定的对象并且万一验证错误，可以将这些错误注册到给定的<code>Errors</code>对象</li>
</ul>
<p>实现一个<code>Validator</code>是相当简单的，特别是当你知道Spring框架还提供了<code>ValidationUtils</code>辅助类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * This Validator validates *just* Person instances</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class clazz)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> Person.class.equals(clazz);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object obj, Errors e)</span> </span>&#123;</div><div class="line">		ValidationUtils.rejectIfEmpty(e, <span class="string">"name"</span>, <span class="string">"name.empty"</span>);</div><div class="line">		Person p = (Person) obj;</div><div class="line">		<span class="keyword">if</span> (p.getAge() &lt; <span class="number">0</span>) &#123;</div><div class="line">			e.rejectValue(<span class="string">"age"</span>, <span class="string">"negativevalue"</span>);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.getAge() &gt; <span class="number">110</span>) &#123;</div><div class="line">			e.rejectValue(<span class="string">"age"</span>, <span class="string">"too.darn.old"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如你看到的，<code>ValidationUtils</code>类的<code>static</code>  <code>rejectIfEmpty(..)</code>方法被用于拒绝那些值为<code>null</code>或者空字符串的<code>&#39;name&#39;</code>属性。除了上面展示的例子之外，去看一看<code>ValidationUtils</code>的java文档有助于了解它提供的功能。</p>
<p>通过实现单个的<code>Validator</code>类来逐个验证富对象中的嵌套对象当然是有可能的，然而将验证逻辑封装在每个嵌套类对象自身的<code>Validator</code>实现中可能是一种更好的选择。<code>Customer</code>就是一个<em>‘富’</em>对象的简单示例，它由两个字符串属性(姓和名)以及一个复杂对象<code>Address</code>组成。<code>Address</code>对象可能独立于<code>Customer</code>对象使用，因此已经实现了一个独特的<code>AddressValidator</code>。如果你想要你的<code>CustomerValidator</code>不借助于复制粘贴而重用包含在<code>AddressValidator</code>中的逻辑，那么你可以通过依赖注入或者实例化你的<code>CustomerValidator</code>中的<code>AddressValidator</code>，然后像这样使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Validator addressValidator;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomerValidator</span><span class="params">(Validator addressValidator)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (addressValidator == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The supplied [Validator] is "</span> +</div><div class="line">				<span class="string">"required and must not be null."</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (!addressValidator.supports(Address.class)) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The supplied [Validator] must "</span> +</div><div class="line">				<span class="string">"support the validation of [Address] instances."</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.addressValidator = addressValidator;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * This Validator validates Customer instances, and any subclasses of Customer too</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class clazz)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> Customer.class.isAssignableFrom(clazz);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</div><div class="line">		ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">"firstName"</span>, <span class="string">"field.required"</span>);</div><div class="line">		ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">"surname"</span>, <span class="string">"field.required"</span>);</div><div class="line">		Customer customer = (Customer) target;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			errors.pushNestedPath(<span class="string">"address"</span>);</div><div class="line">			ValidationUtils.invokeValidator(<span class="keyword">this</span>.addressValidator, customer.getAddress(), errors);</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			errors.popNestedPath();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>验证错误被报告给传递到验证器的<code>Errors</code>对象。在使用Spring Web MVC的情况下，你可以使用<code>&lt;spring:bind/&gt;</code>标签来检查错误信息，不过当然你也可以自己检查错误对象。有关它提供的方法的更多信息可以在java文档中找到。</p>
<h2 id="5-3-将代码解析成错误消息"><a href="#5-3-将代码解析成错误消息" class="headerlink" title="5.3 将代码解析成错误消息"></a>5.3 将代码解析成错误消息</h2><p>在之前我们已经谈论了数据绑定和验证，最后一件值得讨论的事情是输出对应于验证错误的消息。在我们上面展示的例子里，我们拒绝了<code>name</code>和<code>age</code>字段。如果我们要使用<code>MessageSource</code>来输出错误消息，我们将会使用我们在拒绝该字段(这个情况下是’姓名’和’年龄’)时给出的错误代码。当你调用(不管是直接调用还是间接通过使用<code>ValidationUtils</code>类调用)来自<code>Errors</code>接口的<code>rejectValue</code>或者其他<code>reject</code>方法时，其底层实现不仅会注册你传入的代码，还会注册一些额外的错误代码。注册怎样的错误代码取决于它所使用的<code>MessageCodesResolver</code>，默认情况下，会使用<code>DefaultMessageCodesResolver</code>，其不仅会使用你提供的代码注册消息，还会注册包含你传递给拒绝方法的字段名称的消息。所以如果你使用<code>rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;)</code>来拒绝一个字段，除了<code>too.darn.old</code>代码，Spring还会注册<code>too.darn.old.age</code>和<code>too.darn.old.age.int</code>(第一个会包含字段名称且第二个会包含字段类型)。这样做是为了方便开发人员来定位错误消息等。</p>
<p>有关<code>MessageCodesResolver</code>和其默认策略的更多信息可以分别在<code>MessageCodesResolver</code>以及<code>DefaultMessageCodesResolver</code>的在线java文档中找到。</p>
<h2 id="5-4-Bean操作和BeanWrapper"><a href="#5-4-Bean操作和BeanWrapper" class="headerlink" title="5.4 Bean操作和BeanWrapper"></a>5.4 Bean操作和BeanWrapper</h2><p><code>org.springframework.beans</code>包遵循Oracle提供的JavaBeans标准。一个JavaBean只是一个包含默认无参构造器的类，它遵循一个命名约定(通过一个例子)：一个名为<code>bingoMadness</code>属性将有一个设置方法<code>setBingoMadness(..)</code>和一个获取方法<code>getBingoMadness(..)</code>。有关JavaBeans和其规范的更多信息，请参考Oracle的网站(<a href="https://docs.oracle.com/javase/6/docs/api/java/beans/package-summary.html" target="_blank" rel="external">javabeans</a>)。</p>
<p>beans包里一个非常重要的类是<code>BeanWrapper</code>接口和它的相应实现(<code>BeanWrapperImpl</code>)。引用自java文档，<code>BeanWrapper</code>提供了设置和获取属性值(单独或批量)、获取属性描述符以及查询属性以确定它们是可读还是可写的功能。<code>BeanWrapper</code>还提供对嵌套属性的支持，能够不受嵌套深度的限制启用子属性的属性设置。然后，<code>BeanWrapper</code>提供了无需目标类代码的支持就能够添加标准JavaBeans的<code>PropertyChangeListeners</code>和<code>VetoableChangeListeners</code>的能力。最后然而并非最不重要的是，<code>BeanWrapper</code>提供了对索引属性设置的支持。<code>BeanWrapper</code>通常不会被应用程序的代码直接使用，而是由<code>DataBinder</code>和<code>BeanFactory</code>使用。</p>
<p><code>BeanWrapper</code>的名字已经部分暗示了它的工作方式：它包装一个bean以对其执行操作，比如设置和获取属性。</p>
<h3 id="5-4-1-设置并获取基本和嵌套属性"><a href="#5-4-1-设置并获取基本和嵌套属性" class="headerlink" title="5.4.1 设置并获取基本和嵌套属性"></a>5.4.1 设置并获取基本和嵌套属性</h3><p>使用<code>setPropertyValue(s)</code>和<code>getPropertyValue(s)</code>可以设置并获取属性，两者都带有几个重载方法。在Spring自带的java文档中对它们有更详细的描述。重要的是要知道对象属性指示的几个约定。几个例子：</p>
<p><strong>表 5.1. 属性示例</strong></p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>表示属性<code>name</code>与方法<code>getName()</code>或<code>isName()</code>和<code>setName()</code>相对应</td>
</tr>
<tr>
<td><code>account.name</code></td>
<td>表示属性<code>account</code>的嵌套属性<code>name</code>与方法<code>getAccount().setName()</code>或<code>getAccount().getName()</code>相对应</td>
</tr>
<tr>
<td><code>account[2]</code></td>
<td>表示索引属性<code>account</code>的第三个元素。索引属性可以是<code>array</code>、<code>list</code>或其他自然排序的集合</td>
</tr>
<tr>
<td><code>account[COMPANYNAME]</code></td>
<td>表示映射属性<code>account</code>被键<em>COMPANYNAME</em>索引到的映射项的值</td>
</tr>
</tbody>
</table>
<p>下面你会发现一些使用<code>BeanWrapper</code>来获取和设置属性的例子。</p>
<p><em>(如果你不打算直接使用<code>BeanWrapper</code>，那么下一部分对你来说并不重要。如果你仅使用<code>DataBinder</code>和<code>BeanFactory</code>以及它们开箱即用的实现，你应该跳到关于<code>PropertyEditor</code>部分的开头)。</em></p>
<p>考虑下面两个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> Employee managingDirector;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Employee <span class="title">getManagingDirector</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.managingDirector;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setManagingDirector</span><span class="params">(Employee managingDirector)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.managingDirector = managingDirector;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">float</span> salary;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> salary;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">float</span> salary)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.salary = salary;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下的代码片段展示了如何检索和操纵实例化的<code>Companies</code>和<code>Employees</code>的某些属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">BeanWrapper company = <span class="keyword">new</span> BeanWrapperImpl(<span class="keyword">new</span> Company());</div><div class="line"><span class="comment">// setting the company name..</span></div><div class="line">company.setPropertyValue(<span class="string">"name"</span>, <span class="string">"Some Company Inc."</span>);</div><div class="line"><span class="comment">// ... can also be done like this:</span></div><div class="line">PropertyValue value = <span class="keyword">new</span> PropertyValue(<span class="string">"name"</span>, <span class="string">"Some Company Inc."</span>);</div><div class="line">company.setPropertyValue(value);</div><div class="line"></div><div class="line"><span class="comment">// ok, let's create the director and tie it to the company:</span></div><div class="line">BeanWrapper jim = <span class="keyword">new</span> BeanWrapperImpl(<span class="keyword">new</span> Employee());</div><div class="line">jim.setPropertyValue(<span class="string">"name"</span>, <span class="string">"Jim Stravinsky"</span>);</div><div class="line">company.setPropertyValue(<span class="string">"managingDirector"</span>, jim.getWrappedInstance());</div><div class="line"></div><div class="line"><span class="comment">// retrieving the salary of the managingDirector through the company</span></div><div class="line">Float salary = (Float) company.getPropertyValue(<span class="string">"managingDirector.salary"</span>);</div></pre></td></tr></table></figure>
<h3 id="5-4-2-内置PropertyEditor实现"><a href="#5-4-2-内置PropertyEditor实现" class="headerlink" title="5.4.2 内置PropertyEditor实现"></a>5.4.2 内置PropertyEditor实现</h3><p>Spring使用<code>PropertyEditor</code>的概念来实现<code>Object</code>和<code>String</code>之间的转换。如果你考虑到它，有时候换另一种方式表示属性可能比对象本身更方便。举个例子，一个<code>Date</code>可以以人类可读的方式表示(如<code>String</code> <code>&#39;2007-14-09&#39;</code>)，同时我们依然能把人类可读的形式转换回原始的时间(甚至可能更好：将任何以人类可读形式输入的时间转换回<code>Date</code>对象)。这种行为可以通过注册类型为<code>PropertyEditor</code>的自定义编辑器来实现。在<code>BeanWrapper</code>或上一章提到的特定IoC容器中注册自定义编辑器，可以使其了解如何将属性转换为期望的类型。请阅读Oracle为<code>java.beans</code>包提供的java文档来获取更多关于<code>PropertyEditor</code>的信息。</p>
<p>这是Spring使用属性编辑的两个例子：</p>
<ul>
<li>使用<code>PropertyEditor</code>来完成<em>bean的属性设置</em>。当提到将<code>java.lang.String</code>作为你在XML文件中声明的某些bean的属性值时，Spring将会(如果相应的属性的设置方法具有一个<code>Class</code>参数)使用<code>ClassEditor</code>尝试将参数解析成<code>Class</code>对象。</li>
<li>在Spring的MVC框架中<em>解析HTTP请求的参数</em>是由各种<code>PropertyEditor</code>完成的，你可以把它们手动绑定到<code>CommandController</code>的所有子类。</li>
</ul>
<p>Spring有一些内置的<code>PropertyEditor</code>使生活变得轻松。它们中的每一个都已列在下面，并且它们都被放在<code>org.springframework.beans.propertyeditors</code>包中。大部分但并不是全部(如下所示)，默认情况下会由<code>BeanWrapperImpl</code>注册。在某种方式下属性编辑器是可配置的，那么理所当然，你可以注册你自己的变种来覆盖默认编辑器：</p>
<p><span id="5.4.2-Built-in PropertyEditor implementations"><strong>Table 5.2. 内置PropertyEditor</strong></span></p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ByteArrayPropertyEditor</code></td>
<td>针对字节数组的编辑器。字符串会简单地转换成相应的字节表示。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>ClassEditor</code></td>
<td>将类的字符串表示形式解析成实际的类形式并且也能返回实际类的字符串表示形式。如果找不到类，会抛出一个<code>IllegalArgumentException</code>。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>CustomBooleanEditor</code></td>
<td>针对<code>Boolean</code>属性的可定制的属性编辑器。默认情况下由<code>BeanWrapperImpl</code>注册，但是可以作为一种自定义编辑器通过注册其自定义实例来进行覆盖。</td>
</tr>
<tr>
<td><code>CustomCollectionEditor</code></td>
<td>针对集合的属性编辑器，可以将原始的<code>Collection</code>转换成给定的目标<code>Collection</code>类型。</td>
</tr>
<tr>
<td><code>CustomDateEditor</code></td>
<td>针对java.util.Date的可定制的属性编辑器，支持自定义的时间格式。不会被默认注册，用户必须使用适当格式进行注册。</td>
</tr>
<tr>
<td><code>CustomNumberEditor</code></td>
<td>针对任何Number子类(比如<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>)的可定制的属性编辑器。默认情况下由<code>BeanWrapperImpl</code>注册，但是可以作为一种自定义编辑器通过注册其自定义实例来进行覆盖。</td>
</tr>
<tr>
<td><code>FileEditor</code></td>
<td>能够将字符串解析成<code>java.io.File</code>对象。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>InputStreamEditor</code></td>
<td>一次性的属性编辑器，能够读取文本字符串并生成(通过中间的<code>ResourceEditor</code>以及<code>Resource</code>)一个<code>InputStream</code>对象，因此*<code>InputStream</code>类型的属性可以直接以字符串设置。请注意默认的使用方式不会为你关闭<code>InputStream</code>！默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>LocaleEditor</code></td>
<td>能够将字符串解析成<code>Locale</code>对象，反之亦然(字符串格式是<em>[country]</em>[variant]，这与Locale提供的toString()方法是一样的)。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>PatternEditor</code></td>
<td>能够将字符串解析成<code>java.util.regex.Pattern</code>对象，反之亦然。</td>
</tr>
<tr>
<td><code>PropertiesEditor</code></td>
<td>能够将字符串(按照<code>java.util.Properties</code>类的java文档定义的格式进行格式化)解析成<code>Properties</code>对象。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>StringTrimmerEditor</code></td>
<td>用于缩减字符串的属性编辑器。有选择性允许将一个空字符串转变成<code>null</code>值。不会进行默认注册，需要在用户有需要的时候注册。</td>
</tr>
<tr>
<td><code>URLEditor</code></td>
<td>能够将一个URL的字符串表示解析成实际的<code>URL</code>对象。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
</tbody>
</table>
<p>Spring使用<code>java.beans.PropertyEditorManager</code>来设置可能需要的属性编辑器的搜索路径。搜索路径中还包括了<code>sun.bean.editors</code>，这个包里面包含如<code>Font</code>、<code>Color</code>类型以及其他大部分基本类型的<code>PropertyEditor</code>实现。还要注意的是，如果<code>PropertyEditor</code>类与它们所处理的类位于同一个包并且除了’Editor’后缀之外拥有相同的名字，那么标准的JavaBeans基础设施会自动发现这些它们(不需要你显式的注册它们)。例如，有人可能会有以下的类和包结构，这已经足够识别出<code>FooEditor</code>类并将其作为<strong><code>Foo</code></strong>类型属性的<code>PropertyEditor</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">com</div><div class="line">  chank</div><div class="line">    pop</div><div class="line">      Foo</div><div class="line">      FooEditor // the PropertyEditor for the Foo class</div></pre></td></tr></table></figure>
<p>要注意的是在这里你也可以使用标准JavaBeans机制的<code>BeanInfo</code>(在<a href="https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html" target="_blank" rel="external">in not-amazing-detail here</a>有描述)。在下面的示例中，你可以看到使用<code>BeanInfo</code>机制为一个关联类的属性显式注册一个或多个<code>PropertyEditor</code>实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">com</div><div class="line">  chank</div><div class="line">    pop</div><div class="line">      Foo</div><div class="line">      FooBeanInfo // the BeanInfo for the Foo class</div></pre></td></tr></table></figure>
<p>这是被引用到的<code>FooBeanInfo</code>类的Java源代码。它会将一个<code>CustomNumberEditor</code>同<code>Foo</code>类的<code>age</code>属性关联。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBeanInfo</span> <span class="keyword">extends</span> <span class="title">SimpleBeanInfo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">final</span> PropertyEditor numberPE = <span class="keyword">new</span> CustomNumberEditor(Integer.class, <span class="keyword">true</span>);</div><div class="line">			PropertyDescriptor ageDescriptor = <span class="keyword">new</span> PropertyDescriptor(<span class="string">"age"</span>, Foo.class) &#123;</div><div class="line">				<span class="function"><span class="keyword">public</span> PropertyEditor <span class="title">createPropertyEditor</span><span class="params">(Object bean)</span> </span>&#123;</div><div class="line">					<span class="keyword">return</span> numberPE;</div><div class="line">				&#125;;</div><div class="line">			&#125;;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> PropertyDescriptor[] &#123; ageDescriptor &#125;;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (IntrospectionException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Error(ex.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><span id="Registering additional custom PropertyEditors"></span></p>
<h4 id="注册额外的自定义PropertyEditor"><a href="#注册额外的自定义PropertyEditor" class="headerlink" title="注册额外的自定义PropertyEditor"></a>注册额外的自定义PropertyEditor</h4><p>当bean属性设置成一个字符串值时，Spring IoC容器最终会使用标准JavaBeans的<code>PropertyEditor</code>将这些字符串转换成复杂类型的属性。Spring预先注册了一些自定义<code>PropertyEditor</code>(例如将一个以字符串表示的类名转换成真正的<code>Class</code>对象)。此外，Java的标准JavaBeans <code>PropertyEditor</code>查找机制允许一个<code>PropertyEditor</code>只需要恰当的命名并同它支持的类位于相同的包，就能够自动发现它。</p>
<p>如果需要注册其他自定义的<code>PropertyEditor</code>，还有几种可用机制。假设你有一个<code>BeanFactory</code>引用，最人工化的方式(但通常并不方便或者推荐)是直接使用<code>ConfigurableBeanFactory</code>接口的<code>registerCustomEditor()</code>方法。另一种略为方便的机制是使用一个被称为<code>CustomEditorConfigurer</code>的特殊的bean factory后置处理器(<em>post-processor</em>)。虽然bean factory后置处理器可以与<code>BeanFactory</code>实现一起使用，但是因为<code>CustomEditorConfigurer</code>有一个嵌套属性设置过程，所以强烈推荐它与<code>ApplicationContext</code>一起使用，这样就可以采用与其他bean类似的方式来部署它，并自动检测和应用。</p>
<p>请注意所有的bean工厂和应用上下文都会自动地使用一些内置属性编辑器，这些编辑器通过一个被称为<code>BeanWrapper</code>的接口来处理属性转换。<code>BeanWrapper</code>注册的那些标准属性编辑器已经列在<a href="#5.4.2-Built-in PropertyEditor implementations">上一部分</a>。 此外，针对特定的应用程序上下文类型，<code>ApplicationContext</code>会用适当的方法覆盖或添加一些额外的编辑器来处理资源查找。</p>
<p>标准的JavaBeans <code>PropertyEditor</code>实例用于将字符串表示的属性值转换成实际的复杂类型属性。<code>CustomEditorConfigurer</code>，一个bean factory后处理器，可以为添加额外的<code>PropertyEditor</code>到<code>ApplicationContext</code>提供便利支持。</p>
<p>考虑一个用户类<code>ExoticType</code>和另外一个需要将<code>ExoticType</code>设为属性的类<code>DependsOnExoticType</code>： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> example;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExoticType</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ExoticType</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependsOnExoticType</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ExoticType type;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(ExoticType type)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.type = type;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当东西都被正确设置时，我们希望能够分配字符串给type属性，而<code>PropertyEditor</code>会在背后将其转换成实际的<code>ExoticType</code>实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sample"</span> <span class="attr">class</span>=<span class="string">"example.DependsOnExoticType"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"type"</span> <span class="attr">value</span>=<span class="string">"aNameForExoticType"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>PropertyEditor</code>实现可能与此类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// converts string representation to ExoticType object</span></div><div class="line"><span class="keyword">package</span> example;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExoticTypeEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> </span>&#123;</div><div class="line">		setValue(<span class="keyword">new</span> ExoticType(text.toUpperCase()));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我们使用<code>CustomEditorConfigurer</code>将一个新的<code>PropertyEditor</code>注册到<code>ApplicationContext</code>，那么在需要的时候就能够使用它：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomEditorConfigurer"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"customEditors"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"example.ExoticType"</span> <span class="attr">value</span>=<span class="string">"example.ExoticTypeEditor"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="使用PropertyEditorRegistrar"><a href="#使用PropertyEditorRegistrar" class="headerlink" title="使用PropertyEditorRegistrar"></a>使用PropertyEditorRegistrar</h4><p>另一种将属性编辑器注册到Spring容器的机制是创建和使用一个<code>PropertyEditorRegistrar</code>。当你需要在几个不同场景里使用同一组属性编辑器，这个接口会特别有用：编写一个相应的registrar并在每个用例里重用。<code>PropertyEditorRegistrar</code>与一个被称为<code>PropertyEditorRegistry</code>的接口配合工作，后者被Spring的<code>BeanWrapper</code>(以及<code>DataBinder</code>)实现。当与<code>CustomEditorConfigurer</code>配合使用的时候，<code>PropertyEditorRegistrar</code>特别方便(<a href="#Registering additional custom PropertyEditors">这里</a>有介绍)，因为前者暴露了一个方法<code>setPropertyEditorRegistrars(..)</code>：以这种方式添加到<code>CustomEditorConfigurerd</code>的<code>PropertyEditorRegistrar</code>可以很容易地在<code>DataBinder</code>和Spring MVC <code>Controllers</code>之间共享。另外，它避免了在自定义编辑器上的同步需求：一个<code>PropertyEditorRegistrar</code>可以为每一次bean创建尝试创建新的<code>PropertyEditor</code>实例。</p>
<p>使用<code>PropertyEditorRegistrar</code>可能最好还是以一个例子来说明。首先，你需要创建你自己的<code>PropertyEditorRegistrar</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.foo.editors.spring;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPropertyEditorRegistrar</span> <span class="keyword">implements</span> <span class="title">PropertyEditorRegistrar</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCustomEditors</span><span class="params">(PropertyEditorRegistry registry)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">// it is expected that new PropertyEditor instances are created</span></div><div class="line">		registry.registerCustomEditor(ExoticType.class, <span class="keyword">new</span> ExoticTypeEditor());</div><div class="line"></div><div class="line">		<span class="comment">// you could register as many custom property editors as are required here...</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以查看<code>org.springframework.beans.support.ResourceEditorRegistrar</code>当作一个<code>PropertyEditorRegistrar</code>实现的示例。注意在它的<code>registerCustomEditors(..)</code>方法实现里是如何为每个属性编辑器创建新的实例的。</p>
<p>接着我们配置了一个<code>CustomEditorConfigurerd</code>并将我们的<code>CustomPropertyEditorRegistrar</code>注入其中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomEditorConfigurer"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"propertyEditorRegistrars"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"customPropertyEditorRegistrar"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customPropertyEditorRegistrar"</span></span></div><div class="line">	<span class="attr">class</span>=<span class="string">"com.foo.editors.spring.CustomPropertyEditorRegistrar"</span>/&gt;</div></pre></td></tr></table></figure>
<p>最后，有点偏离本章的重点，针对你们之中使用<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html" target="_blank" rel="external">Spring’s MVC web framework</a>的那些人，使用<code>PropertyEditorRegistrar</code>与数据绑定的<code>Controller</code>(比如<code>SimpleFormController</code>)配合使用会非常方便。下面是一个在<code>initBinder(..)</code>方法的实现里使用<code>PropertyEditorRegistrar</code>的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterUserController</span> <span class="keyword">extends</span> <span class="title">SimpleFormController</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> PropertyEditorRegistrar customPropertyEditorRegistrar;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RegisterUserController</span><span class="params">(PropertyEditorRegistrar propertyEditorRegistrar)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.customPropertyEditorRegistrar = propertyEditorRegistrar;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(HttpServletRequest request,</span></span></div><div class="line">			ServletRequestDataBinder binder) <span class="keyword">throws</span> Exception &#123;</div><div class="line">		<span class="keyword">this</span>.customPropertyEditorRegistrar.registerCustomEditors(binder);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// other methods to do with registering a User</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种<code>PropertyEditor</code>注册的风格可以导致简洁的代码(<code>initBinder(..)</code>的实现仅仅只有一行！)，同时也允许将通用的<code>PropertyEditor</code>注册代码封装到一个类里然后根据需要在尽可能多的<code>Controller</code>之间共享。</p>
<h2 id="5-5-Spring类型转换"><a href="#5-5-Spring类型转换" class="headerlink" title="5.5 Spring类型转换"></a>5.5 Spring类型转换</h2><p>Spring 3引入了<code>core.convert</code>包来提供一个一般类型的转换系统。这个系统定义了实现类型转换逻辑的服务提供接口(SPI)以及在运行时执行类型转换的API。在Spring容器内，这个系统可以当作是PropertyEditor的替代选择，用于将外部bean的属性值字符串转换成所需的属性类型。这个公共的API也可以在你的应用程序中任何需要类型转换的地方使用。</p>
<h3 id="5-5-1-Converter-SPI"><a href="#5-5-1-Converter-SPI" class="headerlink" title="5.5.1 Converter SPI"></a>5.5.1 Converter SPI</h3><p>实现类型转换逻辑的SPI是简单并且强类型的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要创建属于你自己的转换器，只需要简单的实现以上接口即可。泛型参数S表示你想要进行转换的源类型，而泛型参数T表示你想要转换的目标类型。如果一个包含S类型元素的集合或数组需要转换为一个包含T类型的数组或集合，那么这个转换器也可以被透明地应用，前提是已经注册了一个委托数组或集合的转换器(默认情况下会是<code>DefaultConversionService</code>处理)。</p>
<p>对每次方法<code>convert(S)</code>的调用，source参数值必须确保不为空。如果转换失败，你的转换器可以抛出任何非受检异常(<em>unchecked exception</em>)；具体来说，为了报告一个非法的source参数值，应该抛出一个<code>IllegalArgumentException</code>。还有要注意确保你的<code>Converter</code>实现必须是线程安全的。</p>
<p>为方便起见，<code>core.convert.support</code>包已经提供了一些转换器实现，这些实现包括了从字符串到数字以及其他常见类型的转换。考虑将<code>StringToInteger</code>作为一个典型的<code>Converter</code>实现示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.support;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToInteger</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> Integer.valueOf(source);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-5-2-ConverterFactory"><a href="#5-5-2-ConverterFactory" class="headerlink" title="5.5.2 ConverterFactory"></a>5.5.2 ConverterFactory</h3><p>当你需要集中整个类层次结构的转换逻辑时，例如，碰到将String转换到java.lang.Enum对象的时候，请实现<code>ConverterFactory</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	&lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>泛型参数S表示你想要转换的源类型，泛型参数R表示你可以转换的那些范围内的类型的基类。然后实现getConverter(Class<t>)，其中T就是R的一个子类。</t></p>
<p>考虑将<code>StringToEnum</code>作为ConverterFactory的一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.support;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToEnumConverterFactory</span> <span class="keyword">implements</span> <span class="title">ConverterFactory</span>&lt;<span class="title">String</span>, <span class="title">Enum</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> &lt;T extends Enum&gt; <span class="function">Converter&lt;String, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StringToEnumConverter(targetType);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToEnumConverter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Enum</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">		<span class="keyword">private</span> Class&lt;T&gt; enumType;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">StringToEnumConverter</span><span class="params">(Class&lt;T&gt; enumType)</span> </span>&#123;</div><div class="line">			<span class="keyword">this</span>.enumType = enumType;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> (T) Enum.valueOf(<span class="keyword">this</span>.enumType, source.trim());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-5-3-GenericConverter"><a href="#5-5-3-GenericConverter" class="headerlink" title="5.5.3 GenericConverter"></a>5.5.3 GenericConverter</h3><p>当你需要一个复杂的转换器实现时，请考虑GenericConverter接口。GenericConverter具备更加灵活但是不太强的类型签名，以支持在多种源类型和目标类型之间的转换。此外，当实现你的转换逻辑时，GenericConverter还可以使源字段和目标字段的上下文对你可用，这样的上下文允许类型转换由字段上的注解或者字段声明中的泛型信息来驱动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要实现一个GenericConverter，getConvertibleTypes()方法要返回支持的源-目标类型对，然后实现convert(Object,TypeDescriptor,TypeDescriptor)方法来实现你的转换逻辑。源TypeDescriptor提供了对持有被转换值的源字段的访问，目标TypeDescriptor提供了对设置转换值的目标字段的访问。</p>
<p>一个很好的GenericConverter的示例是一个在Java数组和集合之间进行转换的转换器。这样一个ArrayToCollectionConverter可以通过内省声明了目标集合类型的字段以解析集合元素的类型，这将允许原数组中每个元素可以在集合被设置到目标字段之前转换成集合元素的类型。</p>
<blockquote>
<p>由于GenericConverter是一个更复杂的SPI接口，所以对基本类型的转换需求优先使用Converter或者ConverterFactory。 </p>
</blockquote>
<h4 id="ConditionalGenericConverter"><a href="#ConditionalGenericConverter" class="headerlink" title="ConditionalGenericConverter"></a>ConditionalGenericConverter</h4><p>有时候你只想要在特定条件成立的情况下<code>Converter</code>才执行，例如，你可能只想要在目标字段存在特定注解的情况下才执行<code>Converter</code>，或者你可能只想要在目标类中定义了特定方法，比如<code>static</code> <code>valueOf</code>方法，才执行<code>Converter</code>。<code>ConditionalGenericConverter</code>是<code>GenericConverter</code>和<code>ConditionalConveter</code>接口的联合，允许你定义这样的自定义匹配条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionalGenericConverter</span></span></div><div class="line">        <span class="keyword">extends</span> <span class="title">GenericConverter</span>, <span class="title">ConditionalConverter</span> &#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ConditionalGenericConverter</code>的一个很好的例子是一个在持久化实体标识和实体引用之间进行转换的实体转换器。这个实体转换器可能只匹配这样的条件–目标实体类声明了一个静态的查找方法，例如<code>findAccount(Long)</code>，你将在<code>matches(TypeDescriptor,TypeDescriptor)</code>方法实现里执行这样的查找方法的检测。</p>
<h3 id="5-5-4-ConversionService-API"><a href="#5-5-4-ConversionService-API" class="headerlink" title="5.5.4 ConversionService API"></a>5.5.4 ConversionService API</h3><p>ConversionService接口定义了运行时执行类型转换的统一API，转换器往往是在这个门面(<em>facade</em>)接口背后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConversionService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</div><div class="line"></div><div class="line">	&lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(Object source, Class&lt;T&gt; targetType)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">	<span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大多数ConversionService实现也会实现<code>ConverterRegistry</code>接口，这个接口提供一个用于注册转换器的服务提供接口(SPI)。在内部，一个ConversionService实现会以委托给注册其中的转换器的方式来执行类型转换逻辑。</p>
<p><code>core.convert.support</code>包已经提供了一个强大的ConversionService实现，<code>GenericConversionService</code>是适用于大多数环境的通用实现，<code>ConversionServiceFactory</code>以工厂的方式为创建常见的ConversionService配置提供了便利。</p>
<h3 id="5-5-5-配置ConversionService"><a href="#5-5-5-配置ConversionService" class="headerlink" title="5.5.5 配置ConversionService"></a>5.5.5 配置ConversionService</h3><p>ConversionService是一个被设计成在应用程序启动时会进行实例化的无状态对象，随后可以在多个线程之间共享。在一个Spring应用程序中，你通常会为每一个Spring容器(或者应用程序上下文ApplicationContext)配置一个ConversionService实例，它会被Spring接收并在框架需要执行一个类型转换时使用。你也可以将这个ConversionService直接注入到你任何的Bean中并直接调用。</p>
<blockquote>
<p>如果Spring没有注册ConversionService，则会使用原始的基于PropertyEditor的系统。</p>
</blockquote>
<p>要向Spring注册默认的ConversionService，可以用<code>conversionService</code>作为id来添加如下的bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></div><div class="line">	<span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>/&gt;</div></pre></td></tr></table></figure>
<p>默认的ConversionService可以在字符串、数字、枚举、映射和其他常见类型之间进行转换。为了使用你自己的自定义转换器来补充或者覆盖默认的转换器，可以设置<code>converters</code>属性，该属性值可以是Converter、ConverterFactory或者GenericConverter之中任何一个的接口实现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></div><div class="line">		<span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.MyCustomConverter"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在一个Spring MVC应用程序中使用ConversionService也是比较常见的，可以去看Spring MVC章节的<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-config-conversion" target="_blank" rel="external">Section 18.16.3 “Conversion and Formatting”</a>。</p>
<p>在某些情况下，你可能希望在转换期间应用格式化，可以看<a href="#5.6.3 FormatterRegistry SPI">5.6.3 “FormatterRegistry SPI”</a>获取使用<code>FormattingConversionServiceFactoryBean</code>的细节。</p>
<h3 id="5-5-6-编程方式使用ConversionService"><a href="#5-5-6-编程方式使用ConversionService" class="headerlink" title="5.5.6 编程方式使用ConversionService"></a>5.5.6 编程方式使用ConversionService</h3><p>要以编程方式使用ConversionService，你只需要像处理其他bean一样注入一个引用即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(ConversionService conversionService)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.conversionService = conversionService;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.conversionService.convert(...)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对大多数用例来说，<code>convert</code>方法指定了可以使用的目标类型，但是它不适用于更复杂的类型比如参数化元素的集合。例如，如果你想要以编程方式将一个<code>Integer</code>的<code>List</code>转换成一个<code>String</code>的<code>List</code>，就需要为原类型和目标类型提供一个正式的定义。</p>
<p>幸运的是，<code>TypeDescriptor</code>提供了多种选项使事情变得简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DefaultConversionService cs = <span class="keyword">new</span> DefaultConversionService();</div><div class="line"></div><div class="line">List&lt;Integer&gt; input = ....</div><div class="line">cs.convert(input,</div><div class="line">	TypeDescriptor.forObject(input), <span class="comment">// List&lt;Integer&gt; type descriptor</span></div><div class="line">	TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));</div></pre></td></tr></table></figure>
<p>注意<code>DefaultConversionService</code>会自动注册对大部分环境都适用的转换器，这其中包括了集合转换器、标量转换器还有基本的<code>Object</code>到<code>String</code>的转换器。可以通过调用<code>DefaultConversionService</code>类上的静态方法<code>addDefaultConverters</code>来向任意的<code>ConverterRegistry</code>注册相同的转换器。</p>
<p>因为值类型的转换器可以被数组和集合重用，所以假设标准集合处理是恰当的，就没有必要创建将一个<code>S</code>的<code>Collection</code>转换成一个<code>T</code>的<code>Collection</code>的特定转换器。</p>
<h2 id="5-6-Spring字段格式化"><a href="#5-6-Spring字段格式化" class="headerlink" title="5.6 Spring字段格式化"></a>5.6 Spring字段格式化</h2><p>如上一节所述，<code>core.convert</code>包是一个通用类型转换系统，它提供了统一的ConversionService API以及强类型的Converter SPI用于实现将一种类型转换成另外一种的转换逻辑。Spring容器使用这个系统来绑定bean属性值，此外，Spring表达式语言(SpEL)和DataBinder也都使用这个系统来绑定字段值。举个例子，当SpEL需要将<code>Short</code>强制转换成<code>Long</code>来完成一次<code>expression.setValue(Object bean, Object value)</code>尝试时，core.convert系统就会执行这个强制转换。</p>
<p>现在让我们考虑一个典型的客户端环境如web或桌面应用程序的类型转换要求，在这样的环境里，你通常会经历将字符串进行转换以支持客户端回传的过程以及转换回字符串以支持视图渲染的过程。此外，你经常需要对字符串值进行本地化。更通用的<em>core.convert</em>包中的Converter SPI不直接解决这种格式化要求。Spring 3为此引入了一个方便的Formatter SPI来直接解决这些问题，这个接口为客户端环境提供一种简单强大并且替代PropertyEditor的方案。</p>
<p>一般来说，当你需要实现通用的类型转换逻辑时请使用Converter SPI，例如，在java.util.Date和java.lang.Long之间进行转换。当你在一个客户端环境(比如web应用程序)工作并且需要解析和打印本地化的字段值时，请使用Formatter SPI。ConversionService接口为这两者提供了一套统一的类型转换API。</p>
<h3 id="5-6-1-Formatter-SPI"><a href="#5-6-1-Formatter-SPI" class="headerlink" title="5.6.1 Formatter SPI"></a>5.6.1 Formatter SPI</h3><p>Formatter SPI实现字段格式化逻辑是简单并且强类型的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formatter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Formatter接口扩展了Printer和Parser这两个基础接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="function">String <span class="title">print</span><span class="params">(T fieldValue, Locale locale)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.text.ParseException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="function">T <span class="title">parse</span><span class="params">(String clientValue, Locale locale)</span> <span class="keyword">throws</span> ParseException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要创建你自己的格式化器，只需要实现上面的Formatter接口。泛型参数T代表你想要格式化的对象的类型，例如，<code>java.util.Date</code>。实现<code>print()</code>操作可以将类型T的实例按客户端区域设置的显示方式打印出来。实现<code>parse()</code>操作可以从依据客户端区域设置返回的格式化表示中解析出类型T的实例。如果解析尝试失败，你的格式化器应该抛出一个ParseException或者IllegalArgumentException。请注意确保你的格式化器实现是线程安全的。</p>
<p>为方便起见，<code>format</code>子包中已经提供了一些格式化器实现。<code>number</code>包提供了<code>NumberFormatter</code>、<code>CurrencyFormatter</code>和<code>PercentFormatter</code>，它们通过使用<code>java.text.NumberFormat</code>来格式化<code>java.lang.Number</code>对象 。<code>datetime</code>包提供了<code>DateFormatter</code>，其通过使用<code>java.text.DateFormat</code>来格式化<code>java.util.Date</code>。<code>datetime.joda</code>包基于<a href="http://www.joda.org/joda-time/" target="_blank" rel="external">Joda Time library</a>提供了全面的日期时间格式化支持。</p>
<p>考虑将<code>DateFormatter</code>作为<code>Formatter</code>实现的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format.datetime;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String pattern;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DateFormatter</span><span class="params">(String pattern)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.pattern = pattern;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">(Date date, Locale locale)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (date == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> getDateFormat(locale).format(date);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String formatted, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</div><div class="line">		<span class="keyword">if</span> (formatted.length() == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> getDateFormat(locale).parse(formatted);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">protected</span> DateFormat <span class="title">getDateFormat</span><span class="params">(Locale locale)</span> </span>&#123;</div><div class="line">		DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="keyword">this</span>.pattern, locale);</div><div class="line">		dateFormat.setLenient(<span class="keyword">false</span>);</div><div class="line">		<span class="keyword">return</span> dateFormat;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring团队欢迎社区驱动的<code>Formatter</code>贡献，可以登陆网站<a href="https://jira.spring.io/browse/SPR" target="_blank" rel="external">jira.spring.io</a>了解如何参与贡献。 </p>
<h3 id="5-6-2-注解驱动的格式化"><a href="#5-6-2-注解驱动的格式化" class="headerlink" title="5.6.2 注解驱动的格式化"></a>5.6.2 注解驱动的格式化</h3><p>如你所见，字段格式化可以通过字段类型或者注解进行配置，要将一个注解绑定到一个格式化器，可以实现AnnotationFormatterFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	Set&lt;Class&lt;?&gt;&gt; getFieldTypes();</div><div class="line"></div><div class="line">	Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);</div><div class="line"></div><div class="line">	Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>泛型参数A代表你想要关联格式化逻辑的字段注解类型，例如<code>org.springframework.format.annotation.DateTimeFormat</code>。让<code>getFieldTypes()</code>方法返回可能使用注解的字段类型，让<code>getPrinter()</code>方法返回一个可以打印被注解字段的值的打印机(Printer)，让<code>getParser()</code>方法返回一个可以解析被注解字段的客户端值的解析器(Parser)。</p>
<p>下面这个AnnotationFormatterFactory实现的示例把@NumberFormat注解绑定到一个格式化器，此注解允许指定数字样式或模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFormatAnnotationFormatterFactory</span></span></div><div class="line">		<span class="keyword">implements</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">NumberFormat</span>&gt; &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;(asList(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;</div><div class="line">			Short.class, Integer.class, Long.class, Float.class,</div><div class="line">			Double.class, BigDecimal.class, BigInteger.class &#125;));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Printer&lt;Number&gt; <span class="title">getPrinter</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Parser&lt;Number&gt; <span class="title">getParser</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> Formatter&lt;Number&gt; <span class="title">configureFormatterFrom</span><span class="params">(NumberFormat annotation,</span></span></div><div class="line">			Class&lt;?&gt; fieldType) &#123;</div><div class="line">		<span class="keyword">if</span> (!annotation.pattern().isEmpty()) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> NumberFormatter(annotation.pattern());</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			Style style = annotation.style();</div><div class="line">			<span class="keyword">if</span> (style == Style.PERCENT) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> PercentFormatter();</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (style == Style.CURRENCY) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> CurrencyFormatter();</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> NumberFormatter();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要触发格式化，只需要使用@NumberFormat对字段进行注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyModel</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@NumberFormat</span>(style=Style.CURRENCY)</div><div class="line">	<span class="keyword">private</span> BigDecimal decimal;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Format-Annotation-API"><a href="#Format-Annotation-API" class="headerlink" title="Format Annotation API"></a>Format Annotation API</h4><p><code>org.springframework.format.annotation</code>包中存在一套可移植(portable)的格式化注解API。请使用@NumberFormat格式化java.lang.Number字段，使用@DateTimeFormat格式化java.util.Date、java.util.Calendar、java.util.Long(注：此处可能是原文错误，应为java.lang.Long)或者Joda Time字段。</p>
<p>下面这个例子使用@DateTimeFormat将java.util.Date格式化为ISO时间(yyyy-MM-dd)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyModel</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@DateTimeFormat</span>(iso=ISO.DATE)</div><div class="line">	<span class="keyword">private</span> Date date;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><span id="5.6.3 FormatterRegistry SPI"></span></p>
<h3 id="5-6-3-FormatterRegistry-SPI"><a href="#5-6-3-FormatterRegistry-SPI" class="headerlink" title="5.6.3 FormatterRegistry SPI"></a>5.6.3 FormatterRegistry SPI</h3><p>FormatterRegistry是一个用于注册格式化器和转换器的服务提供接口(SPI)。<code>FormattingConversionService</code>是一个适用于大多数环境的FormatterRegistry实现，可以以编程方式或利用<code>FormattingConversionServiceFactoryBean</code>声明成Spring bean的方式来进行配置。由于它也实现了<code>ConversionService</code>，所以可以直接配置它与Spring的DataBinder以及Spring表达式语言(SpEL)一起使用。</p>
<p>请查看下面的FormatterRegistry SPI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistry</span> <span class="keyword">extends</span> <span class="title">ConverterRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Formatter&lt;?&gt; formatter)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFormatterForAnnotation</span><span class="params">(AnnotationFormatterFactory&lt;?, ?&gt; factory)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上所示，格式化器可以通过字段类型或者注解进行注册。</p>
<p>FormatterRegistry SPI允许你集中地配置格式化规则，而不是在你的控制器之间重复这样的配置。例如，你可能要强制所有的时间字段以某种方式被格式化，或者是带有特定注解的字段以某种方式被格式化。通过一个共享的FormatterRegistry，你可以只定义这些规则一次，而在需要格式化的时候应用它们。</p>
<h3 id="5-6-4-FormatterRegistrar-SPI"><a href="#5-6-4-FormatterRegistrar-SPI" class="headerlink" title="5.6.4 FormatterRegistrar SPI"></a>5.6.4 FormatterRegistrar SPI</h3><p>FormatterRegistrar是一个通过FormatterRegistry注册格式化器和转换器的服务提供接口(SPI)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistrar</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerFormatters</span><span class="params">(FormatterRegistry registry)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当要为一个给定的格式化类别(比如时间格式化)注册多个关联的转换器和格式化器时，FormatterRegistrar会非常有用。</p>
<p>下一部分提供了更多关于转换器和格式化器注册的信息。</p>
<h3 id="5-6-5-在Spring-MVC中配置格式化"><a href="#5-6-5-在Spring-MVC中配置格式化" class="headerlink" title="5.6.5 在Spring MVC中配置格式化"></a>5.6.5 在Spring MVC中配置格式化</h3><p>请查看Spring MVC章节的<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-config-conversion" target="_blank" rel="external">Section 18.16.3 “Conversion and Formatting”</a>。 </p>
<h2 id="5-7-配置一个全局的日期-amp-时间格式"><a href="#5-7-配置一个全局的日期-amp-时间格式" class="headerlink" title="5.7 配置一个全局的日期&amp;时间格式"></a>5.7 配置一个全局的日期&amp;时间格式</h2><p>默认情况下，未被<code>@DateTimeFormat</code>注解的日期和时间字段会使用<code>DateFormat.SHORT</code>风格从字符串转换。如果你愿意，你可以定义你自己的全局格式来改变这种默认行为。</p>
<p>你将需要确保Spring不会注册默认的格式化器，取而代之的是你应该手动注册所有的格式化器。请根据你是否依赖Joda Time库来确定是使用<code>org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</code>类还是<code>org.springframework.format.datetime.DateFormatterRegistrar</code>类。</p>
<p>例如，下面的Java配置会注册一个全局的’yyyyMMdd’格式，这个例子不依赖于Joda Time库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Bean</span></div><div class="line">	<span class="function"><span class="keyword">public</span> FormattingConversionService <span class="title">conversionService</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">// Use the DefaultFormattingConversionService but do not register defaults</span></div><div class="line">		DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">		<span class="comment">// Ensure @NumberFormat is still supported</span></div><div class="line">		conversionService.addFormatterForFieldAnnotation(<span class="keyword">new</span> NumberFormatAnnotationFormatterFactory());</div><div class="line"></div><div class="line">		<span class="comment">// Register date conversion with a specific global format</span></div><div class="line">		DateFormatterRegistrar registrar = <span class="keyword">new</span> DateFormatterRegistrar();</div><div class="line">		registrar.setFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">"yyyyMMdd"</span>));</div><div class="line">		registrar.registerFormatters(conversionService);</div><div class="line"></div><div class="line">		<span class="keyword">return</span> conversionService;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你更喜欢基于XML的配置，你可以使用一个<code>FormattingConversionServiceFactoryBean</code>，这是同一个例子，但这次使用了Joda Time：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">		http://www.springframework.org/schema/beans</div><div class="line">		http://www.springframework.org/schema/beans/spring-beans.xsd&gt;</div><div class="line"></div><div class="line">	&lt;bean id="<span class="attr">conversionService</span>" <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"registerDefaultFormatters"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"formatters"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.number.NumberFormatAnnotationFormatterFactory"</span> /&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"formatterRegistrars"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormatter"</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean"</span>&gt;</span></div><div class="line">							<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"yyyyMMdd"</span>/&gt;</span></div><div class="line">						<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">					<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Joda Time提供了不同的类型来表示<code>date</code>、<code>time</code>和<code>date-time</code>的值，<code>JodaTimeFormatterRegistrar</code>中的<code>dateFormatter</code>、<code>timeFormatter</code>和<code>dateTimeFormatter</code>属性应该为每种类型配置不同的格式。<code>DateTimeFormatterFactoryBean</code>提供了一种方便的方式来创建格式化器。</p>
</blockquote>
<p>如果你在使用Spring MVC，请记住要明确配置所使用的转换服务。针对基于<code>@Configuration</code>的Java配置方式这意味着要继承<code>WebMvcConfigurationSupport</code>并且覆盖<code>mvcConversionService()</code>方法。针对XML的方式，你应该使用<code>mvc:annotation-drive</code>元素的<code>&#39;conversion-service&#39;</code>属性。更多细节请看<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-config-conversion" target="_blank" rel="external">Section 18.16.3 “Conversion and Formatting”</a>。 </p>
<p><span id="5.8 Spring Validation"></span></p>
<h2 id="5-8-Spring验证"><a href="#5-8-Spring验证" class="headerlink" title="5.8 Spring验证"></a>5.8 Spring验证</h2><p>Spring  3对验证支持引入了几个增强功能。首先，现在全面支持JSR-303 Bean Validation API；其次，当采用编程方式时，Spring的DataBinder现在不仅可以绑定对象还能够验证它们；最后，Spring MVC现在已经支持声明式地验证<code>@Controller</code>的输入。</p>
<h3 id="5-8-1-JSR-303-Bean-Validation-API概述"><a href="#5-8-1-JSR-303-Bean-Validation-API概述" class="headerlink" title="5.8.1 JSR-303 Bean Validation API概述"></a>5.8.1 JSR-303 Bean Validation API概述</h3><p>JSR-303对Java平台的验证约束声明和元数据进行了标准化定义。使用此API，你可以用声明性的验证约束对领域模型的属性进行注解，并在运行时强制执行它们。现在已经有一些内置的约束供你使用，当然你也可以定义你自己的自定义约束。</p>
<p>为了说明这一点，考虑一个拥有两个属性的简单的PersonForm模型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonForm</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JSR-303允许你针对这些属性定义声明性的验证约束：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonForm</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@NotNull</span></div><div class="line">	<span class="meta">@Size</span>(max=<span class="number">64</span>)</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="meta">@Min</span>(<span class="number">0</span>)</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当此类的一个实例被实现JSR-303规范的验证器进行校验的时候，这些约束就会被强制执行。</p>
<p>有关JSR-303/JSR-349的一般信息，可以访问网站<a href="http://beanvalidation.org/" target="_blank" rel="external">Bean Validation website</a>去查看。有关默认参考实现的具体功能的信息，可以参考网站<a href="http://hibernate.org/validator/" target="_blank" rel="external">Hibernate Validator</a>的文档。想要了解如何将Bean验证器提供程序设置为Spring bean，请继续保持阅读。</p>
<h3 id="5-8-2-配置Bean验证器提供程序"><a href="#5-8-2-配置Bean验证器提供程序" class="headerlink" title="5.8.2 配置Bean验证器提供程序"></a>5.8.2 配置Bean验证器提供程序</h3><p>Spring提供了对Bean Validation API的全面支持，这包括将实现JSR-303/JSR-349规范的Bean验证提供程序引导为Spring Bean的方便支持。这样就允许在应用程序任何需要验证的地方注入<code>javax.validation.ValidatorFactory</code>或者<code>javax.validation.Validator</code>。</p>
<p>把<code>LocalValidatorFactoryBean</code>当作Spring bean来配置成默认的验证器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"validator"</span></span></div><div class="line">	<span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"</span>/&gt;</div></pre></td></tr></table></figure>
<p>以上的基本配置会触发Bean Validation使用它默认的引导机制来进行初始化。作为实现JSR-303/JSR-349规范的提供程序，如Hibernate Validator，可以存在于类路径以使它能被自动检测到。</p>
<h4 id="注入验证器"><a href="#注入验证器" class="headerlink" title="注入验证器"></a>注入验证器</h4><p><code>LocalValidatorFactoryBean</code>实现了<code>javax.validation.ValidatorFactory</code>和<code>javax.validation.Validator</code>这两个接口，以及Spring的<code>org.springframework.validation.Validator</code>接口，你可以将这些接口当中的任意一个注入到需要调用验证逻辑的Bean里。</p>
<p>如果你喜欢直接使用Bean Validtion API，那么就注入<code>javax.validation.Validator</code>的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.validation.Validator;</div><div class="line"></div><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="keyword">private</span> Validator validator;</div></pre></td></tr></table></figure>
<p>如果你的Bean需要Spring Validation API，那么就注入<code>org.springframework.validation.Validator</code>的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.validation.Validator;</div><div class="line"></div><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="keyword">private</span> Validator validator;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="配置自定义约束"><a href="#配置自定义约束" class="headerlink" title="配置自定义约束"></a>配置自定义约束</h4><p>每一个Bean验证约束由两部分组成，第一部分是声明了约束和其可配置属性的<code>@Constraint</code>注解，第二部分是实现约束行为的<code>javax.validation.ConstraintValidator</code>接口实现。为了将声明与实现关联起来，每个<code>@Constraint</code>注解会引用一个相应的验证约束的实现类。在运行期间，<code>ConstraintValidatorFactory</code>会在你的领域模型遇到约束注解的情况下实例化被引用到的实现。</p>
<p>默认情况下，<code>LocalValidatorFactoryBean</code>会配置一个<code>SpringConstraintValidatorFactory</code>，其使用Spring来创建约束验证器实例。这允许你的自定义约束验证器可以像其他Spring bean一样从依赖注入中受益。</p>
<p>下面显示了一个自定义的<code>@Constraint</code>声明的例子，紧跟着是一个关联的<code>ConstraintValidator</code>实现，其使用Spring进行依赖注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.FIELD&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Constraint</span>(validatedBy=MyConstraintValidator.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyConstraint &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span>;</div><div class="line">	<span class="keyword">private</span> Foo aDependency;</div><div class="line"></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所见，一个约束验证器实现可以像其他Spring bean一样使用@Autowired注解来自动装配它的依赖。</p>
<h4 id="Spring驱动的方法验证"><a href="#Spring驱动的方法验证" class="headerlink" title="Spring驱动的方法验证"></a>Spring驱动的方法验证</h4><p>被Bean Validation 1.1以及作为Hibernate Validator 4.3中的自定义扩展所支持的方法验证功能可以通过配置<code>MethodValidationPostProcessor</code>的bean定义集成到Spring的上下文中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.MethodValidationPostProcessor"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>为了符合Spring驱动的方法验证，需要对所有目标类用Spring的<code>@Validated</code>注解进行注解，且有选择地对其声明验证组，这样才可以使用。请查阅<code>MethodValidationPostProcessor</code>的java文档来了解针对Hibernate Validator和Bean Validation 1.1提供程序的设置细节。</p>
<h4 id="附加配置选项"><a href="#附加配置选项" class="headerlink" title="附加配置选项"></a>附加配置选项</h4><p>对于大多数情况，默认的<code>LocalValidatorFactoryBean</code>配置应该足够。有许多配置选项来处理从消息插补到遍历解析的各种Bean验证结构。请查看<code>LocalValidatorFactoryBean</code>的java文档来获取关于这些选项的更多信息。</p>
<p><span id="5.8.3 Configuring a DataBinder"></span></p>
<h3 id="5-8-3-配置DataBinder"><a href="#5-8-3-配置DataBinder" class="headerlink" title="5.8.3 配置DataBinder"></a>5.8.3 配置DataBinder</h3><p>从Spring 3开始，DataBinder的实例可以配置一个验证器。一旦配置完成，那么可以通过调用<code>binder.validate()</code>来调用验证器，任何的验证错误都会自动添加到DataBinder的绑定结果(BindingResult)。</p>
<p>当以编程方式处理DataBinder时，可以在绑定目标对象之后调用验证逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Foo target = <span class="keyword">new</span> Foo();</div><div class="line">DataBinder binder = <span class="keyword">new</span> DataBinder(target);</div><div class="line">binder.setValidator(<span class="keyword">new</span> FooValidator());</div><div class="line"></div><div class="line"><span class="comment">// bind to the target object</span></div><div class="line">binder.bind(propertyValues);</div><div class="line"></div><div class="line"><span class="comment">// validate the target object</span></div><div class="line">binder.validate();</div><div class="line"></div><div class="line"><span class="comment">// get BindingResult that includes any validation errors</span></div><div class="line">BindingResult results = binder.getBindingResult();</div></pre></td></tr></table></figure>
<p>通过<code>dataBinder.addValidators</code>和<code>dataBinder.replaceValidators</code>，一个DataBinder也可以配置多个<code>Validator</code>实例。当需要将全局配置的Bean验证与一个DataBinder实例上局部配置的Spring <code>Validator</code>结合时，这一点是非常有用的。</p>
<h3 id="5-8-4-Spring-MVC-3-验证"><a href="#5-8-4-Spring-MVC-3-验证" class="headerlink" title="5.8.4 Spring MVC 3 验证"></a>5.8.4 Spring MVC 3 验证</h3><p>请查看Spring MVC章节的<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-config-validation" target="_blank" rel="external">Section 18.16.4 “Validation”</a>。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发布于并发编程网，文章&lt;a href=&quot;http://ifeve.com/spring-5-validation/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-1-介绍&quot;&gt;&lt;a href=&quot;#5-1-介绍&quot; class=&quot;headerlink&quot; title=&quot;5.1 介绍&quot;&gt;&lt;/a&gt;5.1 介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;JSR-303/JSR-349 Bean Validation&lt;/p&gt;
&lt;p&gt;在设置支持方面，Spring Framework 4.0支持Bean Validation 1.0(JSR-303)和Bean Validation 1.1(JSR-349)，也将其改写成了Spring的&lt;code&gt;Validator&lt;/code&gt;接口。&lt;/p&gt;
&lt;p&gt;正如&lt;a href=&quot;#5.8 Spring Validation&quot;&gt;5.8 Spring验证&lt;/a&gt;所述，应用程序可以选择一次性全局启用Bean验证，并使其专门用于所有的验证需求。&lt;/p&gt;
&lt;p&gt;正如&lt;a href=&quot;#5.8.3 Configuring a DataBinder&quot;&gt;5.8.3 配置DataBinder&lt;/a&gt;所述，应用程序也可以为每个&lt;code&gt;DataBinder&lt;/code&gt;实例注册额外的Spring &lt;code&gt;Validator&lt;/code&gt;实例，这可能有助于不通过使用注解而插入验证逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://lukaicheng.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读总结--ArrayList</title>
    <link href="https://lukaicheng.github.io/2016/11/17/Reading-JDK-ArrayList/"/>
    <id>https://lukaicheng.github.io/2016/11/17/Reading-JDK-ArrayList/</id>
    <published>2016-11-17T07:26:10.000Z</published>
    <updated>2017-05-17T02:16:56.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure>
<p>ArrayList是List接口的一种可变长的数组实现，支持随机访问，它允许添加包括<strong>null</strong>在内的所有元素。另外，ArrayList的实现并不是线程安全的，如果有多个线程访问，且其中至少一个会涉及<strong>结构性修改</strong>，最好采用并发控制策略，或者采用<em>Collections.synchronizedList</em>进行包装，防止意外的非同步访问。以下所述基于JDK1.7.0_79源码。</p>
<a id="more"></a>
<h2 id="2-基本属性"><a href="#2-基本属性" class="headerlink" title="2 基本属性"></a>2 基本属性</h2><h3 id="2-1-elementData"><a href="#2-1-elementData" class="headerlink" title="2.1 elementData"></a>2.1 elementData</h3><p><strong>elementData</strong>属性是实际存储列表元素的数组缓存区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>
<p>尽管从声明上看它是数组类型，然而它的长度却并不固定，这里的意思并不说是可以在数组创建之后再改变它的大小，而是指当进行容量评估时，如果发现需要扩容或者收缩，那么会重新创建一个数组并伴随一次拷贝，然后将<strong>elementData</strong>指向新数组，从而达到扩容或者收缩的目的。</p>
<h3 id="2-2-size"><a href="#2-2-size" class="headerlink" title="2.2 size"></a>2.2 size</h3><p><strong>size</strong>属性就是列表实际所包含的元素个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>这是因为一般情况下，<strong>elementData</strong>数组并不会被完全占满，所以无法用数组长度等价于元素个数，而又需要有一种机制能够快速反馈元素个数，因此设置了<strong>size</strong>属性来缓存这个信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>size()</strong>方法和<strong>isEmpty()</strong>方法就是通过它才保证调用只需花费常数时间。</p>
<h2 id="3-容量调整"><a href="#3-容量调整" class="headerlink" title="3 容量调整"></a>3 容量调整</h2><h3 id="3-1-扩容"><a href="#3-1-扩容" class="headerlink" title="3.1 扩容"></a>3.1 扩容</h3><p>在新版本JDK中，ArrayList不仅像之前一样拥有私有的动态扩容方法，同时还对外提供了公有方法供调用者主动进行扩容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY,minCapacity);</div><div class="line">    &#125;</div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上所示，<strong>ensureCapacity()</strong>是供外部主动扩容调用的方法，<strong>ensureCapacityInternal()</strong>是供内部扩容调用的方法。这两个方法都是先预估出所需的最小容量，进而通过调用私有方法<strong>ensureExplicitCapacity()</strong>来保证这个容量需求得以满足。接下来看一下这个方法的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span>(minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//扩容到1.5倍</span></div><div class="line">    <span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span>(newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) <span class="comment">//overflow处理</span></div><div class="line">	    newCapacity = hugeCapacity(minCapacity);</div><div class="line">    elementData = Arrays.copyOf(elementData,newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(minCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? </div><div class="line">        Integer.MAX_VALUE : </div><div class="line">        MAX_ARRAY_SIZE; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ensureExplicitCapacity()</strong>方法会首先判定所需的最小容量是否超过当前数组长度，只有在肯定的情况下，才会调用<strong>grow()</strong>方法。观察此方法代码，首先默认将原先的数组长度扩充到1.5倍，接着将新容量与最小容量比较，如果发现新容量小于最小容量，那么将会把新容量赋值为最小容量。而后则是对容量扩充到1.5倍时可能发生的int值溢出的情况，进行一些处理。最后才是真正的进行新数组创建，旧数组元素拷贝的过程。</p>
<h3 id="3-2-收缩"><a href="#3-2-收缩" class="headerlink" title="3.2 收缩"></a>3.2 收缩</h3><p>由于列表在增加元素的时候会进行隐式扩容，从而导致底层数组容量往往超过实际所包含的元素，如果碰到资源敏感的场景下，那么可以使用<strong>trimToSize()</strong>方法进行收缩，使得底层数组容量和实际元素个数持平。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span></span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span>(size &lt; elementData.length)&#123;</div><div class="line">        elementData = Arrays.copyOf(elementData,size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-异常检测"><a href="#4-异常检测" class="headerlink" title="4 异常检测"></a>4 异常检测</h2><h3 id="4-1-rangeCheck"><a href="#4-1-rangeCheck" class="headerlink" title="4.1 rangeCheck"></a>4.1 rangeCheck</h3><p>针对索引范围的检查，ArrayList提供了两个版本的方法：<strong>rangeCheck()</strong>和<strong>rangeCheckForAdd()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index &gt;= size)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>rangeCheck()</strong>主要是针对<em>get()、set()、remove()</em>方法进行索引检测，注意到上面代码并没有对index为负的情况进行检测，这是因为紧跟本方法调用的是对底层数组的访问，而后者会直接检测索引为负的情况，但另外一方面由于隐式扩容的缘故，底层数组包含的实际元素个数往往小于数组长度，因此针对索引超出的情况只能在本方法里判定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>顾名思义，<strong>rangeCheckForAdd()</strong>方法在运行时会被<em>add()、addAll()</em>所调用。相比<strong>rangeCheck()</strong>方法，由于后续不是紧跟对底层数组的访问，因此增加了对于索引为负的情况的判定，同时因为允许元素可以末端添加，去掉了index = size这种情况。</p>
<h3 id="4-2-modCount"><a href="#4-2-modCount" class="headerlink" title="4.2 modCount"></a>4.2 modCount</h3><p><strong>modCount</strong>是ArrayList从父类AbstractList从继承过来的属性，这个属性用于记录列表经历的结构性修改的次数，主要被迭代器(<a href="#61-iterator">iterator</a>和<a href="#62-listiterator">listIterator</a>)使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>迭代器借助于它可以提供fast-fail行为，即当迭代器进行迭代时，如果检测它的值被意外修改，可以抛出ConcurrentModificationException异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount) <span class="comment">//与预期不符合，抛出异常</span></div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="5-增删改查"><a href="#5-增删改查" class="headerlink" title="5 增删改查"></a>5 增删改查</h2><h3 id="5-1-set-amp-get"><a href="#5-1-set-amp-get" class="headerlink" title="5.1 set &amp; get"></a>5.1 set &amp; get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>&#123;</div><div class="line">	rangeCheck(index);</div><div class="line">  	E oldValue = elementData(index);</div><div class="line">  	elementData[index] = element;</div><div class="line">  	<span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">  	rangeCheck(index);</div><div class="line">  	<span class="keyword">return</span> elementData(index);</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">  	reurn (E)elementData[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>众所周知，ArrayList的<strong>set()</strong>和<strong>get()</strong>方法均是常数消耗的操作，这是由于底层元素存储依赖于数组，因而在元素获取时可以直接利用数组随机访问的能力，这一点看上面的源码正好可以印证。</p>
<h3 id="5-2-add"><a href="#5-2-add" class="headerlink" title="5.2 add"></a>5.2 add</h3><p>在一般情况下，从算法分析的角度上说ArrayList的元素添加操作时间复杂度是O(n)，这是因为在当前元素添加元素，往往需要将原先在当前位置的元素以及后续元素，往后移动一位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;</div><div class="line">	rangeCheckForAdd(index);</div><div class="line">  	ensureCapacityInternal(size+<span class="number">1</span>);</div><div class="line">  	System.arraycopy(elementData,index,elementData,index+<span class="number">1</span>,size-index);</div><div class="line">  	elementData[index] = element;</div><div class="line">  	size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，针对只在末尾添加元素的场景，ArrayList做了特别处理，不需要移动元素位置，直接快速赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</div><div class="line">  	ensureCapacityInternal(size+<span class="number">1</span>);</div><div class="line">  	elementData[size++] = e;</div><div class="line">  	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是别忘记，不管是一般情况还是特殊情况，最开始都会进行容量检测，这里可能又是一次元素拷贝的开销，因此在容量预知的情况下，应该在ArrayList实例化的时候指定容量。</p>
<h3 id="5-3-remove"><a href="#5-3-remove" class="headerlink" title="5.3 remove"></a>5.3 remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">	rangeCheck(index);</div><div class="line">	modCount++;</div><div class="line">	E oldValue = elementData(index);<span class="comment">//elementData方法在5.1代码示例给出</span></div><div class="line">  	<span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;<span class="comment">//计算需要移动的元素个数</span></div><div class="line"> 	<span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)</div><div class="line">    	System.arraycopy(elementData,index+<span class="number">1</span>,elementData,index,numMoved);  </div><div class="line"> 	elementData[--size] = <span class="keyword">null</span>;<span class="comment">//实际元素个数-1且将原先末尾置空便于GC </span></div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同<strong>add()</strong>方法类似，<strong>remove()</strong>则是将被删除元素的后续元素前移了一位，达到删除元素的目的，可以看到，同样也是需要一次数组元素的拷贝。另外，还注意到modCount值发生了改变，这是因为<strong>remove()</strong>是一种结构性的修改。</p>
<h2 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="6 迭代器"></a>6 迭代器</h2><h3 id="6-1-iterator"><a href="#6-1-iterator" class="headerlink" title="6.1 iterator"></a><span id="61-iterator">6.1 iterator</span></h3><p>ArrayList声明了内部类<strong>Itr</strong>实现了Iterator接口,通过方法<strong>iterator()</strong>对外提供该迭代器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Itr</strong>在内部定义了三个属性：<strong>cursor</strong>用于表示下一个元素的索引，默认初始为0；<strong>lastRet</strong>用于表示上一个返回元素的索引，初始为-1；<strong>expectedModCount</strong>用于表示期望的修改次数，初始为迭代器实例化时外部列表的modCount值。对于<strong>hasNext()</strong>方法，只要判定<strong>cursor</strong>是否已经和当前列表的<strong>size</strong>相同，即可判定是否还存在下一个元素。对于<strong>next()</strong>方法，由于已经知道需要返回的元素的索引(cursor)，那么可以直接通过数组索引访问获取元素，当然对于索引的校验以及列表的结构修改检测也是必须的，且同时需要更新cursor和lastRet。下面主要详细看下<strong>remove()</strong>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">    checkForComodification();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);<span class="comment">//后续元素前移 &amp; modCount++</span></div><div class="line">        cursor = lastRet;<span class="comment">//元素前移，当前位置的元素的索引发生变化</span></div><div class="line">        lastRet = -<span class="number">1</span>;<span class="comment">//只有在next重新调用之后，才能再次调用remove</span></div><div class="line">        expectedModCount = modCount;<span class="comment">//由于modCount变化，需要重新赋值</span></div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Remove()</strong>方法首先对lastRet进行了检验，结合后续代码中对于lastRet赋值为-1的情况和<strong>next()</strong>方法实现情况，可以知道<strong>remove()</strong>方法只有在<strong>next()</strong>方法被调用一次才能调用并且不能连续连续调用<strong>remove()</strong>方法。接着是上面已经提过的modCount检测。然后才是真正的remove操作，它是通过调用外部对象的remove方法来实现移除最近返回的元素。但是这里要注意的是，调用这个方法，会有两个<strong>“副作用”</strong>：一，被移除元素的后续元素都会前移一位；二，modCount将会+1。因此在最后的代码中，才会看见cursor和expectedModCount被重新赋值，这实质上是为了抵消这两个副作用的影响。</p>
<h3 id="6-2-listIterator"><a href="#6-2-listIterator" class="headerlink" title="6.2 listIterator"></a><span id="62-listiterator">6.2 listIterator</span></h3><p>除了一般版本的迭代器，ArrayList还提供了listIterator，与一般版本相比，不仅可以往后进行迭代，还可以向前迭代。外部可以通过<strong>listIterator()</strong>方法获取该迭代器，该方法返回<strong>ListItr</strong>内部类的一个实例，<strong>ListItr</strong>继承关系如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ListItr</strong>继承了<strong>Itr</strong>，在<em>hasNext()、next()、remove()</em>这几个方法的实现上，并未改变其父类中的行为，仅仅是对<em>hasPrevious()、previous()、nextIndex()、previousIndex()、set()、add()</em>方法进行了实现。<strong>nextIndex()</strong>和<strong>previousIndex()</strong>两个方法都可以直接借助cursor属性进行返回。<strong>hasPrevious()</strong>方法同<strong>hasNext()</strong>实现类似，只不过这次是需要判定cursor是否同0相同,即可判断出是否还存在上一个元素。同样，对于<strong>previous()</strong>方法可参考<strong>next()</strong>，只不过需要返回的是数据中cursor-1位置的数据。<strong>set()</strong>方法则是简单的调用了外部列表的<strong>set()</strong>方法。最后主要来讲一下<strong>add()</strong>方法的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    checkForComodification();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = cursor;</div><div class="line">        ArrayList.<span class="keyword">this</span>.add(i, e);<span class="comment">//当前位置元素以及之后元素后移 &amp; modCount++</span></div><div class="line">        cursor = i + <span class="number">1</span>;<span class="comment">//重新赋值当前游标的值</span></div><div class="line">        lastRet = -<span class="number">1</span>;<span class="comment">//保证只有在next或者previous之后，才能重新调用set方法</span></div><div class="line">        expectedModCount = modCount;<span class="comment">//由于modCount变化，需要重新赋值</span></div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Add()</strong>方法首先照例进行列表结构性修改检测，接着实际上调用了外部ArrayList对象的add方法来进行元素添加，类似的，这个调用也会产生两个<strong>“副作用”</strong>：一、原有当前位置以及之后的元素被后移一位；二、modCount将会+1。因此，在后续代码中可以看到对cursor进行了+1操作，同时将新的modCount值赋予expectedModCount。</p>
<h2 id="7-子列表"><a href="#7-子列表" class="headerlink" title="7 子列表"></a>7 子列表</h2><p>ArrayList对外暴露了<strong>subList()</strong>方法来提供子列表的功能，但是子列表并不是重新创建的列表对象，它仅仅只是一个<em>视图</em>。<strong>SubList</strong>内部实际保存了父列表的对象引用，并定义了<strong>parentOffset</strong>和<strong>offset</strong>两个偏移量。其中<strong>parentOffset</strong>表示子列表相对于父列表的偏移量，<strong>offset</strong>表示子列表相对于根列表的偏移量。在实际调用时，子列表的<em>get()、set()</em>方法会通过使用<strong>offset</strong>来快速进行索引，而<em>add()、remove()</em>方法则会借助父对象引用和<strong>parentOffset</strong>来调用父类相应方法实现子列表的相应功能。</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/subList.png" alt="offset说明"></p>
<p>由于子列表和父列表实质上是共用同一份底层数据，那么对于子列表进行的元素添加、删除操作，父列表上也同样会得到体现，然而从反方向看却需要警惕，如果对父列表进行元素添加、删除等涉及结构性修改的操作，会导致已生成的子列表变成不可用(这是因为modCount机制导致)。</p>
<h2 id="8-序列化"><a href="#8-序列化" class="headerlink" title="8 序列化"></a>8 序列化</h2><p>从ArrayList的类声明中可以知道其实现了<strong>Serializable</strong>接口，能够序列化和反序列化，然而细心的可能已经发现<strong>elementData</strong>属性却是被transient修饰，但是实际序列化过程中，元素数据却并没有丢失。其实，这是因为<strong>elementData</strong>数组实际长度往往大于实际元素个数，如果直接采用默认序列化方式，那么其实除了会序列化实际元素之外，还会去序列化数组的剩余空间，并且在反序列化的时候会浪费额外空间来存储。所以，通过实现了<strong>writeObject()</strong>和<strong>readObject</strong>，ArrayList实现了自定义的序列化和反序列化过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">	<span class="keyword">throws</span> java.io.IOException&#123;</div><div class="line">        <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line">        s.defaultWriteObject();</div><div class="line">        s.writeInt(size);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">            s.writeObject(elementData[i]);<span class="comment">//根据实际size序列化数据</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></div><div class="line">	<span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</div><div class="line">        elementData = EMPTY_ELEMENTDATA;</div><div class="line">        s.defaultReadObject();</div><div class="line">        s.readInt();</div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</div><div class="line">            ensureCapacityInternal(size);</div><div class="line">            Object[] a = elementData;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">                a[i] = s.readObject();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从实际的源码不难看出，在实际序列化过程中，通过size来确定实际元素并逐个序列化，从而避免序列化不必要的元素，这不仅效率更高，且在反序列化重新构建ArrayList时可以给<strong>elementData</strong>设置合适的容量，避免空间浪费。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html" target="_blank" rel="external">ArrayList API</a></p>
<p><a href="http://stackoverflow.com/questions/38950203/why-does-arraylistrangecheck-not-check-if-the-index-is-negative" target="_blank" rel="external">why-does-arraylistrangecheck-not-check-if-the-index-is-negative</a></p>
<p><a href="http://stackoverflow.com/questions/9848129/why-does-arraylist-use-transient-storage" target="_blank" rel="external">why-does-arraylist-use-transient-storage</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;1 简介&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;RandomAccess&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Cloneable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ArrayList是List接口的一种可变长的数组实现，支持随机访问，它允许添加包括&lt;strong&gt;null&lt;/strong&gt;在内的所有元素。另外，ArrayList的实现并不是线程安全的，如果有多个线程访问，且其中至少一个会涉及&lt;strong&gt;结构性修改&lt;/strong&gt;，最好采用并发控制策略，或者采用&lt;em&gt;Collections.synchronizedList&lt;/em&gt;进行包装，防止意外的非同步访问。以下所述基于JDK1.7.0_79源码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java collections framework" scheme="https://lukaicheng.github.io/tags/Java-collections-framework/"/>
    
  </entry>
  
  <entry>
    <title>ABNF应知应会</title>
    <link href="https://lukaicheng.github.io/2016/11/02/ABNF/"/>
    <id>https://lukaicheng.github.io/2016/11/02/ABNF/</id>
    <published>2016-11-02T03:38:02.000Z</published>
    <updated>2017-05-17T02:16:43.999Z</updated>
    
    <content type="html"><![CDATA[<p>ABNF英文全称是Augmented Backus-Naur Form，这是一种基于BNF的元语言，在很多的Internet technical Specification中用于定义正式语法。</p>
<a id="more"></a>
<h2 id="1-规则定义"><a href="#1-规则定义" class="headerlink" title="1 规则定义"></a>1 规则定义</h2><h3 id="1-1-规则形式"><a href="#1-1-规则形式" class="headerlink" title="1.1 规则形式"></a>1.1 规则形式</h3><p>规则定义的形式如下所示</p>
<blockquote>
<p>name = elements crlf</p>
</blockquote>
<p>其中</p>
<ul>
<li>name 表示规则名称，对于它的解释可以参考<a href="#12-规则名称">1.2 规则名称</a>，</li>
<li>elements 可以是一个或者多个规则或者最终值的操作组合，关于最终值可以参考<a href="#13-最终值">1.3 最终值</a></li>
<li>crlf 行结束标志(回车换行)</li>
</ul>
<p>为了视觉效果，规则定义需要左对齐，如果碰上一个规则需要多行的情况，那么接下来的行需要缩进，而它们对齐和缩进的基准是ABNF规则的第一行。</p>
<h3 id="1-2-规则名称"><a href="#1-2-规则名称" class="headerlink" title="1.2 规则名称"></a><span id="12-规则名称">1.2 规则名称</span></h3><p>规则名称由字母开头，后续可以包含字母、数字和连字符(减号)组合的序列,其中需要注意的是规则名称<strong>不区分大小写</strong>。而且不像BNF，用尖括号(<strong>&lt;</strong>，<strong>&gt;</strong>)包围规则名称并不是必需的。</p>
<h3 id="1-3-最终值"><a href="#1-3-最终值" class="headerlink" title="1.3 最终值"></a><span id="13-最终值">1.3 最终值</span></h3><p>所有规则最终都会由最终值来解释，而所谓的最终值是由一个指定的基数再结合一个或者多个数值字符来指定。当前已经定义的基数有三种：</p>
<ul>
<li>b： 二进制 binary</li>
<li>d： 十进制 decimal</li>
<li>x： 十六进制 hexadecimal</li>
</ul>
<p>以回车CR为例，下面的规则分别采用十进制和十六进制为基数</p>
<blockquote>
<p>CR = %d13</p>
<p>CR = %x0D</p>
</blockquote>
<p>当碰到需要表示多个字符时，可以用<strong>“.”</strong>来进行串联</p>
<blockquote>
<p>false = %x66.61.6c.73.65</p>
</blockquote>
<p>同时ABNF也允许使用双引号来直接说明文字文本</p>
<blockquote>
<p>command = “pwd”</p>
</blockquote>
<p>但是需要注意的是，这里字符串是大小写不敏感，且使用的字符集是US-ASCII。因此上面的字符串会匹配”pwd”,”Pwd”,”pWd”,”pwD”,”PWd”,”pWD”,”PwD”和”PWD”。如果我们需要字符串具备大小写敏感特性，那么可以分别指定每个字符，有下面两种方式:</p>
<blockquote>
<p>command = %d112.119.100</p>
<p>command = %d112 %d119 %d109</p>
</blockquote>
<h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h2><h3 id="2-1-级联-R1-R2"><a href="#2-1-级联-R1-R2" class="headerlink" title="2.1 级联 R1 R2"></a>2.1 级联 R1 R2</h3><p>可以将已经定义的规则和最终值按顺序列出来，元素之间用空白字符来进行区分。</p>
<blockquote>
<p>foo = %x61</p>
<p>bar = %x62</p>
<p>mumble = foo bar foo</p>
</blockquote>
<p>在上面的示例里规则foo匹配a，bar匹配b，mumble将匹配aba。</p>
<h3 id="2-2-选择-R1-R2"><a href="#2-2-选择-R1-R2" class="headerlink" title="2.2 选择 R1 / R2"></a>2.2 选择 R1 / R2</h3><p>可以通过在规则之间插入/，让规则变成可选。</p>
<blockquote>
<p>ws = %x20 / %x09 / %x0A / %x0D</p>
</blockquote>
<p>在上面的示例里，规则ws会匹配空格、制表符、换行、回车。</p>
<h3 id="2-3-增量选择-R1-R2"><a href="#2-3-增量选择-R1-R2" class="headerlink" title="2.3 增量选择 R1 =/ R2"></a>2.3 增量选择 R1 =/ R2</h3><p>有时候，我们可能希望有一种增量的方式，可以在旧规则里添加新的功能可选项，这个时候增量选择就比较适用，它通过<strong>=/</strong>来将新规则变成旧规则的可选项之一。</p>
<blockquote>
<p>ruleset = alt1 / alt2</p>
<p>ruleset =/ alt3</p>
<p>ruleset =/ alt4 / alt5</p>
</blockquote>
<p>最终ruleset等价于下面所示：</p>
<blockquote>
<p>ruleset = alt1 / alt2 / alt3 / alt4 / alt5</p>
</blockquote>
<h3 id="2-4-值范围"><a href="#2-4-值范围" class="headerlink" title="2.4 值范围"></a>2.4 值范围</h3><p>通过使用连字符(-),ABNF还可以实现指定一个范围的值。</p>
<blockquote>
<p>DIGIT = %x30-39</p>
</blockquote>
<p>上面的示例规则，实际上等价于下面的规则</p>
<blockquote>
<p>DIGIT = “0” / “1” / “2” / “3” / “4” / “5” / “6” / “7” / “8” / “9”</p>
</blockquote>
<h3 id="2-5-序列组合-R1-R2"><a href="#2-5-序列组合-R1-R2" class="headerlink" title="2.5 序列组合 (R1 R2)"></a>2.5 序列组合 (R1 R2)</h3><p>用括号将连个规则包围起来，这样的组合会被当成单个元素，对于一些优先级比较容易混淆的情况尤其推荐使用它。</p>
<blockquote>
<p>group = elem (foo / bar) blat</p>
</blockquote>
<p>上面的示例会匹配 elem foo blat 或者 elem bar blat，但是如果我们不使用括号的话</p>
<blockquote>
<p>group = elem foo / bar blat</p>
</blockquote>
<p>由于操作符优先级的关系，其实group会匹配elem foo或bar blat。</p>
<h3 id="2-6-不定量重复-Rule"><a href="#2-6-不定量重复-Rule" class="headerlink" title="2.6 不定量重复 *Rule"></a>2.6 不定量重复 *Rule</h3><p>我们可以在规则的前面添加*，来表示重复这个规则，完整的形式是m*nRule。其中m和n都是可选的，m表示至少重复多少次，n表示最多重复多少次。两者默认的值分别是0和无穷大，所以*Rule表示允许任意次数的重复包括零次。1*Rule表示规则至少重复一次，1*2Rule表示规则重复一次或两次,3*3Rule表示规则必须且仅允许重复3次。</p>
<h3 id="2-7-定量重复-nRule"><a href="#2-7-定量重复-nRule" class="headerlink" title="2.7 定量重复 nRule"></a>2.7 定量重复 nRule</h3><p>除了不定量重复之外，ABNF也允许指定次数的重复，完整形式是nRule，其实等价于n*nRule。运用这个方式，2DIGIT就表示2位数字，3ALPHA表示长度为3的字符串。</p>
<h3 id="2-8-可选序列-Rule"><a href="#2-8-可选序列-Rule" class="headerlink" title="2.8 可选序列 [Rule]"></a>2.8 可选序列 [Rule]</h3><p>可以使用方括号来圈定一个可选序列</p>
<blockquote>
<p>rule = [foo bar]</p>
</blockquote>
<p>等价于</p>
<blockquote>
<p>rule = *1(foo bar)</p>
</blockquote>
<h3 id="2-9-注释"><a href="#2-9-注释" class="headerlink" title="2.9 注释"></a>2.9 注释</h3><p>对于规则的说明，也提供了注释方式，以分号<strong>;</strong>开始，并到此行的结束。</p>
<blockquote>
<p>false = %x66.61.6c.73.65   ; false</p>
</blockquote>
<h2 id="3-操作优先级"><a href="#3-操作优先级" class="headerlink" title="3.操作优先级"></a>3.操作优先级</h2><p>以下给出了从高(结合最紧密)到低(结合最松散)的优先级:</p>
<ol>
<li>规则名、最终值</li>
<li>注释</li>
<li>值范围</li>
<li>重复</li>
<li>序列组合、可选序列</li>
<li>级联</li>
<li>选择</li>
</ol>
<p>由于级联和选择混用时，往往会让人困惑，建议使用序列组合来消除歧义。</p>
<h2 id="4-核心规则"><a href="#4-核心规则" class="headerlink" title="4.核心规则"></a>4.核心规则</h2><table>
<thead>
<tr>
<th style="text-align:left">规则</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ALPHA</td>
<td style="text-align:left">%x41-5A / %x61-7A</td>
<td style="text-align:left">A-Z / a-z</td>
</tr>
<tr>
<td style="text-align:left">BIT</td>
<td style="text-align:left">“0” / “1”</td>
<td style="text-align:left">二进制字符</td>
</tr>
<tr>
<td style="text-align:left">CHAR</td>
<td style="text-align:left">%x01-7F</td>
<td style="text-align:left">任何7位的US-ASCII字符，不包括Nul(%x00)</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR</td>
<td style="text-align:left">%x21-7E</td>
<td style="text-align:left">可见(可打印)字符</td>
</tr>
<tr>
<td style="text-align:left">CR</td>
<td style="text-align:left">%x0D</td>
<td style="text-align:left">回车</td>
</tr>
<tr>
<td style="text-align:left">LF</td>
<td style="text-align:left">%x0A</td>
<td style="text-align:left">换行</td>
</tr>
<tr>
<td style="text-align:left">CRLF</td>
<td style="text-align:left">CR LF</td>
<td style="text-align:left">回车换行</td>
</tr>
<tr>
<td style="text-align:left">CTL</td>
<td style="text-align:left">%x00-1F / %x7F</td>
<td style="text-align:left">控制字符</td>
</tr>
<tr>
<td style="text-align:left">DIGIT</td>
<td style="text-align:left">%x30-39</td>
<td style="text-align:left">数字0-9</td>
</tr>
<tr>
<td style="text-align:left">DQUOTE</td>
<td style="text-align:left">%x22</td>
<td style="text-align:left">双引号</td>
</tr>
<tr>
<td style="text-align:left">HEXDIG</td>
<td style="text-align:left">DIGIT / “A” / “B” / “C” / “D” / “E” / “F”</td>
<td style="text-align:left">十六进制字符</td>
</tr>
<tr>
<td style="text-align:left">OCTET</td>
<td style="text-align:left">%x00-FF</td>
<td style="text-align:left">8位数据</td>
</tr>
<tr>
<td style="text-align:left">HTAB</td>
<td style="text-align:left">%x09</td>
<td style="text-align:left">横向制表符</td>
</tr>
<tr>
<td style="text-align:left">SP</td>
<td style="text-align:left">%x20</td>
<td style="text-align:left">空格</td>
</tr>
<tr>
<td style="text-align:left">WSP</td>
<td style="text-align:left">SP / HTAB</td>
<td style="text-align:left">空格或者横向制表符</td>
</tr>
<tr>
<td style="text-align:left">LWSP</td>
<td style="text-align:left">*(WSP / CRLF WSP)</td>
<td style="text-align:left">空白行(不要用于邮件头，另外在其他上下文中使用也需要小心)</td>
</tr>
</tbody>
</table>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://tools.ietf.org/html/rfc5234" target="_blank" rel="external">RFC 5234</a><br><a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%85%85%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F" target="_blank" rel="external">维基百科 扩充巴科斯范式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ABNF英文全称是Augmented Backus-Naur Form，这是一种基于BNF的元语言，在很多的Internet technical Specification中用于定义正式语法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RCFile文件格式下的Hive表bigint类型列值读取问题</title>
    <link href="https://lukaicheng.github.io/2016/10/25/Hive-VLong-to-Java-long/"/>
    <id>https://lukaicheng.github.io/2016/10/25/Hive-VLong-to-Java-long/</id>
    <published>2016-10-25T02:25:39.000Z</published>
    <updated>2017-05-17T02:16:30.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景缘起"><a href="#背景缘起" class="headerlink" title="背景缘起"></a>背景缘起</h2><p>目前在将hive部分列数据采集到hbase时，由于平台将原来hive表的文件格式从SequenceFile调整到RCFile，因此需要对原来的离线数据采集程序进行修改。然而在实际修改开发过程中，却碰到了程序读取hive列字段，值为乱码的问题。</p>
<a id="more"></a>
<h2 id="初步诊断"><a href="#初步诊断" class="headerlink" title="初步诊断"></a>初步诊断</h2><p>由于之前的文件格式是SequenceFile，不管列在hive中数据类型是什么，程序都可以以统一的读取String方式来读取。因此在变更为RCFile方式时，仅仅调整了输入部分，转换依然采用了Bytes.toString方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convertHiveBigint</span><span class="params">(BytesRefWritable brw)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    <span class="keyword">return</span> Bytes.toString(brw.getData(),brw.getStart(),brw.getLength());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是针对乱码的字段，查看了hive表对应列的数据类型，发现是Bigint，那么我想可能不仅仅需要调整输入，最终转换的地方也需要调整为Bytes.toLong。于是将代码修改如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">convertHiveBigint</span><span class="params">(BytesRefWritable brw)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    <span class="keyword">return</span> Bytes.toLong(brw.getData(),brw.getStart(),brw.getLength());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="奇怪的-118"><a href="#奇怪的-118" class="headerlink" title="奇怪的-118"></a>奇怪的-118</h2><p>就在我以为上面的修改可以奏效之时，实际运行时却抛出了鲜红的异常</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/exception.png" alt="异常信息"></p>
<p>从异常信息里不难看出，对于Java long来说，已经规定是需要8个字节，然而在上面代码里，最终转换时确变成了7个字节。为此，对程序进行了调试，将原始的brw.getData打印了出来</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/bytesarray.png" alt="原始字节数据"></p>
<p>结合调试得到的offset和length值，获知到程序真实运行时取值为 <strong>-118 1 58 92 103 58 -127</strong>，而我直接通过hive sql查询列原始值，并转换成字节数组为 <strong>0 0 1 58 92 103 58 -127</strong>。观察这两组数据不难发现，不同之处在于前者开头是-118，而后者是0 0。而再仔细观察上面的字节数组，会很惊讶的发现，好像每隔6位，就会出现-118。这个时候，我就猜测假如能够弄明白-118的来源，那么我们的问题有很大概率就可以解决了。</p>
<h2 id="无心插柳"><a href="#无心插柳" class="headerlink" title="无心插柳"></a>无心插柳</h2><p>正当我对这个问题陷入困顿的时候，无意间发现了下图的信息(莫非这个是hive序列化类(⊙o⊙)？)</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/hive.png" alt="hive信息"></p>
<p>于是，我马上翻开了这个类的源码，根据类上面的注释确认了该类确实能将hive column序列化为BytesRefArrayWritable。该类只有initialize和serialize这两个方法，针对序列化过程，不难猜到入口肯定是serialize这个方法，由于需要序列化的列类型是Bigint，因此判定进入如下分支:</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/serialize.png" alt="序列化"></p>
<p>进入此方法后，是一个switch case分支选择，根据bigint和long对应关系，判定进入如下case：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/caselong.png" alt="Long"></p>
<p>最终代码导航下去，你会发现实际的转换过程在方法<strong>LazyBinaryUtils.writeVLongToByteArray</strong>,这也解开了上面-118的问题,不过限于水平目前还不太理解这段代码的含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">writeVLongToByteArray</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">long</span> l)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (l &gt;= -<span class="number">112</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123;</div><div class="line">    bytes[offset] = (<span class="keyword">byte</span>) l;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> len = -<span class="number">112</span>;</div><div class="line">  <span class="keyword">if</span> (l &lt; <span class="number">0</span>) &#123;</div><div class="line">    l ^= -<span class="number">1L</span>; <span class="comment">// take one's complement'</span></div><div class="line">    len = -<span class="number">120</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> tmp = l;</div><div class="line">  <span class="keyword">while</span> (tmp != <span class="number">0</span>) &#123;</div><div class="line">    tmp = tmp &gt;&gt; <span class="number">8</span>;</div><div class="line">    len--;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  bytes[offset] = (<span class="keyword">byte</span>) len;</div><div class="line"></div><div class="line">  len = (len &lt; -<span class="number">120</span>) ? -(len + <span class="number">120</span>) : -(len + <span class="number">112</span>);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = len; idx != <span class="number">0</span>; idx--) &#123;</div><div class="line">    <span class="keyword">int</span> shiftbits = (idx - <span class="number">1</span>) * <span class="number">8</span>;</div><div class="line">    <span class="keyword">long</span> mask = <span class="number">0xFFL</span> &lt;&lt; shiftbits;</div><div class="line">    bytes[offset+<span class="number">1</span>-(idx - len)] = (<span class="keyword">byte</span>) ((l &amp; mask) &gt;&gt; shiftbits);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span> + len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>最后，LazyBinaryUtils不仅提供了VLong序列化成字节数组的过程，同时也提供反序列化的过程，实际程序中只需调用LazyBinaryUtils.readVLongFromByteArray方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">readVLongFromByteArray</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset)</span> </span>&#123;</div><div class="line">  <span class="keyword">byte</span> firstByte = bytes[offset++];</div><div class="line">  <span class="keyword">int</span> len = WritableUtils.decodeVIntSize(firstByte);</div><div class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> firstByte;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">long</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; len-<span class="number">1</span>; idx++) &#123;</div><div class="line">    <span class="keyword">byte</span> b = bytes[offset++];</div><div class="line">    i = i &lt;&lt; <span class="number">8</span>;</div><div class="line">    i = i | (b &amp; <span class="number">0xFF</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (WritableUtils.isNegativeVInt(firstByte) ? ~i : i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结扩展"><a href="#总结扩展" class="headerlink" title="总结扩展"></a>总结扩展</h2><p>序列化和反序列化是相对的，在不了解具体序列化规则的情况下，去进行反序列化，有时候可能碰到问题。而在这个场景里，hive在序列化bigint时，是按照不定长的VLONG形式进行转换，如果我们依然按照原先读取long类型方式，那么就会碰到问题，因此一定要选择对应的反序列化方式才能获取到正确的值。在以后碰到hive不同列类型转换成Java中的类型时，可以参考LazyBinarySerDe.serialize对应类型的序列化方式，来寻找API中对应的反序列化方式，抑或自己动手造轮子。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景缘起&quot;&gt;&lt;a href=&quot;#背景缘起&quot; class=&quot;headerlink&quot; title=&quot;背景缘起&quot;&gt;&lt;/a&gt;背景缘起&lt;/h2&gt;&lt;p&gt;目前在将hive部分列数据采集到hbase时，由于平台将原来hive表的文件格式从SequenceFile调整到RCFile，因此需要对原来的离线数据采集程序进行修改。然而在实际修改开发过程中，却碰到了程序读取hive列字段，值为乱码的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RCFile" scheme="https://lukaicheng.github.io/tags/RCFile/"/>
    
      <category term="Hive" scheme="https://lukaicheng.github.io/tags/Hive/"/>
    
  </entry>
  
</feed>
