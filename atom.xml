<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>羽逝神伤</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lukaicheng.github.io/"/>
  <updated>2017-06-15T06:20:46.015Z</updated>
  <id>https://lukaicheng.github.io/</id>
  
  <author>
    <name>Lucifer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于标签的人群统计实现分析</title>
    <link href="https://lukaicheng.github.io/2017/06/09/TagBasedStatistics/"/>
    <id>https://lukaicheng.github.io/2017/06/09/TagBasedStatistics/</id>
    <published>2017-06-09T12:15:41.000Z</published>
    <updated>2017-06-15T06:20:46.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>最近在做项目过程中，碰到了这样一个需求：当前台页面勾选偏好标签的时候，后端服务需要快速给出标签对应的人群数量。如果仅仅只是单个标签的话，那么问题是非常简单的，然而现实是残酷的，我必须考虑基于多个标签勾选的交并集统计情况。</p>
<p>在此，先做一个假设，每个标签后面对应的人群数量是一百万，当然有可能人群会有重叠，而后续的讨论都是基于此数量级展开。</p>
<a id="more"></a>
<h2 id="初始想法"><a href="#初始想法" class="headerlink" title="初始想法"></a>初始想法</h2><p>考虑到在实际业务场景中用户标识是手机号码，这是一个数字，而且每个用户之间互不相同，为了尽可能满足快速响应以及节省空间的原则，我首先想到了利用<strong>位图</strong>的思想来实现这个需求。在Java中就提供了这样一个类来实现位图操作，它就是<strong>BitSet</strong>，下面是简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitSetDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        BitSet bs1 = <span class="keyword">new</span> BitSet();</div><div class="line">        bs1.set(<span class="number">14</span>);</div><div class="line">        bs1.set(<span class="number">20</span>);</div><div class="line">        bs1.set(<span class="number">43</span>);</div><div class="line">        <span class="comment">//输出bs1中设置为true的位数</span></div><div class="line">        System.out.println(bs1.cardinality());</div><div class="line">        BitSet bs2 = <span class="keyword">new</span> BitSet();</div><div class="line">        bs2.set(<span class="number">7</span>);</div><div class="line">        bs2.set(<span class="number">20</span>);</div><div class="line">        bs2.set(<span class="number">33</span>);</div><div class="line">        bs2.set(<span class="number">45</span>);</div><div class="line">        <span class="comment">//输出bs2中设置为true的位数</span></div><div class="line">        System.out.println(bs2.cardinality());</div><div class="line">        <span class="comment">//bs1和bs2进行交集操作</span></div><div class="line">        bs1.and(bs2);</div><div class="line">        <span class="comment">//输出bs1和bs2进行交集操作之后设置为true的位数</span></div><div class="line">        System.out.println(bs1.cardinality());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BitSet可以通过设置具体索引位的值为true来代表存在此数字，而且它还提供了基于位的交、并、差等操作(需要值得注意的是<strong>这些操作会对原有位图进行修改</strong>)。</p>
<p>映射到实际的业务问题，如果把用户标识(将手机号码看成数字)对应的位设置成true来代表存在此用户，那么似乎可以通过操作不同标签对应的位图，从而实现所期望的功能。然而这里还遗漏了一个问题，那就是位图持久化。</p>
<h2 id="Redis-bitmap"><a href="#Redis-bitmap" class="headerlink" title="Redis bitmap"></a>Redis bitmap</h2><p>正当我苦恼持久化的问题时，无意中翻到Redis居然提供了类似位图操作的命令：<strong>SETBIT</strong>、<strong>BITCOUNT</strong>、<strong>BITOP</strong>， 而且它还提供了RDB和AOF两种持久化机制，另外由于Redis是内存数据库，在命令响应方面也是非常迅速，可以说非常符合我这个问题的场景。</p>
<p>不过，当真正用Redis去实现的时候，又碰到了之前忽视的一个细节：手机号是11号数字，超过了Redis位图所能表示的范围，这一点在<strong>SETBIT</strong>命令的文档中有如下说明：</p>
<blockquote>
<p>The <em>offset</em> argument is required to be greater than or equal to 0, and smaller than 2^32 (this limits bitmaps to 512MB)</p>
</blockquote>
<p>为了解决这个细节问题，我想出了一个方案：将手机号前两位作为key的一部分，剩下的9位作为值插入到位图里面，由于手机号第一位是1，那么实际上一个标签最多需要10个位图来表示。为了避免用<strong>KEYS</strong>命令扫描获取某个标签所有的key，可以把这些key放到Redis Set中，每次可以先使用<strong>SMEMEBERS</strong>命令获取到所有key。</p>
<h2 id="Bitmap-VS-Set"><a href="#Bitmap-VS-Set" class="headerlink" title="Bitmap VS Set"></a>Bitmap VS Set</h2><p>在给他人讲述了我的方案之后，由于此设计在实现上确实有些繁琐复杂，有人提出是否考虑直接使用Set来存储所有的用户号码(他用两个百万随机用户号码的Set做交并操作，效率可以接受)。</p>
<p>于是，我开始对Set方案进行验证，除了处理速度之外，主要关注容量消耗，最终经过测试发现，一百万随机手机号码用Redis Set存储会消耗大概<strong>90MB</strong>内存。回过头来，分析我的Bitmap方案，如果要表达9位数字，那么需要2^30，即128MB(实际测试下来发现也大致符合这个值)，而一个标签最多需要分10个key，所以最大占据<strong>1280MB</strong>。 </p>
<p>诚然Set方案会随着标签下用户群的数量增加容量会随之增加，Bitmap方案的容量较为恒定，然而在这个场景下(最开始假设了一百万的量级，真实场景也大致如此甚至更少)，确实是采用Set会优于Bitmap。</p>
<h2 id="Cluster-amp-hash-tags"><a href="#Cluster-amp-hash-tags" class="headerlink" title="Cluster &amp; hash tags"></a>Cluster &amp; hash tags</h2><p>尽管决定采用Set方案，在实际编码以及调试过程中，又碰到了Redis的一个限制：如果Redis是采用集群方式部署，假设Set对应的key不属于同个节点，那么就无法透明的支持Set的交并操作。</p>
<p>引用自Redis Cluster规范：</p>
<blockquote>
<p>Redis Cluster implements all the single key commands available in the non-distributed version of Redis. Commands performing complex multi-key operations like Set type unions or intersections are implemented as well as long as the keys all belong to the same node.</p>
</blockquote>
<p>这样一来，就需要通过调用者来处理不同标签对应的key分配在不同节点的情况，每次进行多个标签交并操作时，首先需要从多个节点获取到对应标签的用户集合，然后在调用者的程序当中进行实际的集合交并，这样一来会大大增加网络传输量。</p>
<p>幸运的是，Redis提供了一种技巧，可以强制让多个key分配到相同的节点，这种技巧叫做<strong>hash tags</strong>。众所周知，Redis在执行key有关的命令前，先会计算key所对应的slot，不同的key由于计算出来的slot不同，往往就会位于不同的节点。而这个计算有一个短路的地方，假设碰到一个key包含<strong>“{“</strong>和<strong>“}”</strong>，那么只会使用花括号内的子字符串(<em>第一个花括号内的字符串</em>)进行slot的计算，这意味着{foo}bar1和{foo}bar2将会位于同一个节点。想要对这个概念有更详细的了解，可以查看<a href="https://redis.io/topics/cluster-spec#keys-hash-tags" target="_blank" rel="external">Keys hash tags</a>。 </p>
<p>考虑到可能出现的数据倾斜问题，我们可以将同一大类的标签都指派到相同节点，不同大类的标签指派到不同节点。由于交并操作符合交换律和结合律，那么可以优先计算出相同大类的交并集合，最终通过程序汇总，计算出不同大类的交并集合。这样一来，在考虑数据平衡的情况下，也相应减少网络传输。</p>
<h2 id="打破原有思维"><a href="#打破原有思维" class="headerlink" title="打破原有思维"></a>打破原有思维</h2><p>到此为止，这似乎是比较可取的方案了，然而当我跳出目前的思路，再重新去回顾整个问题的时候，猛然有一个念头在我脑海里闪过：一定要用手机号对应的数字来设置位图值吗？意识到这一点，我想到整个问题可以从一个新的角度来解决。</p>
<p>最开始想到采用手机号对应的数字来设置位图信息，是因为在整个系统里手机号可以唯一标识一个用户，然而对此问题而言，本质是关注具体标签下包含哪些用户，至于这些用户是如何确定唯一的，其实并不重要。那么，其实我可以预先做一个映射，将系统中所有的用户号码和一个自增序列进行映射，由于整个系统用户量仅仅只有千万级(且离亿级差距较大)，那么自增序列最大值不会超过100000000(其小于2^27，2^27 bit = 2^3 <em> 2^10 </em> 2^10 <em> 2^4 = 16MB)。如此一来，通过手机号码对应的自增序列数字设置redis位图值，一个key对应的位图就可以存储一个标签所包含的所有用户，且容量仅<em>*16MB</em></em>左右，即使标签下用户量从百万级增长到千万级，容量也是恒定的。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>通过对整个问题持续的思考、同其他人的交流以及自我反思，让我更加深刻意识到分析问题要综合考虑项目实际情况、业务细节以及技术限制，任何好的方案都是通过不断权衡和取舍而做出的选择，这个世界上没有银弹。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://redis.io/commands/setbit" target="_blank" rel="external">Redis SETBIT 命令</a></p>
<p><a href="https://redis.io/commands/bitcount" target="_blank" rel="external">Redis BITCOUNT 命令</a></p>
<p><a href="https://redis.io/commands/bitop" target="_blank" rel="external">Redis BITOP 命令</a></p>
<p><a href="https://redis.io/topics/cluster-spec#keys-hash-tags" target="_blank" rel="external">Redis hash tags</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;最近在做项目过程中，碰到了这样一个需求：当前台页面勾选偏好标签的时候，后端服务需要快速给出标签对应的人群数量。如果仅仅只是单个标签的话，那么问题是非常简单的，然而现实是残酷的，我必须考虑基于多个标签勾选的交并集统计情况。&lt;/p&gt;
&lt;p&gt;在此，先做一个假设，每个标签后面对应的人群数量是一百万，当然有可能人群会有重叠，而后续的讨论都是基于此数量级展开。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://lukaicheng.github.io/tags/Redis/"/>
    
      <category term="BitSet" scheme="https://lukaicheng.github.io/tags/BitSet/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础 - BeanPostProcessor</title>
    <link href="https://lukaicheng.github.io/2017/05/15/Spring-BeanPostProcessor/"/>
    <id>https://lukaicheng.github.io/2017/05/15/Spring-BeanPostProcessor/</id>
    <published>2017-05-15T12:40:40.000Z</published>
    <updated>2017-05-17T02:17:29.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h1><p><strong>BeanPostProcessor</strong>是Spring提供的一个钩子(<em>Hook</em>)接口，可用于实现对新的bean实例进行自定义修改，比如说，检测bean是否实现了某些特定接口从而可以对其进行进一步操作，或者可以将原实例进行包装而实际返回代理对象。其内部主要声明了<em>postProcessBeforeInitialization</em>和<em>postProcessAfterInitialization</em>两个回调方法，具体的接口声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line">  	<span class="comment">//在bean进行初始化行为之前被调用</span></div><div class="line">	<span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">  	<span class="comment">//在bean进行初始化行为之后被调用</span></div><div class="line">	<span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是这里所说的bean初始化行为主要是指调用<strong>InitializingBean</strong>的<em>afterPropertiesSet</em>或者一个自定义的<em>init-method</em>。</p>
<a id="more"></a>
<h1 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h1><p>根据Spring提供的文档注释，不难获知<strong>BeanPostProcessor</strong>提供的两个方法会分别在bean进行初始化的前后被触发调用。抱着好奇心，也是为了更深入的理解，我通过IDE查看这两个方法的调用链，然后发现原来抽象类<strong>AbstractAutowireCapableBeanFactory</strong>的<em>initializeBean</em>方法会间接调用这两者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</div><div class="line">		AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				invokeAwareMethods(beanName, bean);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;, getAccessControlContext());</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		invokeAwareMethods(beanName, bean);</div><div class="line">	&#125;</div><div class="line">	Object wrappedBean = bean;</div><div class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</div><div class="line">		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		invokeInitMethods(beanName, wrappedBean, mbd);</div><div class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</div><div class="line">          (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</div><div class="line">          	beanName, <span class="string">"Invocation of init method failed"</span>, ex);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</div><div class="line">    	wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> wrappedBean;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法<em>applyBeanPostProcessorsBeforeInitialization</em>和<em>applyBeanPostProcessorsAfterInitialization</em>最终会分别调用已经注册的<strong>BeanPostProcessor</strong>的这两个方法，而且是在方法<em>invokeInitMethods</em>调用的前后。而方法<em>invokeInitMethods</em>实质就是对bean进行判定，来确定是否可以转换成<strong>InitializingBean</strong>进而调用接口方法<em>afterPropertiesSet</em>或者是否存在自定义的<em>init-method</em>进行调用。 </p>
<h1 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h1><p>通过<strong>ApplicationContext</strong>和<strong>BeanFactory</strong>进行注册的方式稍微有些不同。对于<strong>ApplicationContext</strong>来说，只要定义在其配置文件里(或注解方式)，它就会自动检测到<strong>BeanPostProcessor</strong>实现类 ，并将其注册；对于普通的<strong>BeanFactory</strong>来说，那么就需要显式以编程方式来调用方法<em>addBeanPostProcessor</em>进行注册。</p>
<p>假设项目开启了注解扫描，那么只需加上注解，就能实现<strong>ApplicationContext</strong>方式的自动注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out.println(<span class="string">"Enter MyBeanPostProcessor postProcessBeforeInitialization"</span>);</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out.println(<span class="string">"Enter MyBeanPostProcessor postProcessAfterInitialization"</span>);</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h1><p>在实际项目中，我们可能需要注册不止一个<strong>BeanPostProcessor</strong>的实现类，而不管是采用<strong>BeanFactory</strong>还是<strong>ApplicationContext</strong>，实际调用顺序都是取决于注册顺序。由于<strong>BeanFactory</strong>是显式编程方式调用，因此可以人为决定注册顺序；而采用<strong>ApplicationContext</strong>的自动检测方式，其注册顺序由以下的规则确定：</p>
<ol>
<li>首先调用实现了<strong>PriorityOrdered</strong>接口的<strong>BeanPostProcessor</strong>实现类，如果不止一个类实现了<strong>PriorityOrdered</strong>接口，那么会按照方法<em>getOrder</em>返回的值的大小，越大就会优先调用。</li>
<li>接着调用实现了<strong>Ordered</strong>接口的<strong>BeanPostProcessor</strong>实现类，如果不止一个类实现了<strong>Ordered</strong>接口，那么会按照<em>getOrder</em>返回的值的大小，值越大就会优先调用。</li>
<li>然后调用既没有实现<strong>PriorityOrdered</strong>也没有实现<strong>Ordered</strong>的<strong>BeanPostProcessor</strong>实现类，这个调用顺序往往是无序的，因为由于没有在注册之前进行排序操作。</li>
<li>最后是调用实现<strong>MergedBeanDefinitionPostProcessor</strong>(通常供框架内部使用)的实现类。</li>
</ol>
<p>感兴趣的话，可以看一下<strong>PostProcessorRegistrationDelegate</strong>的<em>registerBeanPostProcessors</em>方法，其内部实现了对<strong>BeanPostProcessor</strong>的注册(这也是<strong>AbstractApplicationContext</strong>的<em>refresh</em>过程之一)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></div><div class="line">		ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</div><div class="line"></div><div class="line">	String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></div><div class="line">	<span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></div><div class="line">	<span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></div><div class="line">	<span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</div><div class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</div><div class="line"></div><div class="line">	<span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></div><div class="line">	<span class="comment">// Ordered, and the rest.</span></div><div class="line">	List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</div><div class="line">	List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</div><div class="line">	List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</div><div class="line">		<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</div><div class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">			priorityOrderedPostProcessors.add(pp);</div><div class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">				internalPostProcessors.add(pp);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</div><div class="line">			orderedPostProcessorNames.add(ppName);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			nonOrderedPostProcessorNames.add(ppName);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></div><div class="line">	sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</div><div class="line">	registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</div><div class="line"></div><div class="line">	<span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></div><div class="line">	List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</div><div class="line">	<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</div><div class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">		orderedPostProcessors.add(pp);</div><div class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">			internalPostProcessors.add(pp);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	sortPostProcessors(beanFactory, orderedPostProcessors);</div><div class="line">	registerBeanPostProcessors(beanFactory, orderedPostProcessors);</div><div class="line"></div><div class="line">	<span class="comment">// Now, register all regular BeanPostProcessors.</span></div><div class="line">	List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</div><div class="line">	<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</div><div class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">		nonOrderedPostProcessors.add(pp);</div><div class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">			internalPostProcessors.add(pp);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</div><div class="line"></div><div class="line">	<span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></div><div class="line">	sortPostProcessors(beanFactory, internalPostProcessors);</div><div class="line">	registerBeanPostProcessors(beanFactory, internalPostProcessors);</div><div class="line"></div><div class="line">	<span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></div><div class="line">	<span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></div><div class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="简单实践"><a href="#简单实践" class="headerlink" title="简单实践"></a>简单实践</h1><p>现在考虑项目中有这样一个配置，它通过读取配置文件<strong>app.properties</strong>，可以设置规则属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:app.properties"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;app.rule&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String rule;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRule</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> rule;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们需要对设置的规则进行校验，可以通过实现自定义的<strong>BeanPostProcessor</strong>来解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleNameBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; rules = Arrays.asList(<span class="string">"ruleA"</span>, <span class="string">"ruleB"</span>, <span class="string">"ruleC"</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MyConfig) &#123;</div><div class="line">            MyConfig config = (MyConfig) bean;</div><div class="line">            <span class="keyword">if</span> (!rules.contains(config.getRule())) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Invalid rule"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们在<strong>app.properties</strong>文件中配置了预定义规则之外的规则，那么程序在启动的时候就会抛出异常</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/BeanInitializationException.png" alt="异常信息"></p>
<p>通过启动阶段的检测机制，我们能够快速发现可能存在的问题，从而避免在程序运行期间发现错误。当然<strong>BeanPostProcessor</strong>在实际项目中肯定可以发挥更多的作用，这有待于我们进一步去挖掘。另外，如果对于Spring源码感兴趣的话，这个接口以及框架内部已有的实现类也是我们必须要了解的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html" target="_blank" rel="external">BeanPostProcessor javadoc</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;接口简介&quot;&gt;&lt;a href=&quot;#接口简介&quot; class=&quot;headerlink&quot; title=&quot;接口简介&quot;&gt;&lt;/a&gt;接口简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;BeanPostProcessor&lt;/strong&gt;是Spring提供的一个钩子(&lt;em&gt;Hook&lt;/em&gt;)接口，可用于实现对新的bean实例进行自定义修改，比如说，检测bean是否实现了某些特定接口从而可以对其进行进一步操作，或者可以将原实例进行包装而实际返回代理对象。其内部主要声明了&lt;em&gt;postProcessBeforeInitialization&lt;/em&gt;和&lt;em&gt;postProcessAfterInitialization&lt;/em&gt;两个回调方法，具体的接口声明如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BeanPostProcessor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  	&lt;span class=&quot;comment&quot;&gt;//在bean进行初始化行为之前被调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;Object &lt;span class=&quot;title&quot;&gt;postProcessBeforeInitialization&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  	&lt;span class=&quot;comment&quot;&gt;//在bean进行初始化行为之后被调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;Object &lt;span class=&quot;title&quot;&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是这里所说的bean初始化行为主要是指调用&lt;strong&gt;InitializingBean&lt;/strong&gt;的&lt;em&gt;afterPropertiesSet&lt;/em&gt;或者一个自定义的&lt;em&gt;init-method&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://lukaicheng.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 5 验证、数据绑定和类型转换[译]</title>
    <link href="https://lukaicheng.github.io/2017/05/13/Spring5-validation-translate/"/>
    <id>https://lukaicheng.github.io/2017/05/13/Spring5-validation-translate/</id>
    <published>2017-05-13T13:15:12.000Z</published>
    <updated>2017-05-17T02:17:46.288Z</updated>
    
    <content type="html"><![CDATA[<p>发布于并发编程网，文章<a href="http://ifeve.com/spring-5-validation/" target="_blank" rel="external">链接</a></p>
<h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><blockquote>
<p>JSR-303/JSR-349 Bean Validation</p>
<p>在设置支持方面，Spring Framework 4.0支持Bean Validation 1.0(JSR-303)和Bean Validation 1.1(JSR-349)，也将其改写成了Spring的<strong><code>Validator</code></strong>接口。</p>
<p>正如<a href="#5.8 Spring Validation">5.8 Spring验证</a>所述，应用程序可以选择一次性全局启用Bean验证，并使其专门用于所有的验证需求。</p>
<p>正如<a href="#5.8.3 Configuring a DataBinder">5.8.3 配置DataBinder</a>所述，应用程序也可以为每个<strong><code>DataBinder</code></strong>实例注册额外的Spring <strong><code>Validator</code></strong>实例，这可能有助于不通过使用注解而插入验证逻辑。</p>
</blockquote>
<a id="more"></a>
<p>考虑将验证作为业务逻辑是有利有弊的，Spring提供了一种不排除利弊的用于验证(和数据绑定)的设计。具体的验证不应该捆绑在web层，应该容易本地化并且它应该能够插入任何可用的验证器。考虑到以上这些，Spring想出了一个<strong><code>Validator</code></strong>接口，它在应用程序的每一层基本都是可用的。数据绑定对于将用户输入动态绑定到应用程序的领域模型上(或者任何你用于处理用户输入的对象)是非常有用的。Spring提供了所谓的<strong><code>DataBinder</code></strong>来处理这个。<strong><code>Validator</code></strong>和<strong><code>DataBinder</code></strong>组成了<strong><code>validation</code></strong>包，其主要用于但并不局限于MVC框架。</p>
<p><strong><code>BeanWrapper</code></strong>是Spring框架中的一个基本概念且在很多地方使用。然而，你可能并不需要直接使用<strong><code>BeanWrapper</code></strong>。尽管这是参考文档，我们仍然觉得有一些说明需要一步步来。我们将会在本章中解释<strong><code>BeanWrapper</code></strong>，因为你极有可能会在尝试将数据绑定到对象的时候使用它。</p>
<p>Spring的DataBinder和底层的BeanWrapper都使用PropertyEditor来解析和格式化属性值。<strong><code>PropertyEditor</code></strong>概念是JavaBeans规范的一部分，并会在本章进行说明。Spring 3不仅引入了”core.convert”包来提供一套通用类型转换工具，还有一个高层次的”format”包用于格式化UI字段值。可以将这些新包视作更简单的PropertyEditor替代方式来使用，本章还会对此进行讨论。</p>
<h2 id="5-2-使用Spring的验证器接口进行验证"><a href="#5-2-使用Spring的验证器接口进行验证" class="headerlink" title="5.2 使用Spring的验证器接口进行验证"></a>5.2 使用Spring的验证器接口进行验证</h2><p>Spring具有一个<strong><code>Validator</code></strong>接口可以让你用于验证对象。<strong><code>Validator</code></strong>接口在工作时需要使用一个<strong><code>Errors</code></strong>对象，以便于在验证过程中，验证器可以将验证失败的信息报告给这个<strong><code>Errors</code></strong>对象。</p>
<p>让我们考虑一个小的数据对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    </div><div class="line">    <span class="comment">// the usual getters and setters...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过实现<strong><code>org.springframework.validation.Validator</code></strong>的下列两个接口，我们打算为<strong><code>Person</code></strong>类提供验证行为：</p>
<ul>
<li><strong><code>support(Class)</code></strong> - 这个<strong><code>Validator</code></strong>是否可以验证给定<strong><code>Class</code></strong>的实例</li>
<li><strong><code>validate(Object,org.springframework.validation.Errors)</code></strong> - 验证给定的对象并且万一验证错误，可以将这些错误注册到给定的<strong><code>Errors</code></strong>对象</li>
</ul>
<p>实现一个<strong><code>Validator</code></strong>是相当简单的，特别是当你知道Spring框架还提供了<strong><code>ValidationUtils</code></strong>辅助类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * This Validator validates *just* Person instances</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class clazz)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> Person.class.equals(clazz);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object obj, Errors e)</span> </span>&#123;</div><div class="line">		ValidationUtils.rejectIfEmpty(e, <span class="string">"name"</span>, <span class="string">"name.empty"</span>);</div><div class="line">		Person p = (Person) obj;</div><div class="line">		<span class="keyword">if</span> (p.getAge() &lt; <span class="number">0</span>) &#123;</div><div class="line">			e.rejectValue(<span class="string">"age"</span>, <span class="string">"negativevalue"</span>);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.getAge() &gt; <span class="number">110</span>) &#123;</div><div class="line">			e.rejectValue(<span class="string">"age"</span>, <span class="string">"too.darn.old"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如你看到的，<strong><code>ValidationUtils</code></strong>类的<strong><code>static</code> </strong> <strong><code>rejectIfEmpty(..)</code></strong>方法被用于拒绝那些值为<strong><code>null</code></strong>或者空字符串的<strong><code>&#39;name&#39;</code></strong>属性。除了上面展示的例子之外，去看一看<strong><code>ValidationUtils</code></strong>的java文档有助于了解它提供的功能。</p>
<p>通过实现单个的<strong><code>Validator</code></strong>类来逐个验证富对象中的嵌套对象当然是有可能的，然而将验证逻辑封装在每个嵌套类对象自身的<strong><code>Validator</code></strong>实现中可能是一种更好的选择。<strong><code>Customer</code></strong>就是一个<em>‘富’</em>对象的简单示例，它由两个字符串属性(姓和名)以及一个复杂对象<strong><code>Address</code></strong>组成。<strong><code>Address</code></strong>对象可能独立于<strong><code>Customer</code></strong>对象使用，因此已经实现了一个独特的<strong><code>AddressValidator</code></strong>。如果你想要你的<strong><code>CustomerValidator</code></strong>不借助于复制粘贴而重用包含在<strong><code>AddressValidator</code></strong>中的逻辑，那么你可以通过依赖注入或者实例化你的<strong><code>CustomerValidator</code></strong>中的<strong><code>AddressValidator</code></strong>，然后像这样使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Validator addressValidator;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomerValidator</span><span class="params">(Validator addressValidator)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (addressValidator == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The supplied [Validator] is "</span> +</div><div class="line">				<span class="string">"required and must not be null."</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (!addressValidator.supports(Address.class)) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The supplied [Validator] must "</span> +</div><div class="line">				<span class="string">"support the validation of [Address] instances."</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.addressValidator = addressValidator;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * This Validator validates Customer instances, and any subclasses of Customer too</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class clazz)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> Customer.class.isAssignableFrom(clazz);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</div><div class="line">		ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">"firstName"</span>, <span class="string">"field.required"</span>);</div><div class="line">		ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">"surname"</span>, <span class="string">"field.required"</span>);</div><div class="line">		Customer customer = (Customer) target;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			errors.pushNestedPath(<span class="string">"address"</span>);</div><div class="line">			ValidationUtils.invokeValidator(<span class="keyword">this</span>.addressValidator, customer.getAddress(), errors);</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			errors.popNestedPath();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>验证错误被报告给传递到验证器的<strong><code>Errors</code></strong>对象。在使用Spring Web MVC的情况下，你可以使用<strong><code>&lt;spring:bind/&gt;</code></strong>标签来检查错误信息，不过当然你也可以自己检查错误对象。有关它提供的方法的更多信息可以在java文档中找到。</p>
<h2 id="5-3-将代码解析成错误消息"><a href="#5-3-将代码解析成错误消息" class="headerlink" title="5.3 将代码解析成错误消息"></a>5.3 将代码解析成错误消息</h2><p>在之前我们已经谈论了数据绑定和验证，最后一件值得讨论的事情是输出对应于验证错误的消息。在我们上面展示的例子里，我们拒绝了<strong><code>name</code></strong>和<strong><code>age</code></strong>字段。如果我们要使用<strong><code>MessageSource</code></strong>来输出错误消息，我们将会使用我们在拒绝该字段(这个情况下是’姓名’和’年龄’)时给出的错误代码。当你调用(不管是直接调用还是间接通过使用<strong><code>ValidationUtils</code></strong>类调用)来自<strong><code>Errors</code></strong>接口的<strong><code>rejectValue</code></strong>或者其他<strong><code>reject</code></strong>方法时，其底层实现不仅会注册你传入的代码，还会注册一些额外的错误代码。注册怎样的错误代码取决于它所使用的<strong><code>MessageCodesResolver</code></strong>，默认情况下，会使用<strong><code>DefaultMessageCodesResolver</code></strong>，其不仅会使用你提供的代码注册消息，还会注册包含你传递给拒绝方法的字段名称的消息。所以如果你使用<strong><code>rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;)</code></strong>来拒绝一个字段，除了<strong><code>too.darn.old</code></strong>代码，Spring还会注册<strong><code>too.darn.old.age</code></strong>和<strong><code>too.darn.old.age.int</code></strong>(第一个会包含字段名称且第二个会包含字段类型)。这样做是为了方便开发人员来定位错误消息等。</p>
<p>有关<strong><code>MessageCodesResolver</code></strong>和其默认策略的更多信息可以分别在<strong><code>MessageCodesResolver</code></strong>以及<strong><code>DefaultMessageCodesResolver</code></strong>的在线java文档中找到。</p>
<h2 id="5-4-Bean操作和BeanWrapper"><a href="#5-4-Bean操作和BeanWrapper" class="headerlink" title="5.4 Bean操作和BeanWrapper"></a>5.4 Bean操作和BeanWrapper</h2><p><strong><code>org.springframework.beans</code></strong>包遵循Oracle提供的JavaBeans标准。一个JavaBean只是一个包含默认无参构造器的类，它遵循一个命名约定(通过一个例子)：一个名为<strong><code>bingoMadness</code></strong>属性将有一个设置方法<strong><code>setBingoMadness(..)</code></strong>和一个获取方法<strong><code>getBingoMadness(..)</code></strong>。有关JavaBeans和其规范的更多信息，请参考Oracle的网站(<a href="https://docs.oracle.com/javase/6/docs/api/java/beans/package-summary.html" target="_blank" rel="external">javabeans</a>)。</p>
<p>beans包里一个非常重要的类是<strong><code>BeanWrapper</code></strong>接口和它的相应实现(<strong><code>BeanWrapperImpl</code></strong>)。引用自java文档，<strong><code>BeanWrapper</code></strong>提供了设置和获取属性值(单独或批量)、获取属性描述符以及查询属性以确定它们是可读还是可写的功能。<strong><code>BeanWrapper</code></strong>还提供对嵌套属性的支持，能够不受嵌套深度的限制启用子属性的属性设置。然后，<strong><code>BeanWrapper</code></strong>提供了无需目标类代码的支持就能够添加标准JavaBeans的<strong><code>PropertyChangeListeners</code></strong>和<strong><code>VetoableChangeListeners</code></strong>的能力。最后然而并非最不重要的是，<strong><code>BeanWrapper</code></strong>提供了对索引属性设置的支持。<strong><code>BeanWrapper</code></strong>通常不会被应用程序的代码直接使用，而是由<strong><code>DataBinder</code></strong>和<strong><code>BeanFactory</code></strong>使用。</p>
<p><strong><code>BeanWrapper</code></strong>的名字已经部分暗示了它的工作方式：它包装一个bean以对其执行操作，比如设置和获取属性。</p>
<h3 id="5-4-1-设置并获取基本和嵌套属性"><a href="#5-4-1-设置并获取基本和嵌套属性" class="headerlink" title="5.4.1 设置并获取基本和嵌套属性"></a>5.4.1 设置并获取基本和嵌套属性</h3><p>使用<strong><code>setPropertyValue(s)</code></strong>和<strong><code>getPropertyValue(s)</code></strong>可以设置并获取属性，两者都带有几个重载方法。在Spring自带的java文档中对它们有更详细的描述。重要的是要知道对象属性指示的几个约定。几个例子：</p>
<p><strong>表 5.1. 属性示例</strong></p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>name</code></strong></td>
<td>表示属性<strong><code>name</code></strong>与方法<strong><code>getName()</code></strong>或<strong><code>isName()</code></strong>和<strong><code>setName()</code></strong>相对应</td>
</tr>
<tr>
<td><strong><code>account.name</code></strong></td>
<td>表示属性<strong><code>account</code></strong>的嵌套属性<strong><code>name</code></strong>与方法<strong><code>getAccount().setName()</code></strong>或<strong><code>getAccount().getName()</code></strong>相对应</td>
</tr>
<tr>
<td><strong><code>account[2]</code></strong></td>
<td>表示索引属性<strong><code>account</code></strong>的第三个元素。索引属性可以是<strong><code>array</code></strong>、<strong><code>list</code></strong>或其他自然排序的集合</td>
</tr>
<tr>
<td><strong><code>account[COMPANYNAME]</code></strong></td>
<td>表示映射属性<strong><code>account</code></strong>被键<em>COMPANYNAME</em>索引到的映射项的值</td>
</tr>
</tbody>
</table>
<p>下面你会发现一些使用<strong><code>BeanWrapper</code></strong>来获取和设置属性的例子。</p>
<p><em>(如果你不打算直接使用<strong><code>BeanWrapper</code></strong>，那么下一部分对你来说并不重要。如果你仅使用<strong><code>DataBinder</code></strong>和<strong><code>BeanFactory</code></strong>以及它们开箱即用的实现，你应该跳到关于<strong><code>PropertyEditor</code></strong>部分的开头)。</em></p>
<p>考虑下面两个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> Employee managingDirector;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Employee <span class="title">getManagingDirector</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.managingDirector;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setManagingDirector</span><span class="params">(Employee managingDirector)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.managingDirector = managingDirector;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">float</span> salary;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> salary;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">float</span> salary)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.salary = salary;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下的代码片段展示了如何检索和操纵实例化的<strong><code>Companies</code></strong>和<strong><code>Employees</code></strong>的某些属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">BeanWrapper company = <span class="keyword">new</span> BeanWrapperImpl(<span class="keyword">new</span> Company());</div><div class="line"><span class="comment">// setting the company name..</span></div><div class="line">company.setPropertyValue(<span class="string">"name"</span>, <span class="string">"Some Company Inc."</span>);</div><div class="line"><span class="comment">// ... can also be done like this:</span></div><div class="line">PropertyValue value = <span class="keyword">new</span> PropertyValue(<span class="string">"name"</span>, <span class="string">"Some Company Inc."</span>);</div><div class="line">company.setPropertyValue(value);</div><div class="line"></div><div class="line"><span class="comment">// ok, let's create the director and tie it to the company:</span></div><div class="line">BeanWrapper jim = <span class="keyword">new</span> BeanWrapperImpl(<span class="keyword">new</span> Employee());</div><div class="line">jim.setPropertyValue(<span class="string">"name"</span>, <span class="string">"Jim Stravinsky"</span>);</div><div class="line">company.setPropertyValue(<span class="string">"managingDirector"</span>, jim.getWrappedInstance());</div><div class="line"></div><div class="line"><span class="comment">// retrieving the salary of the managingDirector through the company</span></div><div class="line">Float salary = (Float) company.getPropertyValue(<span class="string">"managingDirector.salary"</span>);</div></pre></td></tr></table></figure>
<h3 id="5-4-2-内置PropertyEditor实现"><a href="#5-4-2-内置PropertyEditor实现" class="headerlink" title="5.4.2 内置PropertyEditor实现"></a>5.4.2 内置PropertyEditor实现</h3><p>Spring使用<strong><code>PropertyEditor</code></strong>的概念来实现<strong><code>Object</code></strong>和<strong><code>String</code></strong>之间的转换。如果你考虑到它，有时候换另一种方式表示属性可能比对象本身更方便。举个例子，一个<strong><code>Date</code></strong>可以以人类可读的方式表示(如<strong><code>String</code></strong> <strong><code>&#39;2007-14-09&#39;</code></strong>)，同时我们依然能把人类可读的形式转换回原始的时间(甚至可能更好：将任何以人类可读形式输入的时间转换回<strong><code>Date</code></strong>对象)。这种行为可以通过注册类型为<strong><code>PropertyEditor</code></strong>的自定义编辑器来实现。在<strong><code>BeanWrapper</code></strong>或上一章提到的特定IoC容器中注册自定义编辑器，可以使其了解如何将属性转换为期望的类型。请阅读Oracle为<strong><code>java.beans</code></strong>包提供的java文档来获取更多关于<strong><code>PropertyEditor</code></strong>的信息。</p>
<p>这是Spring使用属性编辑的两个例子：</p>
<ul>
<li>使用<strong><code>PropertyEditor</code></strong>来完成<em>bean的属性设置</em>。当提到将<strong><code>java.lang.String</code></strong>作为你在XML文件中声明的某些bean的属性值时，Spring将会(如果相应的属性的设置方法具有一个<strong><code>Class</code></strong>参数)使用<strong><code>ClassEditor</code></strong>尝试将参数解析成<strong><code>Class</code></strong>对象。</li>
<li>在Spring的MVC框架中<em>解析HTTP请求的参数</em>是由各种<strong><code>PropertyEditor</code></strong>完成的，你可以把它们手动绑定到<strong><code>CommandController</code></strong>的所有子类。</li>
</ul>
<p>Spring有一些内置的<strong><code>PropertyEditor</code></strong>使生活变得轻松。它们中的每一个都已列在下面，并且它们都被放在<strong><code>org.springframework.beans.propertyeditors</code></strong>包中。大部分但并不是全部(如下所示)，默认情况下会由<strong><code>BeanWrapperImpl</code></strong>注册。在某种方式下属性编辑器是可配置的，那么理所当然，你可以注册你自己的变种来覆盖默认编辑器：</p>
<p><span id="5.4.2-Built-in PropertyEditor implementations"><strong>Table 5.2. 内置PropertyEditor</strong></span></p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>ByteArrayPropertyEditor</code></strong></td>
<td>针对字节数组的编辑器。字符串会简单地转换成相应的字节表示。默认情况下由<strong><code>BeanWrapperImpl</code></strong>注册。</td>
</tr>
<tr>
<td><strong><code>ClassEditor</code></strong></td>
<td>将类的字符串表示形式解析成实际的类形式并且也能返回实际类的字符串表示形式。如果找不到类，会抛出一个<strong><code>IllegalArgumentException</code></strong>。默认情况下由<strong><code>BeanWrapperImpl</code></strong>注册。</td>
</tr>
<tr>
<td><strong><code>CustomBooleanEditor</code></strong></td>
<td>针对<strong><code>Boolean</code></strong>属性的可定制的属性编辑器。默认情况下由<strong><code>BeanWrapperImpl</code></strong>注册，但是可以作为一种自定义编辑器通过注册其自定义实例来进行覆盖。</td>
</tr>
<tr>
<td><strong><code>CustomCollectionEditor</code></strong></td>
<td>针对集合的属性编辑器，可以将原始的<strong><code>Collection</code></strong>转换成给定的目标<strong><code>Collection</code></strong>类型。</td>
</tr>
<tr>
<td><strong><code>CustomDateEditor</code></strong></td>
<td>针对java.util.Date的可定制的属性编辑器，支持自定义的时间格式。不会被默认注册，用户必须使用适当格式进行注册。</td>
</tr>
<tr>
<td><strong><code>CustomNumberEditor</code></strong></td>
<td>针对任何Number子类(比如<strong><code>Integer</code></strong>、<strong><code>Long</code></strong>、<strong><code>Float</code></strong>、<strong><code>Double</code></strong>)的可定制的属性编辑器。默认情况下由<strong><code>BeanWrapperImpl</code></strong>注册，但是可以作为一种自定义编辑器通过注册其自定义实例来进行覆盖。</td>
</tr>
<tr>
<td><strong><code>FileEditor</code></strong></td>
<td>能够将字符串解析成<strong><code>java.io.File</code></strong>对象。默认情况下由<strong><code>BeanWrapperImpl</code></strong>注册。</td>
</tr>
<tr>
<td><strong><code>InputStreamEditor</code></strong></td>
<td>一次性的属性编辑器，能够读取文本字符串并生成(通过中间的<strong><code>ResourceEditor</code></strong>以及<strong><code>Resource</code></strong>)一个<strong><code>InputStream</code></strong>对象，因此<strong><code>InputStream</code></strong>类型的属性可以直接以字符串设置。请注意默认的使用方式不会为你关闭<strong><code>InputStream</code></strong>！默认情况下由<strong><code>BeanWrapperImpl</code></strong>注册。</td>
</tr>
<tr>
<td><strong><code>LocaleEditor</code></strong></td>
<td>能够将字符串解析成<strong><code>Locale</code></strong>对象，反之亦然(字符串格式是<em>[country]</em>[variant]，这与Locale提供的toString()方法是一样的)。默认情况下由<strong><code>BeanWrapperImpl</code></strong>注册。</td>
</tr>
<tr>
<td><strong><code>PatternEditor</code></strong></td>
<td>能够将字符串解析成<strong><code>java.util.regex.Pattern</code></strong>对象，反之亦然。</td>
</tr>
<tr>
<td><strong><code>PropertiesEditor</code></strong></td>
<td>能够将字符串(按照<strong><code>java.util.Properties</code></strong>类的java文档定义的格式进行格式化)解析成<strong><code>Properties</code></strong>对象。默认情况下由<strong><code>BeanWrapperImpl</code></strong>注册。</td>
</tr>
<tr>
<td><strong><code>StringTrimmerEditor</code></strong></td>
<td>用于缩减字符串的属性编辑器。有选择性允许将一个空字符串转变成<strong><code>null</code></strong>值。不会进行默认注册，需要在用户有需要的时候注册。</td>
</tr>
<tr>
<td><strong><code>URLEditor</code></strong></td>
<td>能够将一个URL的字符串表示解析成实际的<strong><code>URL</code></strong>对象。默认情况下由<strong><code>BeanWrapperImpl</code></strong>注册。</td>
</tr>
</tbody>
</table>
<p>Spring使用<strong><code>java.beans.PropertyEditorManager</code></strong>来设置可能需要的属性编辑器的搜索路径。搜索路径中还包括了<strong><code>sun.bean.editors</code></strong>，这个包里面包含如<strong><code>Font</code></strong>、<strong><code>Color</code></strong>类型以及其他大部分基本类型的<strong><code>PropertyEditor</code></strong>实现。还要注意的是，如果<strong><code>PropertyEditor</code></strong>类与它们所处理的类位于同一个包并且除了’Editor’后缀之外拥有相同的名字，那么标准的JavaBeans基础设施会自动发现这些它们(不需要你显式的注册它们)。例如，有人可能会有以下的类和包结构，这已经足够识别出<strong><code>FooEditor</code></strong>类并将其作为<strong><code>Foo</code></strong>类型属性的<strong><code>PropertyEditor</code></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">com</div><div class="line">  chank</div><div class="line">    pop</div><div class="line">      Foo</div><div class="line">      FooEditor // the PropertyEditor for the Foo class</div></pre></td></tr></table></figure>
<p>要注意的是在这里你也可以使用标准JavaBeans机制的<strong><code>BeanInfo</code></strong>(在<a href="https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html" target="_blank" rel="external">in not-amazing-detail here</a>有描述)。在下面的示例中，你可以看到使用<strong><code>BeanInfo</code></strong>机制为一个关联类的属性显式注册一个或多个<strong><code>PropertyEditor</code></strong>实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">com</div><div class="line">  chank</div><div class="line">    pop</div><div class="line">      Foo</div><div class="line">      FooBeanInfo // the BeanInfo for the Foo class</div></pre></td></tr></table></figure>
<p>这是被引用到的<strong><code>FooBeanInfo</code></strong>类的Java源代码。它会将一个<strong><code>CustomNumberEditor</code></strong>同<strong><code>Foo</code></strong>类的<strong><code>age</code></strong>属性关联。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBeanInfo</span> <span class="keyword">extends</span> <span class="title">SimpleBeanInfo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">final</span> PropertyEditor numberPE = <span class="keyword">new</span> CustomNumberEditor(Integer.class, <span class="keyword">true</span>);</div><div class="line">			PropertyDescriptor ageDescriptor = <span class="keyword">new</span> PropertyDescriptor(<span class="string">"age"</span>, Foo.class) &#123;</div><div class="line">				<span class="function"><span class="keyword">public</span> PropertyEditor <span class="title">createPropertyEditor</span><span class="params">(Object bean)</span> </span>&#123;</div><div class="line">					<span class="keyword">return</span> numberPE;</div><div class="line">				&#125;;</div><div class="line">			&#125;;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> PropertyDescriptor[] &#123; ageDescriptor &#125;;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (IntrospectionException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Error(ex.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><span id="Registering additional custom PropertyEditors"></span></p>
<h4 id="注册额外的自定义PropertyEditor"><a href="#注册额外的自定义PropertyEditor" class="headerlink" title="注册额外的自定义PropertyEditor"></a>注册额外的自定义PropertyEditor</h4><p>当bean属性设置成一个字符串值时，Spring IoC容器最终会使用标准JavaBeans的<strong><code>PropertyEditor</code></strong>将这些字符串转换成复杂类型的属性。Spring预先注册了一些自定义<strong><code>PropertyEditor</code></strong>(例如将一个以字符串表示的类名转换成真正的<strong><code>Class</code></strong>对象)。此外，Java的标准JavaBeans <strong><code>PropertyEditor</code></strong>查找机制允许一个<strong><code>PropertyEditor</code></strong>只需要恰当的命名并同它支持的类位于相同的包，就能够自动发现它。</p>
<p>如果需要注册其他自定义的<strong><code>PropertyEditor</code></strong>，还有几种可用机制。假设你有一个<strong><code>BeanFactory</code></strong>引用，最人工化的方式(但通常并不方便或者推荐)是直接使用<strong><code>ConfigurableBeanFactory</code></strong>接口的<strong><code>registerCustomEditor()</code></strong>方法。另一种略为方便的机制是使用一个被称为<strong><code>CustomEditorConfigurer</code></strong>的特殊的bean factory后处理器(<em>post-processor</em>)。虽然bean factory后处理器可以与<strong><code>BeanFactory</code></strong>实现一起使用，但是因为<strong><code>CustomEditorConfigurer</code></strong>有一个嵌套属性设置过程，所以强烈推荐它与<strong><code>ApplicationContext</code></strong>一起使用，这样就可以采用与其他bean类似的方式来部署它，并自动检测和应用。</p>
<p>请注意所有的bean工厂和应用上下文都会自动地使用一些内置属性编辑器，这些编辑器通过一个被称为<strong><code>BeanWrapper</code></strong>的接口来处理属性转换。<strong><code>BeanWrapper</code></strong>注册的那些标准属性编辑器已经列在<a href="#5.4.2-Built-in PropertyEditor implementations">上一部分</a>。 此外，针对特定的应用程序上下文类型，<strong><code>ApplicationContext</code></strong>会用适当的方法覆盖或添加一些额外的编辑器来处理资源查找。</p>
<p>标准的JavaBeans <strong><code>PropertyEditor</code></strong>实例用于将字符串表示的属性值转换成实际的复杂类型属性。<strong><code>CustomEditorConfigurer</code></strong>，一个bean factory后处理器，可以为添加额外的<strong><code>PropertyEditor</code></strong>到<strong><code>ApplicationContext</code></strong>提供便利支持。</p>
<p>考虑一个用户类<strong><code>ExoticType</code></strong>和另外一个需要将<strong><code>ExoticType</code></strong>设为属性的类<strong><code>DependsOnExoticType</code></strong>： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> example;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExoticType</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ExoticType</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependsOnExoticType</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ExoticType type;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(ExoticType type)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.type = type;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当东西都被正确设置时，我们希望能够分配字符串给type属性，而<strong><code>PropertyEditor</code></strong>会在背后将其转换成实际的<strong><code>ExoticType</code></strong>实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sample"</span> <span class="attr">class</span>=<span class="string">"example.DependsOnExoticType"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"type"</span> <span class="attr">value</span>=<span class="string">"aNameForExoticType"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong><code>PropertyEditor</code></strong>实现可能与此类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// converts string representation to ExoticType object</span></div><div class="line"><span class="keyword">package</span> example;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExoticTypeEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> </span>&#123;</div><div class="line">		setValue(<span class="keyword">new</span> ExoticType(text.toUpperCase()));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我们使用<strong><code>CustomEditorConfigurer</code></strong>将一个新的<strong><code>PropertyEditor</code></strong>注册到<strong><code>ApplicationContext</code></strong>，那么在需要的时候就能够使用它：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomEditorConfigurer"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"customEditors"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"example.ExoticType"</span> <span class="attr">value</span>=<span class="string">"example.ExoticTypeEditor"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="使用PropertyEditorRegistrar"><a href="#使用PropertyEditorRegistrar" class="headerlink" title="使用PropertyEditorRegistrar"></a>使用PropertyEditorRegistrar</h4><p>另一种将属性编辑器注册到Spring容器的机制是创建和使用一个<strong><code>PropertyEditorRegistrar</code></strong>。当你需要在几个不同场景里使用同一组属性编辑器，这个接口会特别有用：编写一个相应的registrar并在每个用例里重用。<strong><code>PropertyEditorRegistrar</code></strong>与一个被称为<strong><code>PropertyEditorRegistry</code></strong>的接口配合工作，后者被Spring的<strong><code>BeanWrapper</code></strong>(以及<strong><code>DataBinder</code></strong>)实现。当与<strong><code>CustomEditorConfigurer</code></strong>配合使用的时候，<strong><code>PropertyEditorRegistrar</code></strong>特别方便(<a href="#Registering additional custom PropertyEditors">这里</a>有介绍)，因为前者暴露了一个方法<strong><code>setPropertyEditorRegistrars(..)</code></strong>：以这种方式添加到<strong><code>CustomEditorConfigurerd</code></strong>的<strong><code>PropertyEditorRegistrar</code></strong>可以很容易地在<strong><code>DataBinder</code></strong>和Spring MVC <strong><code>Controllers</code></strong>之间共享。另外，它避免了在自定义编辑器上的同步需求：一个<strong><code>PropertyEditorRegistrar</code></strong>可以为每一次bean创建尝试创建新的<strong><code>PropertyEditor</code></strong>实例。</p>
<p>使用<strong><code>PropertyEditorRegistrar</code></strong>可能最好还是以一个例子来说明。首先，你需要创建你自己的<strong><code>PropertyEditorRegistrar</code></strong>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.foo.editors.spring;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPropertyEditorRegistrar</span> <span class="keyword">implements</span> <span class="title">PropertyEditorRegistrar</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCustomEditors</span><span class="params">(PropertyEditorRegistry registry)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">// it is expected that new PropertyEditor instances are created</span></div><div class="line">		registry.registerCustomEditor(ExoticType.class, <span class="keyword">new</span> ExoticTypeEditor());</div><div class="line"></div><div class="line">		<span class="comment">// you could register as many custom property editors as are required here...</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以查看<strong><code>org.springframework.beans.support.ResourceEditorRegistrar</code></strong>当作一个<strong><code>PropertyEditorRegistrar</code></strong>实现的示例。注意在它的<strong><code>registerCustomEditors(..)</code></strong>方法实现里是如何为每个属性编辑器创建新的实例的。</p>
<p>接着我们配置了一个<strong><code>CustomEditorConfigurerd</code></strong>并将我们的<strong><code>CustomPropertyEditorRegistrar</code></strong>注入其中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomEditorConfigurer"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"propertyEditorRegistrars"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"customPropertyEditorRegistrar"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customPropertyEditorRegistrar"</span></span></div><div class="line">	<span class="attr">class</span>=<span class="string">"com.foo.editors.spring.CustomPropertyEditorRegistrar"</span>/&gt;</div></pre></td></tr></table></figure>
<p>最后，有点偏离本章的重点，针对你们之中使用<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html" target="_blank" rel="external">Spring’s MVC web framework</a>的那些人，使用<strong><code>PropertyEditorRegistrar</code></strong>与数据绑定的<strong><code>Controller</code></strong>(比如<strong><code>SimpleFormController</code></strong>)配合使用会非常方便。下面是一个在<strong><code>initBinder(..)</code></strong>方法的实现里使用<strong><code>PropertyEditorRegistrar</code></strong>的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterUserController</span> <span class="keyword">extends</span> <span class="title">SimpleFormController</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> PropertyEditorRegistrar customPropertyEditorRegistrar;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RegisterUserController</span><span class="params">(PropertyEditorRegistrar propertyEditorRegistrar)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.customPropertyEditorRegistrar = propertyEditorRegistrar;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(HttpServletRequest request,</span></span></div><div class="line">			ServletRequestDataBinder binder) <span class="keyword">throws</span> Exception &#123;</div><div class="line">		<span class="keyword">this</span>.customPropertyEditorRegistrar.registerCustomEditors(binder);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// other methods to do with registering a User</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种<strong><code>PropertyEditor</code></strong>注册的风格可以导致简洁的代码(<strong><code>initBinder(..)</code></strong>的实现仅仅只有一行！)，同时也允许将通用的<strong><code>PropertyEditor</code></strong>注册代码封装到一个类里然后根据需要在尽可能多的<strong><code>Controller</code></strong>之间共享。</p>
<h2 id="5-5-Spring类型转换"><a href="#5-5-Spring类型转换" class="headerlink" title="5.5 Spring类型转换"></a>5.5 Spring类型转换</h2><p>Spring 3引入了<strong><code>core.convert</code></strong>包来提供一个一般类型的转换系统。这个系统定义了实现类型转换逻辑的服务提供接口(SPI)以及在运行时执行类型转换的API。在Spring容器内，这个系统可以当作是PropertyEditor的替代选择，用于将外部bean的属性值字符串转换成所需的属性类型。这个公共的API也可以在你的应用程序中任何需要类型转换的地方使用。</p>
<h3 id="5-5-1-Converter-SPI"><a href="#5-5-1-Converter-SPI" class="headerlink" title="5.5.1 Converter SPI"></a>5.5.1 Converter SPI</h3><p>实现类型转换逻辑的SPI是简单并且强类型的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要创建属于你自己的转换器，只需要简单的实现以上接口即可。泛型参数S表示你想要进行转换的源类型，而泛型参数T表示你想要转换的目标类型。如果一个包含S类型元素的集合或数组需要转换为一个包含T类型的数组或集合，那么这个转换器也可以被透明地应用，前提是已经注册了一个委托数组或集合的转换器(默认情况下会是<strong><code>DefaultConversionService</code></strong>处理)。</p>
<p>对每次方法<strong><code>convert(S)</code></strong>的调用，source参数值必须确保不为空。如果转换失败，你的转换器可以抛出任何非受检异常(<em>unchecked exception</em>)；具体来说，为了报告一个非法的source参数值，应该抛出一个<strong><code>IllegalArgumentException</code></strong>。还有要注意确保你的<strong><code>Converter</code></strong>实现必须是线程安全的。</p>
<p>为方便起见，<strong><code>core.convert.support</code></strong>包已经提供了一些转换器实现，这些实现包括了从字符串到数字以及其他常见类型的转换。考虑将<strong><code>StringToInteger</code></strong>作为一个典型的<strong><code>Converter</code></strong>实现示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.support;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToInteger</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> Integer.valueOf(source);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-5-2-ConverterFactory"><a href="#5-5-2-ConverterFactory" class="headerlink" title="5.5.2 ConverterFactory"></a>5.5.2 ConverterFactory</h3><p>当你需要集中整个类层次结构的转换逻辑时，例如，碰到将String转换到java.lang.Enum对象的时候，请实现<strong><code>ConverterFactory</code></strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	&lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>泛型参数S表示你想要转换的源类型，泛型参数R表示你可以转换的那些范围内的类型的基类。然后实现getConverter(Class<t>)，其中T就是R的一个子类。</t></p>
<p>考虑将<strong><code>StringToEnum</code></strong>作为ConverterFactory的一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.support;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToEnumConverterFactory</span> <span class="keyword">implements</span> <span class="title">ConverterFactory</span>&lt;<span class="title">String</span>, <span class="title">Enum</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> &lt;T extends Enum&gt; <span class="function">Converter&lt;String, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StringToEnumConverter(targetType);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToEnumConverter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Enum</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">		<span class="keyword">private</span> Class&lt;T&gt; enumType;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">StringToEnumConverter</span><span class="params">(Class&lt;T&gt; enumType)</span> </span>&#123;</div><div class="line">			<span class="keyword">this</span>.enumType = enumType;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> (T) Enum.valueOf(<span class="keyword">this</span>.enumType, source.trim());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-5-3-GenericConverter"><a href="#5-5-3-GenericConverter" class="headerlink" title="5.5.3 GenericConverter"></a>5.5.3 GenericConverter</h3><p>当你需要一个复杂的转换器实现时，请考虑GenericConverter接口。GenericConverter具备更加灵活但是不太强的类型签名，以支持在多种源类型和目标类型之间的转换。此外，当实现你的转换逻辑时，GenericConverter还可以使源字段和目标字段的上下文对你可用，这样的上下文允许类型转换由字段上的注解或者字段声明中的泛型信息来驱动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要实现一个GenericConverter，getConvertibleTypes()方法要返回支持的源-目标类型对，然后实现convert(Object,TypeDescriptor,TypeDescriptor)方法来实现你的转换逻辑。源TypeDescriptor提供了对持有被转换值的源字段的访问，目标TypeDescriptor提供了对设置转换值的目标字段的访问。</p>
<p>一个很好的GenericConverter的示例是一个在Java数组和集合之间进行转换的转换器。这样一个ArrayToCollectionConverter可以通过内省声明了目标集合类型的字段以解析集合元素的类型，这将允许原数组中每个元素可以在集合被设置到目标字段之前转换成集合元素的类型。</p>
<blockquote>
<p>由于GenericConverter是一个更复杂的SPI接口，所以对基本类型的转换需求优先使用Converter或者ConverterFactory。 </p>
</blockquote>
<h4 id="ConditionalGenericConverter"><a href="#ConditionalGenericConverter" class="headerlink" title="ConditionalGenericConverter"></a>ConditionalGenericConverter</h4><p>有时候你只想要在特定条件成立的情况下<strong><code>Converter</code></strong>才执行，例如，你可能只想要在目标字段存在特定注解的情况下才执行<strong><code>Converter</code></strong>，或者你可能只想要在目标类中定义了特定方法，比如<strong><code>static</code></strong> <strong><code>valueOf</code></strong>方法，才执行<strong><code>Converter</code></strong>。<strong><code>ConditionalGenericConverter</code></strong>是<strong><code>GenericConverter</code></strong>和<strong><code>ConditionalConveter</code></strong>接口的联合，允许你定义这样的自定义匹配条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionalGenericConverter</span></span></div><div class="line">        <span class="keyword">extends</span> <span class="title">GenericConverter</span>, <span class="title">ConditionalConverter</span> &#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>ConditionalGenericConverter</code></strong>的一个很好的例子是一个在持久化实体标识和实体引用之间进行转换的实体转换器。这个实体转换器可能只匹配这样的条件–目标实体类声明了一个静态的查找方法，例如<strong><code>findAccount(Long)</code></strong>，你将在<strong><code>matches(TypeDescriptor,TypeDescriptor)</code></strong>方法实现里执行这样的查找方法的检测。</p>
<h3 id="5-5-4-ConversionService-API"><a href="#5-5-4-ConversionService-API" class="headerlink" title="5.5.4 ConversionService API"></a>5.5.4 ConversionService API</h3><p>ConversionService接口定义了运行时执行类型转换的统一API，转换器往往是在这个门面(<em>facade</em>)接口背后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConversionService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</div><div class="line"></div><div class="line">	&lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(Object source, Class&lt;T&gt; targetType)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">	<span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大多数ConversionService实现也会实现<strong><code>ConverterRegistry</code></strong>接口，这个接口提供一个用于注册转换器的服务提供接口(SPI)。在内部，一个ConversionService实现会以委托给注册其中的转换器的方式来执行类型转换逻辑。</p>
<p><strong><code>core.convert.support</code></strong>包已经提供了一个强大的ConversionService实现，<strong><code>GenericConversionService</code></strong>是适用于大多数环境的通用实现，<strong><code>ConversionServiceFactory</code></strong>以工厂的方式为创建常见的ConversionService配置提供了便利。</p>
<h3 id="5-5-5-配置ConversionService"><a href="#5-5-5-配置ConversionService" class="headerlink" title="5.5.5 配置ConversionService"></a>5.5.5 配置ConversionService</h3><p>ConversionService是一个被设计成在应用程序启动时会进行实例化的无状态对象，随后可以在多个线程之间共享。在一个Spring应用程序中，你通常会为每一个Spring容器(或者应用程序上下文ApplicationContext)配置一个ConversionService实例，它会被Spring接收并在框架需要执行一个类型转换时使用。你也可以将这个ConversionService直接注入到你任何的Bean中并直接调用。</p>
<blockquote>
<p>如果Spring没有注册ConversionService，则会使用原始的基于PropertyEditor的系统。</p>
</blockquote>
<p>要向Spring注册默认的ConversionService，可以用<strong><code>conversionService</code></strong>作为id来添加如下的bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></div><div class="line">	<span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>/&gt;</div></pre></td></tr></table></figure>
<p>默认的ConversionService可以在字符串、数字、枚举、映射和其他常见类型之间进行转换。为了使用你自己的自定义转换器来补充或者覆盖默认的转换器，可以设置<strong><code>converters</code></strong>属性，该属性值可以是Converter、ConverterFactory或者GenericConverter之中任何一个的接口实现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></div><div class="line">		<span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.MyCustomConverter"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在一个Spring MVC应用程序中使用ConversionService也是比较常见的，可以去看Spring MVC章节的<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-config-conversion" target="_blank" rel="external">Section 18.16.3 “Conversion and Formatting”</a>。</p>
<p>在某些情况下，你可能希望在转换期间应用格式化，可以看<a href="#5.6.3 FormatterRegistry SPI">5.6.3 “FormatterRegistry SPI”</a>获取使用<strong><code>FormattingConversionServiceFactoryBean</code></strong>的细节。</p>
<h3 id="5-5-6-编程方式使用ConversionService"><a href="#5-5-6-编程方式使用ConversionService" class="headerlink" title="5.5.6 编程方式使用ConversionService"></a>5.5.6 编程方式使用ConversionService</h3><p>要以编程方式使用ConversionService，你只需要像处理其他bean一样注入一个引用即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(ConversionService conversionService)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.conversionService = conversionService;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.conversionService.convert(...)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对大多数用例来说，<strong><code>convert</code></strong>方法指定了可以使用的目标类型，但是它不适用于更复杂的类型比如参数化元素的集合。例如，如果你想要以编程方式将一个<strong><code>Integer</code></strong>的<strong><code>List</code></strong>转换成一个<strong><code>String</code></strong>的<strong><code>List</code></strong>，就需要为原类型和目标类型提供一个正式的定义。</p>
<p>幸运的是，<strong><code>TypeDescriptor</code></strong>提供了多种选项使事情变得简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DefaultConversionService cs = <span class="keyword">new</span> DefaultConversionService();</div><div class="line"></div><div class="line">List&lt;Integer&gt; input = ....</div><div class="line">cs.convert(input,</div><div class="line">	TypeDescriptor.forObject(input), <span class="comment">// List&lt;Integer&gt; type descriptor</span></div><div class="line">	TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));</div></pre></td></tr></table></figure>
<p>注意<strong><code>DefaultConversionService</code></strong>会自动注册对大部分环境都适用的转换器，这其中包括了集合转换器、标量转换器还有基本的<strong><code>Object</code></strong>到<strong><code>String</code></strong>的转换器。可以通过调用<strong><code>DefaultConversionService</code></strong>类上的静态方法<strong><code>addDefaultConverters</code></strong>来向任意的<strong><code>ConverterRegistry</code></strong>注册相同的转换器。</p>
<p>因为值类型的转换器可以被数组和集合重用，所以假设标准集合处理是恰当的，就没有必要创建将一个<strong><code>S</code></strong>的<strong><code>Collection</code></strong>转换成一个<strong><code>T</code></strong>的<strong><code>Collection</code></strong>的特定转换器。</p>
<h2 id="5-6-Spring字段格式化"><a href="#5-6-Spring字段格式化" class="headerlink" title="5.6 Spring字段格式化"></a>5.6 Spring字段格式化</h2><p>如上一节所述，<strong><code>core.convert</code></strong>包是一个通用类型转换系统，它提供了统一的ConversionService API以及强类型的Converter SPI用于实现将一种类型转换成另外一种的转换逻辑。Spring容器使用这个系统来绑定bean属性值，此外，Spring表达式语言(SpEL)和DataBinder也都使用这个系统来绑定字段值。举个例子，当SpEL需要将<strong><code>Short</code></strong>强制转换成<strong><code>Long</code></strong>来完成一次<strong><code>expression.setValue(Object bean, Object value)</code></strong>尝试时，core.convert系统就会执行这个强制转换。</p>
<p>现在让我们考虑一个典型的客户端环境如web或桌面应用程序的类型转换要求，在这样的环境里，你通常会经历将字符串进行转换以支持客户端回传的过程以及转换回字符串以支持视图渲染的过程。此外，你经常需要对字符串值进行本地化。更通用的<em>core.convert</em>包中的Converter SPI不直接解决这种格式化要求。Spring 3为此引入了一个方便的Formatter SPI来直接解决这些问题，这个接口为客户端环境提供一种简单强大并且替代PropertyEditor的方案。</p>
<p>一般来说，当你需要实现通用的类型转换逻辑时请使用Converter SPI，例如，在java.util.Date和java.lang.Long之间进行转换。当你在一个客户端环境(比如web应用程序)工作并且需要解析和打印本地化的字段值时，请使用Formatter SPI。ConversionService接口为这两者提供了一套统一的类型转换API。</p>
<h3 id="5-6-1-Formatter-SPI"><a href="#5-6-1-Formatter-SPI" class="headerlink" title="5.6.1 Formatter SPI"></a>5.6.1 Formatter SPI</h3><p>Formatter SPI实现字段格式化逻辑是简单并且强类型的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formatter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Formatter接口扩展了Printer和Parser这两个基础接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="function">String <span class="title">print</span><span class="params">(T fieldValue, Locale locale)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.text.ParseException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="function">T <span class="title">parse</span><span class="params">(String clientValue, Locale locale)</span> <span class="keyword">throws</span> ParseException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要创建你自己的格式化器，只需要实现上面的Formatter接口。泛型参数T代表你想要格式化的对象的类型，例如，<strong><code>java.util.Date</code></strong>。实现<strong><code>print()</code></strong>操作可以将类型T的实例按客户端区域设置的显示方式打印出来。实现<strong><code>parse()</code></strong>操作可以从依据客户端区域设置返回的格式化表示中解析出类型T的实例。如果解析尝试失败，你的格式化器应该抛出一个ParseException或者IllegalArgumentException。请注意确保你的格式化器实现是线程安全的。</p>
<p>为方便起见，<strong><code>format</code></strong>子包中已经提供了一些格式化器实现。<strong><code>number</code></strong>包提供了<strong><code>NumberFormatter</code></strong>、<strong><code>CurrencyFormatter</code></strong>和<strong><code>PercentFormatter</code></strong>，它们通过使用<strong><code>java.text.NumberFormat</code></strong>来格式化<strong><code>java.lang.Number</code></strong>对象 。<strong><code>datetime</code></strong>包提供了<strong><code>DateFormatter</code></strong>，其通过使用<strong><code>java.text.DateFormat</code></strong>来格式化<strong><code>java.util.Date</code></strong>。<strong><code>datetime.joda</code></strong>包基于<a href="http://www.joda.org/joda-time/" target="_blank" rel="external">Joda Time library</a>提供了全面的日期时间格式化支持。</p>
<p>考虑将<strong><code>DateFormatter</code></strong>作为<strong><code>Formatter</code></strong>实现的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format.datetime;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String pattern;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DateFormatter</span><span class="params">(String pattern)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.pattern = pattern;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">(Date date, Locale locale)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (date == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> getDateFormat(locale).format(date);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String formatted, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</div><div class="line">		<span class="keyword">if</span> (formatted.length() == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> getDateFormat(locale).parse(formatted);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">protected</span> DateFormat <span class="title">getDateFormat</span><span class="params">(Locale locale)</span> </span>&#123;</div><div class="line">		DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="keyword">this</span>.pattern, locale);</div><div class="line">		dateFormat.setLenient(<span class="keyword">false</span>);</div><div class="line">		<span class="keyword">return</span> dateFormat;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring团队欢迎社区驱动的<strong><code>Formatter</code></strong>贡献，可以登陆网站<a href="https://jira.spring.io/browse/SPR" target="_blank" rel="external">jira.spring.io</a>了解如何参与贡献。 </p>
<h3 id="5-6-2-注解驱动的格式化"><a href="#5-6-2-注解驱动的格式化" class="headerlink" title="5.6.2 注解驱动的格式化"></a>5.6.2 注解驱动的格式化</h3><p>如你所见，字段格式化可以通过字段类型或者注解进行配置，要将一个注解绑定到一个格式化器，可以实现AnnotationFormatterFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	Set&lt;Class&lt;?&gt;&gt; getFieldTypes();</div><div class="line"></div><div class="line">	Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);</div><div class="line"></div><div class="line">	Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>泛型参数A代表你想要关联格式化逻辑的字段注解类型，例如<strong><code>org.springframework.format.annotation.DateTimeFormat</code></strong>。让<strong><code>getFieldTypes()</code></strong>方法返回可能使用注解的字段类型，让<strong><code>getPrinter()</code></strong>方法返回一个可以打印被注解字段的值的打印机(Printer)，让<strong><code>getParser()</code></strong>方法返回一个可以解析被注解字段的客户端值的解析器(Parser)。</p>
<p>下面这个AnnotationFormatterFactory实现的示例把@NumberFormat注解绑定到一个格式化器，此注解允许指定数字样式或模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFormatAnnotationFormatterFactory</span></span></div><div class="line">		<span class="keyword">implements</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">NumberFormat</span>&gt; &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;(asList(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;</div><div class="line">			Short.class, Integer.class, Long.class, Float.class,</div><div class="line">			Double.class, BigDecimal.class, BigInteger.class &#125;));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Printer&lt;Number&gt; <span class="title">getPrinter</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Parser&lt;Number&gt; <span class="title">getParser</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> Formatter&lt;Number&gt; <span class="title">configureFormatterFrom</span><span class="params">(NumberFormat annotation,</span></span></div><div class="line">			Class&lt;?&gt; fieldType) &#123;</div><div class="line">		<span class="keyword">if</span> (!annotation.pattern().isEmpty()) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> NumberFormatter(annotation.pattern());</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			Style style = annotation.style();</div><div class="line">			<span class="keyword">if</span> (style == Style.PERCENT) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> PercentFormatter();</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (style == Style.CURRENCY) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> CurrencyFormatter();</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> NumberFormatter();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要触发格式化，只需要使用@NumberFormat对字段进行注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyModel</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@NumberFormat</span>(style=Style.CURRENCY)</div><div class="line">	<span class="keyword">private</span> BigDecimal decimal;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Format-Annotation-API"><a href="#Format-Annotation-API" class="headerlink" title="Format Annotation API"></a>Format Annotation API</h4><p><strong><code>org.springframework.format.annotation</code></strong>包中存在一套可移植(portable)的格式化注解API。请使用@NumberFormat格式化java.lang.Number字段，使用@DateTimeFormat格式化java.util.Date、java.util.Calendar、<em>java.util.Long(注：此处可能是原文错误，应为java.lang.Long)</em>或者Joda Time字段。</p>
<p>下面这个例子使用@DateTimeFormat将java.util.Date格式化为ISO时间(yyyy-MM-dd)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyModel</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@DateTimeFormat</span>(iso=ISO.DATE)</div><div class="line">	<span class="keyword">private</span> Date date;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><span id="5.6.3 FormatterRegistry SPI"></span></p>
<h3 id="5-6-3-FormatterRegistry-SPI"><a href="#5-6-3-FormatterRegistry-SPI" class="headerlink" title="5.6.3 FormatterRegistry SPI"></a>5.6.3 FormatterRegistry SPI</h3><p>FormatterRegistry是一个用于注册格式化器和转换器的服务提供接口(SPI)。<strong><code>FormattingConversionService</code></strong>是一个适用于大多数环境的FormatterRegistry实现，可以以编程方式或利用<strong><code>FormattingConversionServiceFactoryBean</code></strong>声明成Spring bean的方式来进行配置。由于它也实现了<strong><code>ConversionService</code></strong>，所以可以直接配置它与Spring的DataBinder以及Spring表达式语言(SpEL)一起使用。</p>
<p>请查看下面的FormatterRegistry SPI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistry</span> <span class="keyword">extends</span> <span class="title">ConverterRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Formatter&lt;?&gt; formatter)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFormatterForAnnotation</span><span class="params">(AnnotationFormatterFactory&lt;?, ?&gt; factory)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上所示，格式化器可以通过字段类型或者注解进行注册。</p>
<p>FormatterRegistry SPI允许你集中地配置格式化规则，而不是在你的控制器之间重复这样的配置。例如，你可能要强制所有的时间字段以某种方式被格式化，或者是带有特定注解的字段以某种方式被格式化。通过一个共享的FormatterRegistry，你可以只定义这些规则一次，而在需要格式化的时候应用它们。</p>
<h3 id="5-6-4-FormatterRegistrar-SPI"><a href="#5-6-4-FormatterRegistrar-SPI" class="headerlink" title="5.6.4 FormatterRegistrar SPI"></a>5.6.4 FormatterRegistrar SPI</h3><p>FormatterRegistrar是一个通过FormatterRegistry注册格式化器和转换器的服务提供接口(SPI)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistrar</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerFormatters</span><span class="params">(FormatterRegistry registry)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当要为一个给定的格式化类别(比如时间格式化)注册多个关联的转换器和格式化器时，FormatterRegistrar会非常有用。</p>
<p>下一部分提供了更多关于转换器和格式化器注册的信息。</p>
<h3 id="5-6-5-在Spring-MVC中配置格式化"><a href="#5-6-5-在Spring-MVC中配置格式化" class="headerlink" title="5.6.5 在Spring MVC中配置格式化"></a>5.6.5 在Spring MVC中配置格式化</h3><p>请查看Spring MVC章节的<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-config-conversion" target="_blank" rel="external">Section 18.16.3 “Conversion and Formatting”</a>。 </p>
<h2 id="5-7-配置一个全局的日期-amp-时间格式"><a href="#5-7-配置一个全局的日期-amp-时间格式" class="headerlink" title="5.7 配置一个全局的日期&amp;时间格式"></a>5.7 配置一个全局的日期&amp;时间格式</h2><p>默认情况下，未被<strong><code>@DateTimeFormat</code></strong>注解的日期和时间字段会使用<strong><code>DateFormat.SHORT</code></strong>风格从字符串转换。如果你愿意，你可以定义你自己的全局格式来改变这种默认行为。</p>
<p>你将需要确保Spring不会注册默认的格式化器，取而代之的是你应该手动注册所有的格式化器。请根据你是否依赖Joda Time库来确定是使用<strong><code>org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</code></strong>类还是<strong><code>org.springframework.format.datetime.DateFormatterRegistrar</code></strong>类。</p>
<p>例如，下面的Java配置会注册一个全局的’yyyyMMdd’格式，这个例子不依赖于Joda Time库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Bean</span></div><div class="line">	<span class="function"><span class="keyword">public</span> FormattingConversionService <span class="title">conversionService</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">// Use the DefaultFormattingConversionService but do not register defaults</span></div><div class="line">		DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">		<span class="comment">// Ensure @NumberFormat is still supported</span></div><div class="line">		conversionService.addFormatterForFieldAnnotation(<span class="keyword">new</span> NumberFormatAnnotationFormatterFactory());</div><div class="line"></div><div class="line">		<span class="comment">// Register date conversion with a specific global format</span></div><div class="line">		DateFormatterRegistrar registrar = <span class="keyword">new</span> DateFormatterRegistrar();</div><div class="line">		registrar.setFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">"yyyyMMdd"</span>));</div><div class="line">		registrar.registerFormatters(conversionService);</div><div class="line"></div><div class="line">		<span class="keyword">return</span> conversionService;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你更喜欢基于XML的配置，你可以使用一个<strong><code>FormattingConversionServiceFactoryBean</code></strong>，这是同一个例子，但这次使用了Joda Time：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">		http://www.springframework.org/schema/beans</div><div class="line">		http://www.springframework.org/schema/beans/spring-beans.xsd&gt;</div><div class="line"></div><div class="line">	&lt;bean id="<span class="attr">conversionService</span>" <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"registerDefaultFormatters"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"formatters"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.number.NumberFormatAnnotationFormatterFactory"</span> /&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"formatterRegistrars"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormatter"</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean"</span>&gt;</span></div><div class="line">							<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"yyyyMMdd"</span>/&gt;</span></div><div class="line">						<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">					<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Joda Time提供了不同的类型来表示<strong><code>date</code></strong>、<strong><code>time</code></strong>和<strong><code>date-time</code></strong>的值，<strong><code>JodaTimeFormatterRegistrar</code></strong>中的<strong><code>dateFormatter</code></strong>、<strong><code>timeFormatter</code></strong>和<strong><code>dateTimeFormatter</code></strong>属性应该为每种类型配置不同的格式。<strong><code>DateTimeFormatterFactoryBean</code></strong>提供了一种方便的方式来创建格式化器。</p>
</blockquote>
<p>如果你在使用Spring MVC，请记住要明确配置所使用的转换服务。针对基于<strong><code>@Configuration</code></strong>的Java配置方式这意味着要继承<strong><code>WebMvcConfigurationSupport</code></strong>并且覆盖<strong><code>mvcConversionService()</code></strong>方法。针对XML的方式，你应该使用<strong><code>mvc:annotation-drive</code></strong>元素的<strong><code>&#39;conversion-service&#39;</code></strong>属性。更多细节请看<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-config-conversion" target="_blank" rel="external">Section 18.16.3 “Conversion and Formatting”</a>。 </p>
<p><span id="5.8 Spring Validation"></span></p>
<h2 id="5-8-Spring验证"><a href="#5-8-Spring验证" class="headerlink" title="5.8 Spring验证"></a>5.8 Spring验证</h2><p>Spring  3对验证支持引入了几个增强功能。首先，现在全面支持JSR-303 Bean Validation API；其次，当采用编程方式时，Spring的DataBinder现在不仅可以绑定对象还能够验证它们；最后，Spring MVC现在已经支持声明式地验证<strong><code>@Controller</code></strong>的输入。</p>
<h3 id="5-8-1-JSR-303-Bean-Validation-API概述"><a href="#5-8-1-JSR-303-Bean-Validation-API概述" class="headerlink" title="5.8.1 JSR-303 Bean Validation API概述"></a>5.8.1 JSR-303 Bean Validation API概述</h3><p>JSR-303对Java平台的验证约束声明和元数据进行了标准化定义。使用此API，你可以用声明性的验证约束对领域模型的属性进行注解，并在运行时强制执行它们。现在已经有一些内置的约束供你使用，当然你也可以定义你自己的自定义约束。</p>
<p>为了说明这一点，考虑一个拥有两个属性的简单的PersonForm模型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonForm</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JSR-303允许你针对这些属性定义声明性的验证约束：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonForm</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@NotNull</span></div><div class="line">	<span class="meta">@Size</span>(max=<span class="number">64</span>)</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="meta">@Min</span>(<span class="number">0</span>)</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当此类的一个实例被实现JSR-303规范的验证器进行校验的时候，这些约束就会被强制执行。</p>
<p>有关JSR-303/JSR-349的一般信息，可以访问网站<a href="http://beanvalidation.org/" target="_blank" rel="external">Bean Validation website</a>去查看。有关默认参考实现的具体功能的信息，可以参考网站<a href="http://hibernate.org/validator/" target="_blank" rel="external">Hibernate Validator</a>的文档。想要了解如何将Bean验证器提供程序设置为Spring bean，请继续保持阅读。</p>
<h3 id="5-8-2-配置Bean验证器提供程序"><a href="#5-8-2-配置Bean验证器提供程序" class="headerlink" title="5.8.2 配置Bean验证器提供程序"></a>5.8.2 配置Bean验证器提供程序</h3><p>Spring提供了对Bean Validation API的全面支持，这包括将实现JSR-303/JSR-349规范的Bean验证提供程序引导为Spring Bean的方便支持。这样就允许在应用程序任何需要验证的地方注入<strong><code>javax.validation.ValidatorFactory</code></strong>或者<strong><code>javax.validation.Validator</code></strong>。</p>
<p>把<strong><code>LocalValidatorFactoryBean</code></strong>当作Spring bean来配置成默认的验证器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"validator"</span></span></div><div class="line">	<span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"</span>/&gt;</div></pre></td></tr></table></figure>
<p>以上的基本配置会触发Bean Validation使用它默认的引导机制来进行初始化。作为实现JSR-303/JSR-349规范的提供程序，如Hibernate Validator，可以存在于类路径以使它能被自动检测到。</p>
<h4 id="注入验证器"><a href="#注入验证器" class="headerlink" title="注入验证器"></a>注入验证器</h4><p><strong><code>LocalValidatorFactoryBean</code></strong>实现了<strong><code>javax.validation.ValidatorFactory</code></strong>和<strong><code>javax.validation.Validator</code></strong>这两个接口，以及Spring的<strong><code>org.springframework.validation.Validator</code></strong>接口，你可以将这些接口当中的任意一个注入到需要调用验证逻辑的Bean里。</p>
<p>如果你喜欢直接使用Bean Validtion API，那么就注入<strong><code>javax.validation.Validator</code></strong>的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.validation.Validator;</div><div class="line"></div><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="keyword">private</span> Validator validator;</div></pre></td></tr></table></figure>
<p>如果你的Bean需要Spring Validation API，那么就注入<strong><code>org.springframework.validation.Validator</code></strong>的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.validation.Validator;</div><div class="line"></div><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="keyword">private</span> Validator validator;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="配置自定义约束"><a href="#配置自定义约束" class="headerlink" title="配置自定义约束"></a>配置自定义约束</h4><p>每一个Bean验证约束由两部分组成，第一部分是声明了约束和其可配置属性的<strong><code>@Constraint</code></strong>注解，第二部分是实现约束行为的<strong><code>javax.validation.ConstraintValidator</code></strong>接口实现。为了将声明与实现关联起来，每个<strong><code>@Constraint</code></strong>注解会引用一个相应的验证约束的实现类。在运行期间，<strong><code>ConstraintValidatorFactory</code></strong>会在你的领域模型遇到约束注解的情况下实例化被引用到的实现。</p>
<p>默认情况下，<strong><code>LocalValidatorFactoryBean</code></strong>会配置一个<strong><code>SpringConstraintValidatorFactory</code></strong>，其使用Spring来创建约束验证器实例。这允许你的自定义约束验证器可以像其他Spring bean一样从依赖注入中受益。</p>
<p>下面显示了一个自定义的<strong><code>@Constraint</code></strong>声明的例子，紧跟着是一个关联的<strong><code>ConstraintValidator</code></strong>实现，其使用Spring进行依赖注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.FIELD&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Constraint</span>(validatedBy=MyConstraintValidator.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyConstraint &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span>;</div><div class="line">	<span class="keyword">private</span> Foo aDependency;</div><div class="line"></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所见，一个约束验证器实现可以像其他Spring bean一样使用@Autowired注解来自动装配它的依赖。</p>
<h4 id="Spring驱动的方法验证"><a href="#Spring驱动的方法验证" class="headerlink" title="Spring驱动的方法验证"></a>Spring驱动的方法验证</h4><p>被Bean Validation 1.1以及作为Hibernate Validator 4.3中的自定义扩展所支持的方法验证功能可以通过配置<strong><code>MethodValidationPostProcessor</code></strong>的bean定义集成到Spring的上下文中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.MethodValidationPostProcessor"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>为了符合Spring驱动的方法验证，需要对所有目标类用Spring的<strong><code>@Validated</code></strong>注解进行注解，且有选择地对其声明验证组，这样才可以使用。请查阅<strong><code>MethodValidationPostProcessor</code></strong>的java文档来了解针对Hibernate Validator和Bean Validation 1.1提供程序的设置细节。</p>
<h4 id="附加配置选项"><a href="#附加配置选项" class="headerlink" title="附加配置选项"></a>附加配置选项</h4><p>对于大多数情况，默认的<strong><code>LocalValidatorFactoryBean</code></strong>配置应该足够。有许多配置选项来处理从消息插补到遍历解析的各种Bean验证结构。请查看<strong><code>LocalValidatorFactoryBean</code></strong>的java文档来获取关于这些选项的更多信息。</p>
<p><span id="5.8.3 Configuring a DataBinder"></span></p>
<h3 id="5-8-3-配置DataBinder"><a href="#5-8-3-配置DataBinder" class="headerlink" title="5.8.3 配置DataBinder"></a>5.8.3 配置DataBinder</h3><p>从Spring 3开始，DataBinder的实例可以配置一个验证器。一旦配置完成，那么可以通过调用<strong><code>binder.validate()</code></strong>来调用验证器，任何的验证错误都会自动添加到DataBinder的绑定结果(BindingResult)。</p>
<p>当以编程方式处理DataBinder时，可以在绑定目标对象之后调用验证逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Foo target = <span class="keyword">new</span> Foo();</div><div class="line">DataBinder binder = <span class="keyword">new</span> DataBinder(target);</div><div class="line">binder.setValidator(<span class="keyword">new</span> FooValidator());</div><div class="line"></div><div class="line"><span class="comment">// bind to the target object</span></div><div class="line">binder.bind(propertyValues);</div><div class="line"></div><div class="line"><span class="comment">// validate the target object</span></div><div class="line">binder.validate();</div><div class="line"></div><div class="line"><span class="comment">// get BindingResult that includes any validation errors</span></div><div class="line">BindingResult results = binder.getBindingResult();</div></pre></td></tr></table></figure>
<p>通过<strong><code>dataBinder.addValidators</code></strong>和<strong><code>dataBinder.replaceValidators</code></strong>，一个DataBinder也可以配置多个<strong><code>Validator</code></strong>实例。当需要将全局配置的Bean验证与一个DataBinder实例上局部配置的Spring <strong><code>Validator</code></strong>结合时，这一点是非常有用的。</p>
<h3 id="5-8-4-Spring-MVC-3-验证"><a href="#5-8-4-Spring-MVC-3-验证" class="headerlink" title="5.8.4 Spring MVC 3 验证"></a>5.8.4 Spring MVC 3 验证</h3><p>请查看Spring MVC章节的<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-config-validation" target="_blank" rel="external">Section 18.16.4 “Validation”</a>。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发布于并发编程网，文章&lt;a href=&quot;http://ifeve.com/spring-5-validation/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-1-介绍&quot;&gt;&lt;a href=&quot;#5-1-介绍&quot; class=&quot;headerlink&quot; title=&quot;5.1 介绍&quot;&gt;&lt;/a&gt;5.1 介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;JSR-303/JSR-349 Bean Validation&lt;/p&gt;
&lt;p&gt;在设置支持方面，Spring Framework 4.0支持Bean Validation 1.0(JSR-303)和Bean Validation 1.1(JSR-349)，也将其改写成了Spring的&lt;strong&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/strong&gt;接口。&lt;/p&gt;
&lt;p&gt;正如&lt;a href=&quot;#5.8 Spring Validation&quot;&gt;5.8 Spring验证&lt;/a&gt;所述，应用程序可以选择一次性全局启用Bean验证，并使其专门用于所有的验证需求。&lt;/p&gt;
&lt;p&gt;正如&lt;a href=&quot;#5.8.3 Configuring a DataBinder&quot;&gt;5.8.3 配置DataBinder&lt;/a&gt;所述，应用程序也可以为每个&lt;strong&gt;&lt;code&gt;DataBinder&lt;/code&gt;&lt;/strong&gt;实例注册额外的Spring &lt;strong&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/strong&gt;实例，这可能有助于不通过使用注解而插入验证逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://lukaicheng.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读总结--ArrayList</title>
    <link href="https://lukaicheng.github.io/2016/11/17/Reading-JDK-ArrayList/"/>
    <id>https://lukaicheng.github.io/2016/11/17/Reading-JDK-ArrayList/</id>
    <published>2016-11-17T07:26:10.000Z</published>
    <updated>2017-05-17T02:16:56.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure>
<p>ArrayList是List接口的一种可变长的数组实现，支持随机访问，它允许添加包括<strong>null</strong>在内的所有元素。另外，ArrayList的实现并不是线程安全的，如果有多个线程访问，且其中至少一个会涉及<strong>结构性修改</strong>，最好采用并发控制策略，或者采用<em>Collections.synchronizedList</em>进行包装，防止意外的非同步访问。以下所述基于JDK1.7.0_79源码。</p>
<a id="more"></a>
<h2 id="2-基本属性"><a href="#2-基本属性" class="headerlink" title="2 基本属性"></a>2 基本属性</h2><h3 id="2-1-elementData"><a href="#2-1-elementData" class="headerlink" title="2.1 elementData"></a>2.1 elementData</h3><p><strong>elementData</strong>属性是实际存储列表元素的数组缓存区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>
<p>尽管从声明上看它是数组类型，然而它的长度却并不固定，这里的意思并不说是可以在数组创建之后再改变它的大小，而是指当进行容量评估时，如果发现需要扩容或者收缩，那么会重新创建一个数组并伴随一次拷贝，然后将<strong>elementData</strong>指向新数组，从而达到扩容或者收缩的目的。</p>
<h3 id="2-2-size"><a href="#2-2-size" class="headerlink" title="2.2 size"></a>2.2 size</h3><p><strong>size</strong>属性就是列表实际所包含的元素个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>这是因为一般情况下，<strong>elementData</strong>数组并不会被完全占满，所以无法用数组长度等价于元素个数，而又需要有一种机制能够快速反馈元素个数，因此设置了<strong>size</strong>属性来缓存这个信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>size()</strong>方法和<strong>isEmpty()</strong>方法就是通过它才保证调用只需花费常数时间。</p>
<h2 id="3-容量调整"><a href="#3-容量调整" class="headerlink" title="3 容量调整"></a>3 容量调整</h2><h3 id="3-1-扩容"><a href="#3-1-扩容" class="headerlink" title="3.1 扩容"></a>3.1 扩容</h3><p>在新版本JDK中，ArrayList不仅像之前一样拥有私有的动态扩容方法，同时还对外提供了公有方法供调用者主动进行扩容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY,minCapacity);</div><div class="line">    &#125;</div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上所示，<strong>ensureCapacity()</strong>是供外部主动扩容调用的方法，<strong>ensureCapacityInternal()</strong>是供内部扩容调用的方法。这两个方法都是先预估出所需的最小容量，进而通过调用私有方法<strong>ensureExplicitCapacity()</strong>来保证这个容量需求得以满足。接下来看一下这个方法的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span>(minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//扩容到1.5倍</span></div><div class="line">    <span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span>(newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) <span class="comment">//overflow处理</span></div><div class="line">	    newCapacity = hugeCapacity(minCapacity);</div><div class="line">    elementData = Arrays.copyOf(elementData,newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(minCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? </div><div class="line">        Integer.MAX_VALUE : </div><div class="line">        MAX_ARRAY_SIZE; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ensureExplicitCapacity()</strong>方法会首先判定所需的最小容量是否超过当前数组长度，只有在肯定的情况下，才会调用<strong>grow()</strong>方法。观察此方法代码，首先默认将原先的数组长度扩充到1.5倍，接着将新容量与最小容量比较，如果发现新容量小于最小容量，那么将会把新容量赋值为最小容量。而后则是对容量扩充到1.5倍时可能发生的int值溢出的情况，进行一些处理。最后才是真正的进行新数组创建，旧数组元素拷贝的过程。</p>
<h3 id="3-2-收缩"><a href="#3-2-收缩" class="headerlink" title="3.2 收缩"></a>3.2 收缩</h3><p>由于列表在增加元素的时候会进行隐式扩容，从而导致底层数组容量往往超过实际所包含的元素，如果碰到资源敏感的场景下，那么可以使用<strong>trimToSize()</strong>方法进行收缩，使得底层数组容量和实际元素个数持平。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span></span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span>(size &lt; elementData.length)&#123;</div><div class="line">        elementData = Arrays.copyOf(elementData,size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-异常检测"><a href="#4-异常检测" class="headerlink" title="4 异常检测"></a>4 异常检测</h2><h3 id="4-1-rangeCheck"><a href="#4-1-rangeCheck" class="headerlink" title="4.1 rangeCheck"></a>4.1 rangeCheck</h3><p>针对索引范围的检查，ArrayList提供了两个版本的方法：<strong>rangeCheck()</strong>和<strong>rangeCheckForAdd()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index &gt;= size)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>rangeCheck()</strong>主要是针对<em>get()、set()、remove()</em>方法进行索引检测，注意到上面代码并没有对index为负的情况进行检测，这是因为紧跟本方法调用的是对底层数组的访问，而后者会直接检测索引为负的情况，但另外一方面由于隐式扩容的缘故，底层数组包含的实际元素个数往往小于数组长度，因此针对索引超出的情况只能在本方法里判定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>顾名思义，<strong>rangeCheckForAdd()</strong>方法在运行时会被<em>add()、addAll()</em>所调用。相比<strong>rangeCheck()</strong>方法，由于后续不是紧跟对底层数组的访问，因此增加了对于索引为负的情况的判定，同时因为允许元素可以末端添加，去掉了index = size这种情况。</p>
<h3 id="4-2-modCount"><a href="#4-2-modCount" class="headerlink" title="4.2 modCount"></a>4.2 modCount</h3><p><strong>modCount</strong>是ArrayList从父类AbstractList从继承过来的属性，这个属性用于记录列表经历的结构性修改的次数，主要被迭代器(<a href="#61-iterator">iterator</a>和<a href="#62-listiterator">listIterator</a>)使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>迭代器借助于它可以提供fast-fail行为，即当迭代器进行迭代时，如果检测它的值被意外修改，可以抛出ConcurrentModificationException异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount) <span class="comment">//与预期不符合，抛出异常</span></div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="5-增删改查"><a href="#5-增删改查" class="headerlink" title="5 增删改查"></a>5 增删改查</h2><h3 id="5-1-set-amp-get"><a href="#5-1-set-amp-get" class="headerlink" title="5.1 set &amp; get"></a>5.1 set &amp; get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>&#123;</div><div class="line">	rangeCheck(index);</div><div class="line">  	E oldValue = elementData(index);</div><div class="line">  	elementData[index] = element;</div><div class="line">  	<span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">  	rangeCheck(index);</div><div class="line">  	<span class="keyword">return</span> elementData(index);</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">  	reurn (E)elementData[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>众所周知，ArrayList的<strong>set()</strong>和<strong>get()</strong>方法均是常数消耗的操作，这是由于底层元素存储依赖于数组，因而在元素获取时可以直接利用数组随机访问的能力，这一点看上面的源码正好可以印证。</p>
<h3 id="5-2-add"><a href="#5-2-add" class="headerlink" title="5.2 add"></a>5.2 add</h3><p>在一般情况下，从算法分析的角度上说ArrayList的元素添加操作时间复杂度是O(n)，这是因为在当前元素添加元素，往往需要将原先在当前位置的元素以及后续元素，往后移动一位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;</div><div class="line">	rangeCheckForAdd(index);</div><div class="line">  	ensureCapacityInternal(size+<span class="number">1</span>);</div><div class="line">  	System.arraycopy(elementData,index,elementData,index+<span class="number">1</span>,size-index);</div><div class="line">  	elementData[index] = element;</div><div class="line">  	size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，针对只在末尾添加元素的场景，ArrayList做了特别处理，不需要移动元素位置，直接快速赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</div><div class="line">  	ensureCapacityInternal(size+<span class="number">1</span>);</div><div class="line">  	elementData[size++] = e;</div><div class="line">  	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是别忘记，不管是一般情况还是特殊情况，最开始都会进行容量检测，这里可能又是一次元素拷贝的开销，因此在容量预知的情况下，应该在ArrayList实例化的时候指定容量。</p>
<h3 id="5-3-remove"><a href="#5-3-remove" class="headerlink" title="5.3 remove"></a>5.3 remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">	rangeCheck(index);</div><div class="line">	modCount++;</div><div class="line">	E oldValue = elementData(index);<span class="comment">//elementData方法在5.1代码示例给出</span></div><div class="line">  	<span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;<span class="comment">//计算需要移动的元素个数</span></div><div class="line"> 	<span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)</div><div class="line">    	System.arraycopy(elementData,index+<span class="number">1</span>,elementData,index,numMoved);  </div><div class="line"> 	elementData[--size] = <span class="keyword">null</span>;<span class="comment">//实际元素个数-1且将原先末尾置空便于GC </span></div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同<strong>add()</strong>方法类似，<strong>remove()</strong>则是将被删除元素的后续元素前移了一位，达到删除元素的目的，可以看到，同样也是需要一次数组元素的拷贝。另外，还注意到modCount值发生了改变，这是因为<strong>remove()</strong>是一种结构性的修改。</p>
<h2 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="6 迭代器"></a>6 迭代器</h2><h3 id="6-1-iterator"><a href="#6-1-iterator" class="headerlink" title="6.1 iterator"></a><span id="61-iterator">6.1 iterator</span></h3><p>ArrayList声明了内部类<strong>Itr</strong>实现了Iterator接口,通过方法<strong>iterator()</strong>对外提供该迭代器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Itr</strong>在内部定义了三个属性：<strong>cursor</strong>用于表示下一个元素的索引，默认初始为0；<strong>lastRet</strong>用于表示上一个返回元素的索引，初始为-1；<strong>expectedModCount</strong>用于表示期望的修改次数，初始为迭代器实例化时外部列表的modCount值。对于<strong>hasNext()</strong>方法，只要判定<strong>cursor</strong>是否已经和当前列表的<strong>size</strong>相同，即可判定是否还存在下一个元素。对于<strong>next()</strong>方法，由于已经知道需要返回的元素的索引(cursor)，那么可以直接通过数组索引访问获取元素，当然对于索引的校验以及列表的结构修改检测也是必须的，且同时需要更新cursor和lastRet。下面主要详细看下<strong>remove()</strong>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">    checkForComodification();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);<span class="comment">//后续元素前移 &amp; modCount++</span></div><div class="line">        cursor = lastRet;<span class="comment">//元素前移，当前位置的元素的索引发生变化</span></div><div class="line">        lastRet = -<span class="number">1</span>;<span class="comment">//只有在next重新调用之后，才能再次调用remove</span></div><div class="line">        expectedModCount = modCount;<span class="comment">//由于modCount变化，需要重新赋值</span></div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Remove()</strong>方法首先对lastRet进行了检验，结合后续代码中对于lastRet赋值为-1的情况和<strong>next()</strong>方法实现情况，可以知道<strong>remove()</strong>方法只有在<strong>next()</strong>方法被调用一次才能调用并且不能连续连续调用<strong>remove()</strong>方法。接着是上面已经提过的modCount检测。然后才是真正的remove操作，它是通过调用外部对象的remove方法来实现移除最近返回的元素。但是这里要注意的是，调用这个方法，会有两个<strong>“副作用”</strong>：一，被移除元素的后续元素都会前移一位；二，modCount将会+1。因此在最后的代码中，才会看见cursor和expectedModCount被重新赋值，这实质上是为了抵消这两个副作用的影响。</p>
<h3 id="6-2-listIterator"><a href="#6-2-listIterator" class="headerlink" title="6.2 listIterator"></a><span id="62-listiterator">6.2 listIterator</span></h3><p>除了一般版本的迭代器，ArrayList还提供了listIterator，与一般版本相比，不仅可以往后进行迭代，还可以向前迭代。外部可以通过<strong>listIterator()</strong>方法获取该迭代器，该方法返回<strong>ListItr</strong>内部类的一个实例，<strong>ListItr</strong>继承关系如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ListItr</strong>继承了<strong>Itr</strong>，在<em>hasNext()、next()、remove()</em>这几个方法的实现上，并未改变其父类中的行为，仅仅是对<em>hasPrevious()、previous()、nextIndex()、previousIndex()、set()、add()</em>方法进行了实现。<strong>nextIndex()</strong>和<strong>previousIndex()</strong>两个方法都可以直接借助cursor属性进行返回。<strong>hasPrevious()</strong>方法同<strong>hasNext()</strong>实现类似，只不过这次是需要判定cursor是否同0相同,即可判断出是否还存在上一个元素。同样，对于<strong>previous()</strong>方法可参考<strong>next()</strong>，只不过需要返回的是数据中cursor-1位置的数据。<strong>set()</strong>方法则是简单的调用了外部列表的<strong>set()</strong>方法。最后主要来讲一下<strong>add()</strong>方法的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    checkForComodification();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = cursor;</div><div class="line">        ArrayList.<span class="keyword">this</span>.add(i, e);<span class="comment">//当前位置元素以及之后元素后移 &amp; modCount++</span></div><div class="line">        cursor = i + <span class="number">1</span>;<span class="comment">//重新赋值当前游标的值</span></div><div class="line">        lastRet = -<span class="number">1</span>;<span class="comment">//保证只有在next或者previous之后，才能重新调用set方法</span></div><div class="line">        expectedModCount = modCount;<span class="comment">//由于modCount变化，需要重新赋值</span></div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Add()</strong>方法首先照例进行列表结构性修改检测，接着实际上调用了外部ArrayList对象的add方法来进行元素添加，类似的，这个调用也会产生两个<strong>“副作用”</strong>：一、原有当前位置以及之后的元素被后移一位；二、modCount将会+1。因此，在后续代码中可以看到对cursor进行了+1操作，同时将新的modCount值赋予expectedModCount。</p>
<h2 id="7-子列表"><a href="#7-子列表" class="headerlink" title="7 子列表"></a>7 子列表</h2><p>ArrayList对外暴露了<strong>subList()</strong>方法来提供子列表的功能，但是子列表并不是重新创建的列表对象，它仅仅只是一个<em>视图</em>。<strong>SubList</strong>内部实际保存了父列表的对象引用，并定义了<strong>parentOffset</strong>和<strong>offset</strong>两个偏移量。其中<strong>parentOffset</strong>表示子列表相对于父列表的偏移量，<strong>offset</strong>表示子列表相对于根列表的偏移量。在实际调用时，子列表的<em>get()、set()</em>方法会通过使用<strong>offset</strong>来快速进行索引，而<em>add()、remove()</em>方法则会借助父对象引用和<strong>parentOffset</strong>来调用父类相应方法实现子列表的相应功能。</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/subList.png" alt="offset说明"></p>
<p>由于子列表和父列表实质上是共用同一份底层数据，那么对于子列表进行的元素添加、删除操作，父列表上也同样会得到体现，然而从反方向看却需要警惕，如果对父列表进行元素添加、删除等涉及结构性修改的操作，会导致已生成的子列表变成不可用(这是因为modCount机制导致)。</p>
<h2 id="8-序列化"><a href="#8-序列化" class="headerlink" title="8 序列化"></a>8 序列化</h2><p>从ArrayList的类声明中可以知道其实现了<strong>Serializable</strong>接口，能够序列化和反序列化，然而细心的可能已经发现<strong>elementData</strong>属性却是被transient修饰，但是实际序列化过程中，元素数据却并没有丢失。其实，这是因为<strong>elementData</strong>数组实际长度往往大于实际元素个数，如果直接采用默认序列化方式，那么其实除了会序列化实际元素之外，还会去序列化数组的剩余空间，并且在反序列化的时候会浪费额外空间来存储。所以，通过实现了<strong>writeObject()</strong>和<strong>readObject</strong>，ArrayList实现了自定义的序列化和反序列化过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">	<span class="keyword">throws</span> java.io.IOException&#123;</div><div class="line">        <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line">        s.defaultWriteObject();</div><div class="line">        s.writeInt(size);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">            s.writeObject(elementData[i]);<span class="comment">//根据实际size序列化数据</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></div><div class="line">	<span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</div><div class="line">        elementData = EMPTY_ELEMENTDATA;</div><div class="line">        s.defaultReadObject();</div><div class="line">        s.readInt();</div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</div><div class="line">            ensureCapacityInternal(size);</div><div class="line">            Object[] a = elementData;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">                a[i] = s.readObject();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从实际的源码不难看出，在实际序列化过程中，通过size来确定实际元素并逐个序列化，从而避免序列化不必要的元素，这不仅效率更高，且在反序列化重新构建ArrayList时可以给<strong>elementData</strong>设置合适的容量，避免空间浪费。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html" target="_blank" rel="external">ArrayList API</a></p>
<p><a href="http://stackoverflow.com/questions/38950203/why-does-arraylistrangecheck-not-check-if-the-index-is-negative" target="_blank" rel="external">why-does-arraylistrangecheck-not-check-if-the-index-is-negative</a></p>
<p><a href="http://stackoverflow.com/questions/9848129/why-does-arraylist-use-transient-storage" target="_blank" rel="external">why-does-arraylist-use-transient-storage</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;1 简介&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;RandomAccess&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Cloneable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ArrayList是List接口的一种可变长的数组实现，支持随机访问，它允许添加包括&lt;strong&gt;null&lt;/strong&gt;在内的所有元素。另外，ArrayList的实现并不是线程安全的，如果有多个线程访问，且其中至少一个会涉及&lt;strong&gt;结构性修改&lt;/strong&gt;，最好采用并发控制策略，或者采用&lt;em&gt;Collections.synchronizedList&lt;/em&gt;进行包装，防止意外的非同步访问。以下所述基于JDK1.7.0_79源码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java collections framework" scheme="https://lukaicheng.github.io/tags/Java-collections-framework/"/>
    
  </entry>
  
  <entry>
    <title>ABNF应知应会</title>
    <link href="https://lukaicheng.github.io/2016/11/02/ABNF/"/>
    <id>https://lukaicheng.github.io/2016/11/02/ABNF/</id>
    <published>2016-11-02T03:38:02.000Z</published>
    <updated>2017-05-17T02:16:43.999Z</updated>
    
    <content type="html"><![CDATA[<p>ABNF英文全称是Augmented Backus-Naur Form，这是一种基于BNF的元语言，在很多的Internet technical Specification中用于定义正式语法。</p>
<a id="more"></a>
<h2 id="1-规则定义"><a href="#1-规则定义" class="headerlink" title="1 规则定义"></a>1 规则定义</h2><h3 id="1-1-规则形式"><a href="#1-1-规则形式" class="headerlink" title="1.1 规则形式"></a>1.1 规则形式</h3><p>规则定义的形式如下所示</p>
<blockquote>
<p>name = elements crlf</p>
</blockquote>
<p>其中</p>
<ul>
<li>name 表示规则名称，对于它的解释可以参考<a href="#12-规则名称">1.2 规则名称</a>，</li>
<li>elements 可以是一个或者多个规则或者最终值的操作组合，关于最终值可以参考<a href="#13-最终值">1.3 最终值</a></li>
<li>crlf 行结束标志(回车换行)</li>
</ul>
<p>为了视觉效果，规则定义需要左对齐，如果碰上一个规则需要多行的情况，那么接下来的行需要缩进，而它们对齐和缩进的基准是ABNF规则的第一行。</p>
<h3 id="1-2-规则名称"><a href="#1-2-规则名称" class="headerlink" title="1.2 规则名称"></a><span id="12-规则名称">1.2 规则名称</span></h3><p>规则名称由字母开头，后续可以包含字母、数字和连字符(减号)组合的序列,其中需要注意的是规则名称<strong>不区分大小写</strong>。而且不像BNF，用尖括号(<strong>&lt;</strong>，<strong>&gt;</strong>)包围规则名称并不是必需的。</p>
<h3 id="1-3-最终值"><a href="#1-3-最终值" class="headerlink" title="1.3 最终值"></a><span id="13-最终值">1.3 最终值</span></h3><p>所有规则最终都会由最终值来解释，而所谓的最终值是由一个指定的基数再结合一个或者多个数值字符来指定。当前已经定义的基数有三种：</p>
<ul>
<li>b： 二进制 binary</li>
<li>d： 十进制 decimal</li>
<li>x： 十六进制 hexadecimal</li>
</ul>
<p>以回车CR为例，下面的规则分别采用十进制和十六进制为基数</p>
<blockquote>
<p>CR = %d13</p>
<p>CR = %x0D</p>
</blockquote>
<p>当碰到需要表示多个字符时，可以用<strong>“.”</strong>来进行串联</p>
<blockquote>
<p>false = %x66.61.6c.73.65</p>
</blockquote>
<p>同时ABNF也允许使用双引号来直接说明文字文本</p>
<blockquote>
<p>command = “pwd”</p>
</blockquote>
<p>但是需要注意的是，这里字符串是大小写不敏感，且使用的字符集是US-ASCII。因此上面的字符串会匹配”pwd”,”Pwd”,”pWd”,”pwD”,”PWd”,”pWD”,”PwD”和”PWD”。如果我们需要字符串具备大小写敏感特性，那么可以分别指定每个字符，有下面两种方式:</p>
<blockquote>
<p>command = %d112.119.100</p>
<p>command = %d112 %d119 %d109</p>
</blockquote>
<h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h2><h3 id="2-1-级联-R1-R2"><a href="#2-1-级联-R1-R2" class="headerlink" title="2.1 级联 R1 R2"></a>2.1 级联 R1 R2</h3><p>可以将已经定义的规则和最终值按顺序列出来，元素之间用空白字符来进行区分。</p>
<blockquote>
<p>foo = %x61</p>
<p>bar = %x62</p>
<p>mumble = foo bar foo</p>
</blockquote>
<p>在上面的示例里规则foo匹配a，bar匹配b，mumble将匹配aba。</p>
<h3 id="2-2-选择-R1-R2"><a href="#2-2-选择-R1-R2" class="headerlink" title="2.2 选择 R1 / R2"></a>2.2 选择 R1 / R2</h3><p>可以通过在规则之间插入/，让规则变成可选。</p>
<blockquote>
<p>ws = %x20 / %x09 / %x0A / %x0D</p>
</blockquote>
<p>在上面的示例里，规则ws会匹配空格、制表符、换行、回车。</p>
<h3 id="2-3-增量选择-R1-R2"><a href="#2-3-增量选择-R1-R2" class="headerlink" title="2.3 增量选择 R1 =/ R2"></a>2.3 增量选择 R1 =/ R2</h3><p>有时候，我们可能希望有一种增量的方式，可以在旧规则里添加新的功能可选项，这个时候增量选择就比较适用，它通过<strong>=/</strong>来将新规则变成旧规则的可选项之一。</p>
<blockquote>
<p>ruleset = alt1 / alt2</p>
<p>ruleset =/ alt3</p>
<p>ruleset =/ alt4 / alt5</p>
</blockquote>
<p>最终ruleset等价于下面所示：</p>
<blockquote>
<p>ruleset = alt1 / alt2 / alt3 / alt4 / alt5</p>
</blockquote>
<h3 id="2-4-值范围"><a href="#2-4-值范围" class="headerlink" title="2.4 值范围"></a>2.4 值范围</h3><p>通过使用连字符(-),ABNF还可以实现指定一个范围的值。</p>
<blockquote>
<p>DIGIT = %x30-39</p>
</blockquote>
<p>上面的示例规则，实际上等价于下面的规则</p>
<blockquote>
<p>DIGIT = “0” / “1” / “2” / “3” / “4” / “5” / “6” / “7” / “8” / “9”</p>
</blockquote>
<h3 id="2-5-序列组合-R1-R2"><a href="#2-5-序列组合-R1-R2" class="headerlink" title="2.5 序列组合 (R1 R2)"></a>2.5 序列组合 (R1 R2)</h3><p>用括号将连个规则包围起来，这样的组合会被当成单个元素，对于一些优先级比较容易混淆的情况尤其推荐使用它。</p>
<blockquote>
<p>group = elem (foo / bar) blat</p>
</blockquote>
<p>上面的示例会匹配 elem foo blat 或者 elem bar blat，但是如果我们不使用括号的话</p>
<blockquote>
<p>group = elem foo / bar blat</p>
</blockquote>
<p>由于操作符优先级的关系，其实group会匹配elem foo或bar blat。</p>
<h3 id="2-6-不定量重复-Rule"><a href="#2-6-不定量重复-Rule" class="headerlink" title="2.6 不定量重复 *Rule"></a>2.6 不定量重复 *Rule</h3><p>我们可以在规则的前面添加*，来表示重复这个规则，完整的形式是m*nRule。其中m和n都是可选的，m表示至少重复多少次，n表示最多重复多少次。两者默认的值分别是0和无穷大，所以*Rule表示允许任意次数的重复包括零次。1*Rule表示规则至少重复一次，1*2Rule表示规则重复一次或两次,3*3Rule表示规则必须且仅允许重复3次。</p>
<h3 id="2-7-定量重复-nRule"><a href="#2-7-定量重复-nRule" class="headerlink" title="2.7 定量重复 nRule"></a>2.7 定量重复 nRule</h3><p>除了不定量重复之外，ABNF也允许指定次数的重复，完整形式是nRule，其实等价于n*nRule。运用这个方式，2DIGIT就表示2位数字，3ALPHA表示长度为3的字符串。</p>
<h3 id="2-8-可选序列-Rule"><a href="#2-8-可选序列-Rule" class="headerlink" title="2.8 可选序列 [Rule]"></a>2.8 可选序列 [Rule]</h3><p>可以使用方括号来圈定一个可选序列</p>
<blockquote>
<p>rule = [foo bar]</p>
</blockquote>
<p>等价于</p>
<blockquote>
<p>rule = *1(foo bar)</p>
</blockquote>
<h3 id="2-9-注释"><a href="#2-9-注释" class="headerlink" title="2.9 注释"></a>2.9 注释</h3><p>对于规则的说明，也提供了注释方式，以分号<strong>;</strong>开始，并到此行的结束。</p>
<blockquote>
<p>false = %x66.61.6c.73.65   ; false</p>
</blockquote>
<h2 id="3-操作优先级"><a href="#3-操作优先级" class="headerlink" title="3.操作优先级"></a>3.操作优先级</h2><p>以下给出了从高(结合最紧密)到低(结合最松散)的优先级:</p>
<ol>
<li>规则名、最终值</li>
<li>注释</li>
<li>值范围</li>
<li>重复</li>
<li>序列组合、可选序列</li>
<li>级联</li>
<li>选择</li>
</ol>
<p>由于级联和选择混用时，往往会让人困惑，建议使用序列组合来消除歧义。</p>
<h2 id="4-核心规则"><a href="#4-核心规则" class="headerlink" title="4.核心规则"></a>4.核心规则</h2><table>
<thead>
<tr>
<th style="text-align:left">规则</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ALPHA</td>
<td style="text-align:left">%x41-5A / %x61-7A</td>
<td style="text-align:left">A-Z / a-z</td>
</tr>
<tr>
<td style="text-align:left">BIT</td>
<td style="text-align:left">“0” / “1”</td>
<td style="text-align:left">二进制字符</td>
</tr>
<tr>
<td style="text-align:left">CHAR</td>
<td style="text-align:left">%x01-7F</td>
<td style="text-align:left">任何7位的US-ASCII字符，不包括Nul(%x00)</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR</td>
<td style="text-align:left">%x21-7E</td>
<td style="text-align:left">可见(可打印)字符</td>
</tr>
<tr>
<td style="text-align:left">CR</td>
<td style="text-align:left">%x0D</td>
<td style="text-align:left">回车</td>
</tr>
<tr>
<td style="text-align:left">LF</td>
<td style="text-align:left">%x0A</td>
<td style="text-align:left">换行</td>
</tr>
<tr>
<td style="text-align:left">CRLF</td>
<td style="text-align:left">CR LF</td>
<td style="text-align:left">回车换行</td>
</tr>
<tr>
<td style="text-align:left">CTL</td>
<td style="text-align:left">%x00-1F / %x7F</td>
<td style="text-align:left">控制字符</td>
</tr>
<tr>
<td style="text-align:left">DIGIT</td>
<td style="text-align:left">%x30-39</td>
<td style="text-align:left">数字0-9</td>
</tr>
<tr>
<td style="text-align:left">DQUOTE</td>
<td style="text-align:left">%x22</td>
<td style="text-align:left">双引号</td>
</tr>
<tr>
<td style="text-align:left">HEXDIG</td>
<td style="text-align:left">DIGIT / “A” / “B” / “C” / “D” / “E” / “F”</td>
<td style="text-align:left">十六进制字符</td>
</tr>
<tr>
<td style="text-align:left">OCTET</td>
<td style="text-align:left">%x00-FF</td>
<td style="text-align:left">8位数据</td>
</tr>
<tr>
<td style="text-align:left">HTAB</td>
<td style="text-align:left">%x09</td>
<td style="text-align:left">横向制表符</td>
</tr>
<tr>
<td style="text-align:left">SP</td>
<td style="text-align:left">%x20</td>
<td style="text-align:left">空格</td>
</tr>
<tr>
<td style="text-align:left">WSP</td>
<td style="text-align:left">SP / HTAB</td>
<td style="text-align:left">空格或者横向制表符</td>
</tr>
<tr>
<td style="text-align:left">LWSP</td>
<td style="text-align:left">*(WSP / CRLF WSP)</td>
<td style="text-align:left">空白行(不要用于邮件头，另外在其他上下文中使用也需要小心)</td>
</tr>
</tbody>
</table>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://tools.ietf.org/html/rfc5234" target="_blank" rel="external">RFC 5234</a><br><a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%85%85%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F" target="_blank" rel="external">维基百科 扩充巴科斯范式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ABNF英文全称是Augmented Backus-Naur Form，这是一种基于BNF的元语言，在很多的Internet technical Specification中用于定义正式语法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RCFile文件格式下的Hive表bigint类型列值读取问题</title>
    <link href="https://lukaicheng.github.io/2016/10/25/Hive-VLong-to-Java-long/"/>
    <id>https://lukaicheng.github.io/2016/10/25/Hive-VLong-to-Java-long/</id>
    <published>2016-10-25T02:25:39.000Z</published>
    <updated>2017-05-17T02:16:30.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景缘起"><a href="#背景缘起" class="headerlink" title="背景缘起"></a>背景缘起</h2><p>目前在将hive部分列数据采集到hbase时，由于平台将原来hive表的文件格式从SequenceFile调整到RCFile，因此需要对原来的离线数据采集程序进行修改。然而在实际修改开发过程中，却碰到了程序读取hive列字段，值为乱码的问题。</p>
<a id="more"></a>
<h2 id="初步诊断"><a href="#初步诊断" class="headerlink" title="初步诊断"></a>初步诊断</h2><p>由于之前的文件格式是SequenceFile，不管列在hive中数据类型是什么，程序都可以以统一的读取String方式来读取。因此在变更为RCFile方式时，仅仅调整了输入部分，转换依然采用了Bytes.toString方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convertHiveBigint</span><span class="params">(BytesRefWritable brw)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    <span class="keyword">return</span> Bytes.toString(brw.getData(),brw.getStart(),brw.getLength());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是针对乱码的字段，查看了hive表对应列的数据类型，发现是Bigint，那么我想可能不仅仅需要调整输入，最终转换的地方也需要调整为Bytes.toLong。于是将代码修改如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">convertHiveBigint</span><span class="params">(BytesRefWritable brw)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    <span class="keyword">return</span> Bytes.toLong(brw.getData(),brw.getStart(),brw.getLength());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="奇怪的-118"><a href="#奇怪的-118" class="headerlink" title="奇怪的-118"></a>奇怪的-118</h2><p>就在我以为上面的修改可以奏效之时，实际运行时却抛出了鲜红的异常</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/exception.png" alt="异常信息"></p>
<p>从异常信息里不难看出，对于Java long来说，已经规定是需要8个字节，然而在上面代码里，最终转换时确变成了7个字节。为此，对程序进行了调试，将原始的brw.getData打印了出来</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/bytesarray.png" alt="原始字节数据"></p>
<p>结合调试得到的offset和length值，获知到程序真实运行时取值为 <strong>-118 1 58 92 103 58 -127</strong>，而我直接通过hive sql查询列原始值，并转换成字节数组为 <strong>0 0 1 58 92 103 58 -127</strong>。观察这两组数据不难发现，不同之处在于前者开头是-118，而后者是0 0。而再仔细观察上面的字节数组，会很惊讶的发现，好像每隔6位，就会出现-118。这个时候，我就猜测假如能够弄明白-118的来源，那么我们的问题有很大概率就可以解决了。</p>
<h2 id="无心插柳"><a href="#无心插柳" class="headerlink" title="无心插柳"></a>无心插柳</h2><p>正当我对这个问题陷入困顿的时候，无意间发现了下图的信息(莫非这个是hive序列化类(⊙o⊙)？)</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/hive.png" alt="hive信息"></p>
<p>于是，我马上翻开了这个类的源码，根据类上面的注释确认了该类确实能将hive column序列化为BytesRefArrayWritable。该类只有initialize和serialize这两个方法，针对序列化过程，不难猜到入口肯定是serialize这个方法，由于需要序列化的列类型是Bigint，因此判定进入如下分支:</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/serialize.png" alt="序列化"></p>
<p>进入此方法后，是一个switch case分支选择，根据bigint和long对应关系，判定进入如下case：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/caselong.png" alt="Long"></p>
<p>最终代码导航下去，你会发现实际的转换过程在方法<strong>LazyBinaryUtils.writeVLongToByteArray</strong>,这也解开了上面-118的问题,不过限于水平目前还不太理解这段代码的含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">writeVLongToByteArray</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">long</span> l)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (l &gt;= -<span class="number">112</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123;</div><div class="line">    bytes[offset] = (<span class="keyword">byte</span>) l;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> len = -<span class="number">112</span>;</div><div class="line">  <span class="keyword">if</span> (l &lt; <span class="number">0</span>) &#123;</div><div class="line">    l ^= -<span class="number">1L</span>; <span class="comment">// take one's complement'</span></div><div class="line">    len = -<span class="number">120</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> tmp = l;</div><div class="line">  <span class="keyword">while</span> (tmp != <span class="number">0</span>) &#123;</div><div class="line">    tmp = tmp &gt;&gt; <span class="number">8</span>;</div><div class="line">    len--;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  bytes[offset] = (<span class="keyword">byte</span>) len;</div><div class="line"></div><div class="line">  len = (len &lt; -<span class="number">120</span>) ? -(len + <span class="number">120</span>) : -(len + <span class="number">112</span>);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = len; idx != <span class="number">0</span>; idx--) &#123;</div><div class="line">    <span class="keyword">int</span> shiftbits = (idx - <span class="number">1</span>) * <span class="number">8</span>;</div><div class="line">    <span class="keyword">long</span> mask = <span class="number">0xFFL</span> &lt;&lt; shiftbits;</div><div class="line">    bytes[offset+<span class="number">1</span>-(idx - len)] = (<span class="keyword">byte</span>) ((l &amp; mask) &gt;&gt; shiftbits);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span> + len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>最后，LazyBinaryUtils不仅提供了VLong序列化成字节数组的过程，同时也提供反序列化的过程，实际程序中只需调用LazyBinaryUtils.readVLongFromByteArray方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">readVLongFromByteArray</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset)</span> </span>&#123;</div><div class="line">  <span class="keyword">byte</span> firstByte = bytes[offset++];</div><div class="line">  <span class="keyword">int</span> len = WritableUtils.decodeVIntSize(firstByte);</div><div class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> firstByte;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">long</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; len-<span class="number">1</span>; idx++) &#123;</div><div class="line">    <span class="keyword">byte</span> b = bytes[offset++];</div><div class="line">    i = i &lt;&lt; <span class="number">8</span>;</div><div class="line">    i = i | (b &amp; <span class="number">0xFF</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (WritableUtils.isNegativeVInt(firstByte) ? ~i : i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结扩展"><a href="#总结扩展" class="headerlink" title="总结扩展"></a>总结扩展</h2><p>序列化和反序列化是相对的，在不了解具体序列化规则的情况下，去进行反序列化，有时候可能碰到问题。而在这个场景里，hive在序列化bigint时，是按照不定长的VLONG形式进行转换，如果我们依然按照原先读取long类型方式，那么就会碰到问题，因此一定要选择对应的反序列化方式才能获取到正确的值。在以后碰到hive不同列类型转换成Java中的类型时，可以参考LazyBinarySerDe.serialize对应类型的序列化方式，来寻找API中对应的反序列化方式，抑或自己动手造轮子。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景缘起&quot;&gt;&lt;a href=&quot;#背景缘起&quot; class=&quot;headerlink&quot; title=&quot;背景缘起&quot;&gt;&lt;/a&gt;背景缘起&lt;/h2&gt;&lt;p&gt;目前在将hive部分列数据采集到hbase时，由于平台将原来hive表的文件格式从SequenceFile调整到RCFile，因此需要对原来的离线数据采集程序进行修改。然而在实际修改开发过程中，却碰到了程序读取hive列字段，值为乱码的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RCFile" scheme="https://lukaicheng.github.io/tags/RCFile/"/>
    
      <category term="Hive" scheme="https://lukaicheng.github.io/tags/Hive/"/>
    
  </entry>
  
</feed>
