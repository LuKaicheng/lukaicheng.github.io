<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>羽逝神伤</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lukaicheng.github.io/"/>
  <updated>2017-06-25T12:56:58.695Z</updated>
  <id>https://lukaicheng.github.io/</id>
  
  <author>
    <name>Lucifer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>延迟任务实践总结</title>
    <link href="https://lukaicheng.github.io/2017/06/25/Delay-task-practice/"/>
    <id>https://lukaicheng.github.io/2017/06/25/Delay-task-practice/</id>
    <published>2017-06-25T07:41:52.000Z</published>
    <updated>2017-06-25T12:56:58.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在实际开发项目过程中，可能会碰到类似这样的需求：期望一个任务不是马上执行，而是可以在给定的时间段之后才执行，通常这被称为<strong>延迟任务</strong>。解决这个问题的方案已经有不少，最直接的是采用定时任务的方式扫描数据库，或者考虑使用时间轮算法，或者基于RabbitMQ来实现延迟队列。最近我在项目中就碰到了同样的问题：当新内容添加到系统时，会带有一个过期时间，一旦到达此过期时间，那么需要自动下架该内容。对于此问题，在实际项目演变过程中我采用了与上述不同的两种方式来解决。</p>
<a id="more"></a>
<h2 id="基于DelayQueue实现延迟队列"><a href="#基于DelayQueue实现延迟队列" class="headerlink" title="基于DelayQueue实现延迟队列"></a>基于DelayQueue实现延迟队列</h2><p>由于项目最开始服务器资源较为紧张，初步预估先采用单实例部署，故最初想到的方案是使用JDK自带的<code>java.util.concurrent.DelayQueue</code>来实现。<code>DelayQueue</code>实质上是一个<strong>无界的带有优先级的阻塞队列</strong>，其包含的元素必须实现<code>java.util.concurrent.Delayed</code>接口(<em>实际由内部的<code>PriorityQueue</code>持有元素</em>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合实际问题，创建出具体的<code>DelayTask</code>类，它包含过期时间和任务唯一标识，其中，过期时间会参与到方法<code>compareTo</code>和<code>getDelay</code>的实现，而任务唯一标识除了用于表达任务的唯一性，还用于后续获取该任务的相关信息，从而进行实际的业务处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</div><div class="line">    <span class="comment">//任务唯一标识</span></div><div class="line">    <span class="keyword">private</span> String uniqueIdentity;</div><div class="line">    <span class="comment">//过期时间</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTime;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedTask</span><span class="params">(String uniqueIdentity, <span class="keyword">long</span> expireTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.uniqueIdentity = uniqueIdentity;</div><div class="line">        <span class="keyword">this</span>.expireTime = expireTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//在插入优先队列时被调用，以决定元素具体的插入位置</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.expireTime &lt; ((DelayedTask) o).expireTime)</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.expireTime &gt; ((DelayedTask) o).expireTime)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//当前时间减去过期时间，假如小于等于零，则表示该任务已过去</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> unit.convert(expireTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUniqueIdentity</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> uniqueIdentity;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来基于生产者-消费者模式，使用Spring的<code>@Service</code>注解来定义一个延迟队列的单例，这样可以方便我们在多个生产者和消费者之间共享同一个延迟队列。这个类里我们定义了一个任务入队方法<code>enqueue</code>和任务出队<code>dequeue</code>方法，其中后者实际使用<code>DelayQueue.take</code>获取超时任务，如果队列暂时没有任务超时将会导致线程阻塞，因此实际消费者必须在单独线程中获取任务以免影响主线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentDelayQueue</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//延迟队列</span></div><div class="line">    <span class="keyword">private</span> DelayQueue&lt;DelayedTask&gt; queue = <span class="keyword">new</span> DelayQueue&lt;DelayedTask&gt;();</div><div class="line"></div><div class="line">    <span class="comment">//将需要延迟处理的对象放入队列</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(DelayedTask task)</span> </span>&#123;</div><div class="line">        queue.offer(task);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//返回将要超时的对象，如果暂时没有，则会进行阻塞，因此建议在一个独立的线程中进行处理</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DelayedTask <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.take();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后还有一点需要注意，使用这种方式实现的延迟队列，当程序运行时数据存在于内存之中，一旦程序停止，整个队列的数据就会消失，因此需要有一个初始化行为保证在程序重启之后可以从数据库获取信息恢复原来的延迟队列。如果使用了Spring的话，可以考虑实现<code>InitializingBean</code>接口，把初始化行为放在<code>afterPropertiesSet</code>方法里实现。</p>
<h2 id="基于Redis实现延迟队列"><a href="#基于Redis实现延迟队列" class="headerlink" title="基于Redis实现延迟队列"></a>基于Redis实现延迟队列</h2><p>尽管采用<code>DelayQueue</code>可以实现延迟任务的处理，然而如果需要部署多个程序实例，不经过修改是无法满足需求的，但是如果要修改可能并不是一件简单的事情。于是随着项目推进，分布式环境下实现延迟队列这个问题摆在了我的面前。由于之前没有引入RabbitMQ，现有组件只有Redis和Kafka，经过研究，最终决定利用Redis实现分布式环境下的的延迟队列方案。</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>参考网上已有的方案(<a href="https://redislabs.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-4-task-queues/6-4-2-delayed-tasks/" target="_blank" rel="external">Delayd tasks</a>)，并结合项目实际情况，确定了最终的总体设计思路，如下所述：</p>
<ol>
<li>以任务过期时间毫秒数作为分值，将延迟任务添加到Redis Sorted Set，从而使得任务可以根据过期时间的先后顺序进行排序。</li>
<li>利用Redis Sorted Set的<code>ZRANGEBYSCORE</code>命令，获取分值在零至当前时间之间的任务(即已经到期的延迟任务)，接着将其插入到Redis Set。</li>
<li>利用Redis Set的<code>SPOP</code>命令可以获取并移除Set上的一个到期的延迟任务，处理完业务逻辑之后，再使用Redis Sorted Set的<code>ZREM</code>命令移除原始的延迟任务。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>对于延迟任务的定义，依然沿用上一节的思路，只不过这次不需要实现<code>Delayed</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//任务唯一标识</span></div><div class="line">    <span class="keyword">private</span> String uniqueIdentity;</div><div class="line">    <span class="comment">//过期时间毫秒数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTime;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedTask</span><span class="params">(String uniqueIdentity, <span class="keyword">long</span> expireTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.uniqueIdentity = uniqueIdentity;</div><div class="line">        <span class="keyword">this</span>.expireTime = expireTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUniqueIdentity</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> uniqueIdentity;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpireTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> expireTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExpireTime</span><span class="params">(<span class="keyword">long</span> expireTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.expireTime = expireTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先实现步骤1，将任务添加到Redis有序集合。由于项目使用的Redis是集群方式配置，因此这里连接Redis的API使用的是Jedis库的<code>JedisCluster</code>，注意分值是过期时间，对应内容是延迟任务对象格式化成JSON之后的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTaskProducer</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(DelayedTaskProducer.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SORTED_SET = <span class="string">"SortedSetForDelayedTask"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SET = <span class="string">"SetForDelayedTask"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JedisCluster client;</div><div class="line">    <span class="comment">//用于将对象格式化成JSON字符串</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDelayedTask</span><span class="params">(String uniqueIdentitfy, <span class="keyword">long</span> expireTime)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//构建延迟任务</span></div><div class="line">        DelayedTask task = <span class="keyword">new</span> DelayedTask(uniqueIdentitfy, expireTime);</div><div class="line">        <span class="comment">//以过期时间为分值，将延迟任务添加到Redis有序集合</span></div><div class="line">        client.zadd(KEY_SORTED_SET, expireTime, mapper.writeValueAsString(task));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TransferWorker(), <span class="string">"DelayTaskTransferThread"</span>);</div><div class="line">        t1.start();</div><div class="line">        LOGGER.info(<span class="string">"DelayTaskTransferThread Start"</span>);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FinishWorker(), <span class="string">"DelayTaskFinishThread"</span>);</div><div class="line">        t2.start();</div><div class="line">        LOGGER.info(<span class="string">"DelayTaskFinishThread Start"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着是步骤2的实现代码，在实际项目实现中，我定义了一个内部类<code>TransferWorker</code>，它实现了<code>Runnable</code>接口，可以单独运行在一个线程中。主要工作就是根据<code>zrangeByScore</code>命令获取已经到期的延迟任务，并将它们转移到另外一个Redis集合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//从Redis Sorted Set获取已经过去的延迟任务</span></div><div class="line">                Set&lt;String&gt; set = client.zrangeByScore(KEY_SORTED_SET, <span class="number">0</span>,</div><div class="line">                        System.currentTimeMillis());</div><div class="line">                <span class="keyword">if</span> (set.isEmpty()) &#123;</div><div class="line">                    <span class="comment">//可以做成配置</span></div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">30</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                String[] members = <span class="keyword">new</span> String[set.size()];</div><div class="line">                set.toArray(members);</div><div class="line">                <span class="comment">//将过去的延迟任务添加到Redis Set</span></div><div class="line">                client.sadd(KEY_SET, members);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                LOGGER.error(e.getMessage(), e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后是步骤3的代码实现，同步骤2的做法一样，我也将<code>FinishWorker</code>定义为内部类，并实现了<code>Runnable</code>接口。它会从Redis集合中获取延迟任务，并将其移除，随后根据任务信息进行业务处理，最终如果一切顺利，那么会把原始任务从Redis有序集合中移除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FinishWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//从Redis Set获取一个延迟任务，并将其从Set中移除</span></div><div class="line">                String any = client.spop(KEY_SET);</div><div class="line">                <span class="keyword">if</span> (any == <span class="keyword">null</span> || any.trim().isEmpty()) &#123;</div><div class="line">                    <span class="comment">//可以做成配置</span></div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                DelayedTask task = mapper.readValue(any, DelayedTask.class);</div><div class="line">                <span class="comment">//省略业务处理代码...</span></div><div class="line">                </div><div class="line">                <span class="comment">//将原始的延迟任务从Redis Sorted Set中移除</span></div><div class="line">                client.zrem(KEY_SORTED_SET, any);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                LOGGER.error(e.getMessage(), e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我让<code>DelayedTaskProducer</code>实现<code>InitializingBean</code>接口，这样在初始化时，可以启动<code>TransferWork</code>和<code>FinishWorker</code>这两个线程任务。当然也可以将<code>TransferWork</code>和<code>FinishWorkder</code>提取出来，声明成非内部类，并在另外的地方启动它们。另外，由于这仅仅只是示例，所以在代码里只各启动了一个线程，然而在实际情况下，需要根据任务量来最终确定两种任务启动的线程数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TransferWorker(), <span class="string">"DelayTaskTransferThread"</span>);</div><div class="line">    t1.start();</div><div class="line">    LOGGER.info(<span class="string">"DelayTaskTransferThread Start"</span>);</div><div class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FinishWorker(), <span class="string">"DelayTaskFinishThread"</span>);</div><div class="line">    t2.start();</div><div class="line">    LOGGER.info(<span class="string">"DelayTaskFinishThread Start"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="背后考虑"><a href="#背后考虑" class="headerlink" title="背后考虑"></a>背后考虑</h3><p>最后再来总结一下整个设计过程中的一些考虑：</p>
<ul>
<li>最重要的一点是业务处理过程需要满足<strong>幂等性</strong>。</li>
<li>对程序异常有一定容忍，允许重试。</li>
<li>由于将移除有序集合的原始任务放在最后，因此即使前面的步骤发生异常，也可以通过重新加载有序集合的原始任务进行重试。</li>
<li>使用Set作为中转的原因是期望同一个任务只被一个线程消费，用<code>SPOP</code>命令可以实现。当然List也能满足这一点，但最终使用Set的原因是为了避免步骤2中多个程序实例的线程插入相同的任务。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://redislabs.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-4-task-queues/6-4-2-delayed-tasks/" target="_blank" rel="external">Delayd tasks</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在实际开发项目过程中，可能会碰到类似这样的需求：期望一个任务不是马上执行，而是可以在给定的时间段之后才执行，通常这被称为&lt;strong&gt;延迟任务&lt;/strong&gt;。解决这个问题的方案已经有不少，最直接的是采用定时任务的方式扫描数据库，或者考虑使用时间轮算法，或者基于RabbitMQ来实现延迟队列。最近我在项目中就碰到了同样的问题：当新内容添加到系统时，会带有一个过期时间，一旦到达此过期时间，那么需要自动下架该内容。对于此问题，在实际项目演变过程中我采用了与上述不同的两种方式来解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DelayQueue" scheme="https://lukaicheng.github.io/tags/DelayQueue/"/>
    
      <category term="Redis" scheme="https://lukaicheng.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化机制总结</title>
    <link href="https://lukaicheng.github.io/2017/06/24/Java-serialization-mechanism/"/>
    <id>https://lukaicheng.github.io/2017/06/24/Java-serialization-mechanism/</id>
    <published>2017-06-24T00:42:31.000Z</published>
    <updated>2017-06-25T07:35:43.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列化缘由"><a href="#序列化缘由" class="headerlink" title="序列化缘由"></a>序列化缘由</h2><p>在实际的程序运行过程中，总会有这样的场景：程序可以将本次运行的某些对象或者状态保存下来，以供下次启动时使用；在一个联网环境里，不同节点之间的系统需要进行通信，发送者要将某些对象发送到远程的接收者从而达到沟通协调的目的。序列化正是缘于这些场景而出现的一种技术概念，为了能够序列化Java平台的对象，JDK从很早的版本开始就提供了一种序列化机制，它可以将对象编码成字节流(<em>序列化</em>)，也可以反向从字节流编码中重新构建对象(<em>反序列化</em>)，以用于支持RMI和JavaBean。</p>
<a id="more"></a>
<h2 id="序列化实现"><a href="#序列化实现" class="headerlink" title="序列化实现"></a>序列化实现</h2><p>想要一个类的实例能被序列化，只要让类实现<code>java.io.Serializable</code>或者<code>java.io.Externalizable</code>接口即可。其中，<code>java.io.Serializable</code>仅仅只是一个标记接口，系统通过判断是否是此接口的子类来确定对象能否被序列化，而整个序列化过程对于应用开发者来说完全是透明的。<code>java.io.Externalizable</code>不同于前者，开发者必须通过实现<code>writeExternal</code>和<code>readExternal</code>这两个方法，来决定如何保存和恢复对象的内容，另外需要注意的是<code>Externalizable</code>子类要有一个<strong>公共的无参构造器</strong>，否则会导致反序列化失败。</p>
<p>下面的例子展示了一个<code>Person</code>类，其继承<code>Serializable</code>接口，表示能被序列化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> String birth;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String birth, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.birth = birth;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(<span class="string">"My name is %s, My birthDay is %s,My age is %d"</span>, name, birth, age);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当实际进行序列化操作时，可以创建<code>ObjectOutputStream</code>，调用相应的<strong>writeXXX</strong>方法就可以将对象序列化成字节流。当需要进行反序列化操作时，可以创建<code>ObjectInputStream</code>，调用相应的<strong>readXXX</strong>方法就可以从字节流中还原对象信息。下面的例子展示了如何将对象序列化到文件，并从文件反序列化成对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialiazationTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String file = <span class="string">"D:/extern.out"</span>;</div><div class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file))) &#123;</div><div class="line">            oos.writeObject(<span class="keyword">new</span> Person(<span class="string">"Lucifer"</span>, <span class="string">"1986-01-01"</span>, <span class="number">30</span>));</div><div class="line">            oos.flush();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file))) &#123;</div><div class="line">            Person p = (Person) ois.readObject();</div><div class="line">            System.out.println(p);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="序列化字段修饰"><a href="#序列化字段修饰" class="headerlink" title="序列化字段修饰"></a>序列化字段修饰</h3><p>默认情况下，除了用<strong>transient</strong>或<strong>static</strong>声明的字段，本类中所声明的其他字段都会被序列化。在实际序列化过程中，会创建实例类对应的<code>ObjectStreamClass</code>，它会探测实例类中哪些字段需要进行序列化，具体细节可参考<code>ObjectStreamClass.getDefaultSerialFields</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) &#123;</div><div class="line">    Field[] clFields = cl.getDeclaredFields();</div><div class="line">    ArrayList&lt;ObjectStreamField&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> mask = Modifier.STATIC | Modifier.TRANSIENT;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clFields.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> ((clFields[i].getModifiers() &amp; mask) == <span class="number">0</span>) &#123;</div><div class="line">            list.add(<span class="keyword">new</span> ObjectStreamField(clFields[i], <span class="keyword">false</span>, <span class="keyword">true</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> size = list.size();</div><div class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? NO_FIELDS :</div><div class="line">        list.toArray(<span class="keyword">new</span> ObjectStreamField[size]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="序列化字段声明"><a href="#序列化字段声明" class="headerlink" title="序列化字段声明"></a>序列化字段声明</h3><p>除了使用修饰符来控制字段是否需要被序列化，还有一种方式可以显式的声明需要进行序列化的字段，并且会<strong>覆盖默认使用修饰符的方式</strong>，那就是声明特殊的<code>serialPersistentFields</code>字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</div><div class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">"name"</span>, String.class),</div><div class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">"birth"</span>, String.class) &#125;;</div></pre></td></tr></table></figure>
<p>需要注意的是<code>serialPersistentFields</code>字段的修饰符必须包含<code>private</code> <code>static</code> <code>final</code>，而且类型必须是<code>ObjectStreamField[]</code>。使用这种方式也可以使得类中的字段在后续版本中可以发生变化，个人理解为这个字段声明了在类版本演化过程中需要维持兼容性的一个边界。想要了解更详细的情况，可以查看<code>ObjectStream.getDeclaredSerialFields</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectStreamField[] getDeclaredSerialFields(Class&lt;?&gt; cl)</div><div class="line">    <span class="keyword">throws</span> InvalidClassException</div><div class="line">&#123;</div><div class="line">    ObjectStreamField[] serialPersistentFields = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Field f = cl.getDeclaredField(<span class="string">"serialPersistentFields"</span>);</div><div class="line">        <span class="keyword">int</span> mask = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;</div><div class="line">        <span class="keyword">if</span> ((f.getModifiers() &amp; mask) == mask) &#123;</div><div class="line">            f.setAccessible(<span class="keyword">true</span>);</div><div class="line">            serialPersistentFields = (ObjectStreamField[]) f.get(<span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (serialPersistentFields == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serialPersistentFields.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NO_FIELDS;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ObjectStreamField[] boundFields =</div><div class="line">        <span class="keyword">new</span> ObjectStreamField[serialPersistentFields.length];</div><div class="line">    Set&lt;String&gt; fieldNames = <span class="keyword">new</span> HashSet&lt;&gt;(serialPersistentFields.length);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; serialPersistentFields.length; i++) &#123;</div><div class="line">        ObjectStreamField spf = serialPersistentFields[i];</div><div class="line"></div><div class="line">        String fname = spf.getName();</div><div class="line">        <span class="keyword">if</span> (fieldNames.contains(fname)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(</div><div class="line">                <span class="string">"multiple serializable fields named "</span> + fname);</div><div class="line">        &#125;</div><div class="line">        fieldNames.add(fname);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Field f = cl.getDeclaredField(fname);</div><div class="line">            <span class="keyword">if</span> ((f.getType() == spf.getType()) &amp;&amp;</div><div class="line">                ((f.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>))</div><div class="line">            &#123;</div><div class="line">                boundFields[i] =</div><div class="line">                    <span class="keyword">new</span> ObjectStreamField(f, spf.isUnshared(), <span class="keyword">true</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException ex) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (boundFields[i] == <span class="keyword">null</span>) &#123;</div><div class="line">            boundFields[i] = <span class="keyword">new</span> ObjectStreamField(</div><div class="line">                fname, spf.getType(), spf.isUnshared());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> boundFields;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义序列化行为"><a href="#自定义序列化行为" class="headerlink" title="自定义序列化行为"></a>自定义序列化行为</h2><p>除了使用修饰符或者特殊字段的方式之外，Java序列化机制还提供了<code>writeObject</code>和<code>readObject</code>这两个特殊的方法，可以让我们覆盖默认的序列化方式，实现自定义序列化行为，下面是完整的方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//自定义序列化行为</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="comment">//自定义反序列化行为</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</div></pre></td></tr></table></figure>
<p>需要自定义序列化行为的<code>Serializable</code>子类可以通过实现这两个方法来自定义整个序列化过程。以<code>LinkedList</code>为例，其内部就定义实现了这两个方法，之所以如此，这是由于其内部实现目前采用了双端链表的形式，假如采用默认的序列化方式，那么不仅会镜像链表中的所有项，整个链表的拓扑结构也会被镜像，这不但会导致不必要的空间消耗，也会使得类永远被束缚其内部表示法，因此<code>Linked</code>实现了自定义的序列化方式，仅仅序列化数据项的数量以及实际数据项，而拓扑结构是在反序列化过程中重新组织：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">    <span class="keyword">throws</span> java.io.IOException &#123;</div><div class="line">    <span class="comment">// Write out any hidden serialization magic</span></div><div class="line">    s.defaultWriteObject();</div><div class="line"></div><div class="line">    <span class="comment">// Write out size</span></div><div class="line">    s.writeInt(size);</div><div class="line"></div><div class="line">    <span class="comment">// Write out all elements in the proper order.</span></div><div class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</div><div class="line">        s.writeObject(x.item);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></div><div class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</div><div class="line">    <span class="comment">// Read in any hidden serialization magic</span></div><div class="line">    s.defaultReadObject();</div><div class="line"></div><div class="line">    <span class="comment">// Read in size</span></div><div class="line">    <span class="keyword">int</span> size = s.readInt();</div><div class="line"></div><div class="line">    <span class="comment">// Read in all elements in the proper order.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">        linkLast((E)s.readObject());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有两点需要注意：首先，即使你需要实现自定义的序列化过程，也请在序列化时优先调用<code>defaultWriteObject</code>方法以及在反序列化时优先调用<code>defaultReadObject</code>方法，这可以使类保持更大的灵活性，即使以后类增加了非<strong>transient</strong>字段，也能保持向前和向后兼容性；其次，在反序列化过程中，对于类的约束关系也需要进行保证，这是因为反序列化其实也是一种对象创建机制，是一种<strong>隐藏的构造器</strong>，否则类的约束关系就容易遭到破坏，从而可能遭受非法访问。</p>
<h2 id="序列化版本号"><a href="#序列化版本号" class="headerlink" title="序列化版本号"></a>序列化版本号</h2><p>当然不管最终采用默认的抑或自定义的序列化行为，显式声明<code>serialVersionUID</code> 都是一种较好的编程习惯。首先，如果不提供显式的<code>serialVersionUID</code> ，那么需要在运行时通过一个高开销的计算过程(<a href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/class.html#4100" target="_blank" rel="external">Stream Unique Identifiers</a>)产生一个<code>serialVersionUID</code>，这会导致一些性能损失。其次，<code>serialVersionUID</code>计算会综合考虑类、接口、方法以及字段，随着类的演进，这可能导致旧版本和新版本计算出来的<code>serialVersionUID</code>不一致，从而导致现有类与原有类的不兼容(<em>即使两者实际上可以兼容</em>)。基于以上考虑，显式声明<code>serialVersionUID</code>，可以让我们明确是否需要为类创建新版本。</p>
<h3 id="不可兼容变更"><a href="#不可兼容变更" class="headerlink" title="不可兼容变更"></a>不可兼容变更</h3><p>当类演进过程中，碰到如下情况，可以考虑为不兼容，需要创建新版本：</p>
<ul>
<li>删除字段</li>
<li>提升或降低类层级</li>
<li>将一个非<strong>transient</strong>字段变成<strong>transient</strong>或者将一个非<strong>static</strong>字段变成<strong>static</strong></li>
<li>改变一个基本类型字段的原有声明类型</li>
<li>修改<code>writeObject</code>或<code>readObject</code>方法使得与原有版本在处理默认字段时方式不同</li>
<li>将类从实现<code>Serializable</code>接口 变成实现<code>Externalizable</code>接口或者相反情况</li>
<li>将类从非枚举类型变成枚举类型或者相反情况</li>
<li>移除<code>Serializable</code>接口或<code>Externalizable</code>接口</li>
<li>为类增加<code>writeReplace</code>或者<code>readResolve</code>方法</li>
</ul>
<h3 id="可兼容变更"><a href="#可兼容变更" class="headerlink" title="可兼容变更"></a>可兼容变更</h3><p>当类演进过程中，碰到如下情况，可以考虑为兼容情况：</p>
<ul>
<li>增加字段</li>
<li>增加类</li>
<li>删除类</li>
<li>增加<code>writeObject</code>和<code>readObject</code>方法</li>
<li>移除<code>writeObject</code>和<code>readObject</code>方法</li>
<li>增加<code>java.io.Serializable</code>接口</li>
<li>改变字段的访问权限</li>
<li>将一个字段从<strong>static</strong>变成非<strong>static</strong>或者从<strong>transient</strong>变成非<strong>transient</strong></li>
</ul>
<h2 id="序列化代理模式"><a href="#序列化代理模式" class="headerlink" title="序列化代理模式"></a>序列化代理模式</h2><p>由于序列化机制会利用普通构造器之外的机制来创建对象，增加了出错和出现安全问题的可能性，于是JDK设计人员提出了所谓的序列化代理模式，这种模式大概的思路是为可序列化的类设计一个私有的静态嵌套类，其被称作序列化代理，它有一个单独的构造器来接收外围类，从而复制外围类的数据，这个复制过程不需要一致性检查和保护性拷贝。接着利用两个特殊方法<code>writeReplace</code>和<code>readResolve</code>来实现外围类实例和序列化代理类实例之间的互相转换，从而最终序列化目的。</p>
<p>两个方法的完整签名以及简要说明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//类通过实现此方法，可以使得其实例在序列化写入流时替换成此方法返回的对象</span></div><div class="line">ANY-ACCESS-<span class="function">MODIFIER Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</div><div class="line"><span class="comment">//类通过实现此方法，可以使得反序列化读取到其实例之后，并在返回调用者之前，替换成此方法的返回对象</span></div><div class="line">ANY-ACCESS-<span class="function">MODIFIER Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</div></pre></td></tr></table></figure>
<p><code>EnumSet</code>内部就实现了序列化代理，它定义了静态内部类<code>SerializationProxy</code>并实现了<code>writeReplace</code>方法。当对<code>EnumSet</code>实例进行序列化时，会调用<code>writeReplace</code>方法，这会返回一个<code>SerializationProxy</code>实例并替换<code>EnumSet</code>实例写入字节流；当反序列化时，读取出来的首先是<code>SerializationProxy</code>实例，由于该实例的类定义了<code>readResolve</code>方法，因此在返回给调用者之前，此方法会被调用，从而利用已有的工厂方法重建回<code>EnumSet</code>实例。另外需要注意的是<code>EnumSet</code>定义<code>readObject</code>方法是为了防止可能的攻击。以下是<code>EnumSet</code>类的部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Class&lt;E&gt; elementType;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Enum[] universe;</div><div class="line">  </div><div class="line">    <span class="comment">//省略部分代码</span></div><div class="line">   	<span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Enum&lt;E&gt;&gt; <span class="function">EnumSet&lt;E&gt; <span class="title">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span> </span>&#123;</div><div class="line">        Enum[] universe = getUniverse(elementType);</div><div class="line">        <span class="keyword">if</span> (universe == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(elementType + <span class="string">" not an enum"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (universe.length &lt;= <span class="number">64</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RegularEnumSet&lt;&gt;(elementType, universe);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JumboEnumSet&lt;&gt;(elementType, universe);</div><div class="line">    &#125;</div><div class="line">  	<span class="comment">//省略部分代码</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationProxy</span> &lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;E&gt; elementType;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Enum[] elements;</div><div class="line"></div><div class="line">        SerializationProxy(EnumSet&lt;E&gt; set) &#123;</div><div class="line">            elementType = set.elementType;</div><div class="line">            elements = set.toArray(ZERO_LENGTH_ENUM_ARRAY);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</div><div class="line">            EnumSet&lt;E&gt; result = EnumSet.noneOf(elementType);</div><div class="line">            <span class="keyword">for</span> (Enum e : elements)</div><div class="line">                result.add((E)e);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362491234563181265L</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">Object <span class="title">writeReplace</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SerializationProxy&lt;&gt;(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream stream)</span></span></div><div class="line">        <span class="keyword">throws</span> java.io.InvalidObjectException &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Proxy required"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/serialTOC.html" target="_blank" rel="external">Java Object Serialization Specification</a></p>
<p><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="external">Effective Java中文版(第2版)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序列化缘由&quot;&gt;&lt;a href=&quot;#序列化缘由&quot; class=&quot;headerlink&quot; title=&quot;序列化缘由&quot;&gt;&lt;/a&gt;序列化缘由&lt;/h2&gt;&lt;p&gt;在实际的程序运行过程中，总会有这样的场景：程序可以将本次运行的某些对象或者状态保存下来，以供下次启动时使用；在一个联网环境里，不同节点之间的系统需要进行通信，发送者要将某些对象发送到远程的接收者从而达到沟通协调的目的。序列化正是缘于这些场景而出现的一种技术概念，为了能够序列化Java平台的对象，JDK从很早的版本开始就提供了一种序列化机制，它可以将对象编码成字节流(&lt;em&gt;序列化&lt;/em&gt;)，也可以反向从字节流编码中重新构建对象(&lt;em&gt;反序列化&lt;/em&gt;)，以用于支持RMI和JavaBean。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Serialization" scheme="https://lukaicheng.github.io/tags/Serialization/"/>
    
  </entry>
  
  <entry>
    <title>基于标签的人群统计实现分析</title>
    <link href="https://lukaicheng.github.io/2017/06/09/TagBasedStatistics/"/>
    <id>https://lukaicheng.github.io/2017/06/09/TagBasedStatistics/</id>
    <published>2017-06-09T12:15:41.000Z</published>
    <updated>2017-06-15T06:28:25.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>最近在做项目过程中，碰到了这样一个需求：当前台页面勾选偏好标签的时候，后端服务需要快速给出标签对应的人群数量。如果仅仅只是单个标签的话，那么问题是非常简单的，然而现实是残酷的，我必须考虑基于多个标签勾选的交并集统计情况。</p>
<p>在此，先做一个假设，每个标签后面对应的人群数量是一百万，当然有可能人群会有重叠，而后续的讨论都是基于此数量级展开。</p>
<a id="more"></a>
<h2 id="初始想法"><a href="#初始想法" class="headerlink" title="初始想法"></a>初始想法</h2><p>考虑到在实际业务场景中用户标识是手机号码，这是一个数字，而且每个用户之间互不相同，为了尽可能满足快速响应以及节省空间的原则，我首先想到了利用<strong>位图</strong>的思想来实现这个需求。在Java中就提供了这样一个类来实现位图操作，它就是<strong>BitSet</strong>，下面是简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitSetDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        BitSet bs1 = <span class="keyword">new</span> BitSet();</div><div class="line">        bs1.set(<span class="number">14</span>);</div><div class="line">        bs1.set(<span class="number">20</span>);</div><div class="line">        bs1.set(<span class="number">43</span>);</div><div class="line">        <span class="comment">//输出bs1中设置为true的位数</span></div><div class="line">        System.out.println(bs1.cardinality());</div><div class="line">        BitSet bs2 = <span class="keyword">new</span> BitSet();</div><div class="line">        bs2.set(<span class="number">7</span>);</div><div class="line">        bs2.set(<span class="number">20</span>);</div><div class="line">        bs2.set(<span class="number">33</span>);</div><div class="line">        bs2.set(<span class="number">45</span>);</div><div class="line">        <span class="comment">//输出bs2中设置为true的位数</span></div><div class="line">        System.out.println(bs2.cardinality());</div><div class="line">        <span class="comment">//bs1和bs2进行交集操作</span></div><div class="line">        bs1.and(bs2);</div><div class="line">        <span class="comment">//输出bs1和bs2进行交集操作之后设置为true的位数</span></div><div class="line">        System.out.println(bs1.cardinality());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BitSet可以通过设置具体索引位的值为true来代表存在此数字，而且它还提供了基于位的交、并、差等操作(需要值得注意的是<strong>这些操作会对原有位图进行修改</strong>)。</p>
<p>映射到实际的业务问题，如果把用户标识(将手机号码看成数字)对应的位设置成true来代表存在此用户，那么似乎可以通过操作不同标签对应的位图，从而实现所期望的功能。然而这里还遗漏了一个问题，那就是位图持久化。</p>
<h2 id="Redis-bitmap"><a href="#Redis-bitmap" class="headerlink" title="Redis bitmap"></a>Redis bitmap</h2><p>正当我苦恼持久化的问题时，无意中翻到Redis居然提供了类似位图操作的命令：<strong>SETBIT</strong>、<strong>BITCOUNT</strong>、<strong>BITOP</strong>， 而且它还提供了RDB和AOF两种持久化机制，另外由于Redis是内存数据库，在命令响应方面也是非常迅速，可以说非常符合我这个问题的场景。</p>
<p>不过，当真正用Redis去实现的时候，又碰到了之前忽视的一个细节：手机号是11号数字，超过了Redis位图所能表示的范围，这一点在<strong>SETBIT</strong>命令的文档中有如下说明：</p>
<blockquote>
<p>The <em>offset</em> argument is required to be greater than or equal to 0, and smaller than 2^32 (this limits bitmaps to 512MB)</p>
</blockquote>
<p>为了解决这个细节问题，我想出了一个方案：将手机号前两位作为key的一部分，剩下的9位作为值插入到位图里面，由于手机号第一位是1，那么实际上一个标签最多需要10个位图来表示。为了避免用<strong>KEYS</strong>命令扫描获取某个标签所有的key，可以把这些key放到Redis Set中，每次可以先使用<strong>SMEMEBERS</strong>命令获取到所有key。</p>
<h2 id="Bitmap-VS-Set"><a href="#Bitmap-VS-Set" class="headerlink" title="Bitmap VS Set"></a>Bitmap VS Set</h2><p>在给他人讲述了我的方案之后，由于此设计在实现上确实有些繁琐复杂，有人提出是否考虑直接使用Set来存储所有的用户号码(他用两个百万随机用户号码的Set做交并操作，效率可以接受)。</p>
<p>于是，我开始对Set方案进行验证，除了处理速度之外，主要关注容量消耗，最终经过测试发现，一百万随机手机号码用Redis Set存储会消耗大概<strong>90MB</strong>内存。回过头来，分析我的Bitmap方案，如果要表达9位数字，那么需要2^30，即128MB(实际测试下来发现也大致符合这个值)，而一个标签最多需要分10个key，所以最大占据<strong>1280MB</strong>。 </p>
<p>诚然Set方案会随着标签下用户群的数量增加容量会随之增加，Bitmap方案的容量较为恒定，然而在这个场景下(最开始假设了一百万的量级，真实场景也大致如此甚至更少)，确实是采用Set会优于Bitmap。</p>
<h2 id="Cluster-amp-hash-tags"><a href="#Cluster-amp-hash-tags" class="headerlink" title="Cluster &amp; hash tags"></a>Cluster &amp; hash tags</h2><p>尽管决定采用Set方案，在实际编码以及调试过程中，又碰到了Redis的一个限制：如果Redis是采用集群方式部署，假设Set对应的key不属于同个节点，那么就无法透明的支持Set的交并操作。</p>
<p>引用自Redis Cluster规范：</p>
<blockquote>
<p>Redis Cluster implements all the single key commands available in the non-distributed version of Redis. Commands performing complex multi-key operations like Set type unions or intersections are implemented as well as long as the keys all belong to the same node.</p>
</blockquote>
<p>这样一来，就需要通过调用者来处理不同标签对应的key分配在不同节点的情况，每次进行多个标签交并操作时，首先需要从多个节点获取到对应标签的用户集合，然后在调用者的程序当中进行实际的集合交并，这样一来会大大增加网络传输量。</p>
<p>幸运的是，Redis提供了一种技巧，可以强制让多个key分配到相同的节点，这种技巧叫做<strong>hash tags</strong>。众所周知，Redis在执行key有关的命令前，先会计算key所对应的slot，不同的key由于计算出来的slot不同，往往就会位于不同的节点。而这个计算有一个短路的地方，假设碰到一个key包含<strong>“{“</strong>和<strong>“}”</strong>，那么只会使用花括号内的子字符串(<em>第一个花括号内的字符串</em>)进行slot的计算，这意味着{foo}bar1和{foo}bar2将会位于同一个节点。想要对这个概念有更详细的了解，可以查看<a href="https://redis.io/topics/cluster-spec#keys-hash-tags" target="_blank" rel="external">Keys hash tags</a>。 </p>
<p>考虑到可能出现的数据倾斜问题，我们可以将同一大类的标签都指派到相同节点，不同大类的标签指派到不同节点。由于交并操作符合交换律和结合律，那么可以优先计算出相同大类的交并集合，最终通过程序汇总，计算出不同大类的交并集合。这样一来，在考虑数据平衡的情况下，也相应减少网络传输。</p>
<h2 id="打破原有思维"><a href="#打破原有思维" class="headerlink" title="打破原有思维"></a>打破原有思维</h2><p>到此为止，这似乎是比较可取的方案了，然而当我跳出目前的思路，再重新去回顾整个问题的时候，猛然有一个念头在我脑海里闪过：一定要用手机号对应的数字来设置位图值吗？意识到这一点，我想到整个问题可以从一个新的角度来解决。</p>
<p>最开始想到采用手机号对应的数字来设置位图信息，是因为在整个系统里手机号可以唯一标识一个用户，然而对此问题而言，本质是关注具体标签下包含哪些用户，至于这些用户是如何确定唯一的，其实并不重要。那么，其实我可以预先做一个映射，将系统中所有的用户号码和一个自增序列进行映射，由于整个系统用户量仅仅只有千万级(且离亿级差距较大)，那么自增序列最大值不会超过100000000(其小于2^27，2^27 bit = 16MB)。如此一来，通过手机号码对应的自增序列数字设置redis位图值，一个key对应的位图就可以存储一个标签所包含的所有用户，且容量仅<strong>16MB</strong>左右，即使标签下用户量从百万级增长到千万级，容量也是恒定的。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>通过对整个问题持续的思考、同其他人的交流以及自我反思，让我更加深刻意识到分析问题要综合考虑项目实际情况、业务细节以及技术限制，任何好的方案都是通过不断权衡和取舍而做出的选择，这个世界上没有银弹。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://redis.io/commands/setbit" target="_blank" rel="external">Redis SETBIT 命令</a></p>
<p><a href="https://redis.io/commands/bitcount" target="_blank" rel="external">Redis BITCOUNT 命令</a></p>
<p><a href="https://redis.io/commands/bitop" target="_blank" rel="external">Redis BITOP 命令</a></p>
<p><a href="https://redis.io/topics/cluster-spec#keys-hash-tags" target="_blank" rel="external">Redis hash tags</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;最近在做项目过程中，碰到了这样一个需求：当前台页面勾选偏好标签的时候，后端服务需要快速给出标签对应的人群数量。如果仅仅只是单个标签的话，那么问题是非常简单的，然而现实是残酷的，我必须考虑基于多个标签勾选的交并集统计情况。&lt;/p&gt;
&lt;p&gt;在此，先做一个假设，每个标签后面对应的人群数量是一百万，当然有可能人群会有重叠，而后续的讨论都是基于此数量级展开。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://lukaicheng.github.io/tags/Redis/"/>
    
      <category term="BitSet" scheme="https://lukaicheng.github.io/tags/BitSet/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础 - BeanPostProcessor</title>
    <link href="https://lukaicheng.github.io/2017/05/15/Spring-BeanPostProcessor/"/>
    <id>https://lukaicheng.github.io/2017/05/15/Spring-BeanPostProcessor/</id>
    <published>2017-05-15T12:40:40.000Z</published>
    <updated>2017-05-17T02:17:29.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h1><p><strong>BeanPostProcessor</strong>是Spring提供的一个钩子(<em>Hook</em>)接口，可用于实现对新的bean实例进行自定义修改，比如说，检测bean是否实现了某些特定接口从而可以对其进行进一步操作，或者可以将原实例进行包装而实际返回代理对象。其内部主要声明了<em>postProcessBeforeInitialization</em>和<em>postProcessAfterInitialization</em>两个回调方法，具体的接口声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line">  	<span class="comment">//在bean进行初始化行为之前被调用</span></div><div class="line">	<span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">  	<span class="comment">//在bean进行初始化行为之后被调用</span></div><div class="line">	<span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是这里所说的bean初始化行为主要是指调用<strong>InitializingBean</strong>的<em>afterPropertiesSet</em>或者一个自定义的<em>init-method</em>。</p>
<a id="more"></a>
<h1 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h1><p>根据Spring提供的文档注释，不难获知<strong>BeanPostProcessor</strong>提供的两个方法会分别在bean进行初始化的前后被触发调用。抱着好奇心，也是为了更深入的理解，我通过IDE查看这两个方法的调用链，然后发现原来抽象类<strong>AbstractAutowireCapableBeanFactory</strong>的<em>initializeBean</em>方法会间接调用这两者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</div><div class="line">		AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				invokeAwareMethods(beanName, bean);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;, getAccessControlContext());</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		invokeAwareMethods(beanName, bean);</div><div class="line">	&#125;</div><div class="line">	Object wrappedBean = bean;</div><div class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</div><div class="line">		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		invokeInitMethods(beanName, wrappedBean, mbd);</div><div class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</div><div class="line">          (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</div><div class="line">          	beanName, <span class="string">"Invocation of init method failed"</span>, ex);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</div><div class="line">    	wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> wrappedBean;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法<em>applyBeanPostProcessorsBeforeInitialization</em>和<em>applyBeanPostProcessorsAfterInitialization</em>最终会分别调用已经注册的<strong>BeanPostProcessor</strong>的这两个方法，而且是在方法<em>invokeInitMethods</em>调用的前后。而方法<em>invokeInitMethods</em>实质就是对bean进行判定，来确定是否可以转换成<strong>InitializingBean</strong>进而调用接口方法<em>afterPropertiesSet</em>或者是否存在自定义的<em>init-method</em>进行调用。 </p>
<h1 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h1><p>通过<strong>ApplicationContext</strong>和<strong>BeanFactory</strong>进行注册的方式稍微有些不同。对于<strong>ApplicationContext</strong>来说，只要定义在其配置文件里(或注解方式)，它就会自动检测到<strong>BeanPostProcessor</strong>实现类 ，并将其注册；对于普通的<strong>BeanFactory</strong>来说，那么就需要显式以编程方式来调用方法<em>addBeanPostProcessor</em>进行注册。</p>
<p>假设项目开启了注解扫描，那么只需加上注解，就能实现<strong>ApplicationContext</strong>方式的自动注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out.println(<span class="string">"Enter MyBeanPostProcessor postProcessBeforeInitialization"</span>);</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out.println(<span class="string">"Enter MyBeanPostProcessor postProcessAfterInitialization"</span>);</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h1><p>在实际项目中，我们可能需要注册不止一个<strong>BeanPostProcessor</strong>的实现类，而不管是采用<strong>BeanFactory</strong>还是<strong>ApplicationContext</strong>，实际调用顺序都是取决于注册顺序。由于<strong>BeanFactory</strong>是显式编程方式调用，因此可以人为决定注册顺序；而采用<strong>ApplicationContext</strong>的自动检测方式，其注册顺序由以下的规则确定：</p>
<ol>
<li>首先调用实现了<strong>PriorityOrdered</strong>接口的<strong>BeanPostProcessor</strong>实现类，如果不止一个类实现了<strong>PriorityOrdered</strong>接口，那么会按照方法<em>getOrder</em>返回的值的大小，越大就会优先调用。</li>
<li>接着调用实现了<strong>Ordered</strong>接口的<strong>BeanPostProcessor</strong>实现类，如果不止一个类实现了<strong>Ordered</strong>接口，那么会按照<em>getOrder</em>返回的值的大小，值越大就会优先调用。</li>
<li>然后调用既没有实现<strong>PriorityOrdered</strong>也没有实现<strong>Ordered</strong>的<strong>BeanPostProcessor</strong>实现类，这个调用顺序往往是无序的，因为由于没有在注册之前进行排序操作。</li>
<li>最后是调用实现<strong>MergedBeanDefinitionPostProcessor</strong>(通常供框架内部使用)的实现类。</li>
</ol>
<p>感兴趣的话，可以看一下<strong>PostProcessorRegistrationDelegate</strong>的<em>registerBeanPostProcessors</em>方法，其内部实现了对<strong>BeanPostProcessor</strong>的注册(这也是<strong>AbstractApplicationContext</strong>的<em>refresh</em>过程之一)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></div><div class="line">		ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</div><div class="line"></div><div class="line">	String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></div><div class="line">	<span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></div><div class="line">	<span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></div><div class="line">	<span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</div><div class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</div><div class="line"></div><div class="line">	<span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></div><div class="line">	<span class="comment">// Ordered, and the rest.</span></div><div class="line">	List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</div><div class="line">	List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</div><div class="line">	List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</div><div class="line">		<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</div><div class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">			priorityOrderedPostProcessors.add(pp);</div><div class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">				internalPostProcessors.add(pp);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</div><div class="line">			orderedPostProcessorNames.add(ppName);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			nonOrderedPostProcessorNames.add(ppName);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></div><div class="line">	sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</div><div class="line">	registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</div><div class="line"></div><div class="line">	<span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></div><div class="line">	List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</div><div class="line">	<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</div><div class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">		orderedPostProcessors.add(pp);</div><div class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">			internalPostProcessors.add(pp);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	sortPostProcessors(beanFactory, orderedPostProcessors);</div><div class="line">	registerBeanPostProcessors(beanFactory, orderedPostProcessors);</div><div class="line"></div><div class="line">	<span class="comment">// Now, register all regular BeanPostProcessors.</span></div><div class="line">	List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</div><div class="line">	<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</div><div class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">		nonOrderedPostProcessors.add(pp);</div><div class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">			internalPostProcessors.add(pp);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</div><div class="line"></div><div class="line">	<span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></div><div class="line">	sortPostProcessors(beanFactory, internalPostProcessors);</div><div class="line">	registerBeanPostProcessors(beanFactory, internalPostProcessors);</div><div class="line"></div><div class="line">	<span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></div><div class="line">	<span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></div><div class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="简单实践"><a href="#简单实践" class="headerlink" title="简单实践"></a>简单实践</h1><p>现在考虑项目中有这样一个配置，它通过读取配置文件<strong>app.properties</strong>，可以设置规则属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:app.properties"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;app.rule&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String rule;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRule</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> rule;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们需要对设置的规则进行校验，可以通过实现自定义的<strong>BeanPostProcessor</strong>来解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleNameBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; rules = Arrays.asList(<span class="string">"ruleA"</span>, <span class="string">"ruleB"</span>, <span class="string">"ruleC"</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MyConfig) &#123;</div><div class="line">            MyConfig config = (MyConfig) bean;</div><div class="line">            <span class="keyword">if</span> (!rules.contains(config.getRule())) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Invalid rule"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们在<strong>app.properties</strong>文件中配置了预定义规则之外的规则，那么程序在启动的时候就会抛出异常</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/BeanInitializationException.png" alt="异常信息"></p>
<p>通过启动阶段的检测机制，我们能够快速发现可能存在的问题，从而避免在程序运行期间发现错误。当然<strong>BeanPostProcessor</strong>在实际项目中肯定可以发挥更多的作用，这有待于我们进一步去挖掘。另外，如果对于Spring源码感兴趣的话，这个接口以及框架内部已有的实现类也是我们必须要了解的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html" target="_blank" rel="external">BeanPostProcessor javadoc</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;接口简介&quot;&gt;&lt;a href=&quot;#接口简介&quot; class=&quot;headerlink&quot; title=&quot;接口简介&quot;&gt;&lt;/a&gt;接口简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;BeanPostProcessor&lt;/strong&gt;是Spring提供的一个钩子(&lt;em&gt;Hook&lt;/em&gt;)接口，可用于实现对新的bean实例进行自定义修改，比如说，检测bean是否实现了某些特定接口从而可以对其进行进一步操作，或者可以将原实例进行包装而实际返回代理对象。其内部主要声明了&lt;em&gt;postProcessBeforeInitialization&lt;/em&gt;和&lt;em&gt;postProcessAfterInitialization&lt;/em&gt;两个回调方法，具体的接口声明如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BeanPostProcessor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  	&lt;span class=&quot;comment&quot;&gt;//在bean进行初始化行为之前被调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;Object &lt;span class=&quot;title&quot;&gt;postProcessBeforeInitialization&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  	&lt;span class=&quot;comment&quot;&gt;//在bean进行初始化行为之后被调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;Object &lt;span class=&quot;title&quot;&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是这里所说的bean初始化行为主要是指调用&lt;strong&gt;InitializingBean&lt;/strong&gt;的&lt;em&gt;afterPropertiesSet&lt;/em&gt;或者一个自定义的&lt;em&gt;init-method&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://lukaicheng.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读总结--ArrayList</title>
    <link href="https://lukaicheng.github.io/2016/11/17/Reading-JDK-ArrayList/"/>
    <id>https://lukaicheng.github.io/2016/11/17/Reading-JDK-ArrayList/</id>
    <published>2016-11-17T07:26:10.000Z</published>
    <updated>2017-05-17T02:16:56.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure>
<p>ArrayList是List接口的一种可变长的数组实现，支持随机访问，它允许添加包括<strong>null</strong>在内的所有元素。另外，ArrayList的实现并不是线程安全的，如果有多个线程访问，且其中至少一个会涉及<strong>结构性修改</strong>，最好采用并发控制策略，或者采用<em>Collections.synchronizedList</em>进行包装，防止意外的非同步访问。以下所述基于JDK1.7.0_79源码。</p>
<a id="more"></a>
<h2 id="2-基本属性"><a href="#2-基本属性" class="headerlink" title="2 基本属性"></a>2 基本属性</h2><h3 id="2-1-elementData"><a href="#2-1-elementData" class="headerlink" title="2.1 elementData"></a>2.1 elementData</h3><p><strong>elementData</strong>属性是实际存储列表元素的数组缓存区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>
<p>尽管从声明上看它是数组类型，然而它的长度却并不固定，这里的意思并不说是可以在数组创建之后再改变它的大小，而是指当进行容量评估时，如果发现需要扩容或者收缩，那么会重新创建一个数组并伴随一次拷贝，然后将<strong>elementData</strong>指向新数组，从而达到扩容或者收缩的目的。</p>
<h3 id="2-2-size"><a href="#2-2-size" class="headerlink" title="2.2 size"></a>2.2 size</h3><p><strong>size</strong>属性就是列表实际所包含的元素个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>这是因为一般情况下，<strong>elementData</strong>数组并不会被完全占满，所以无法用数组长度等价于元素个数，而又需要有一种机制能够快速反馈元素个数，因此设置了<strong>size</strong>属性来缓存这个信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>size()</strong>方法和<strong>isEmpty()</strong>方法就是通过它才保证调用只需花费常数时间。</p>
<h2 id="3-容量调整"><a href="#3-容量调整" class="headerlink" title="3 容量调整"></a>3 容量调整</h2><h3 id="3-1-扩容"><a href="#3-1-扩容" class="headerlink" title="3.1 扩容"></a>3.1 扩容</h3><p>在新版本JDK中，ArrayList不仅像之前一样拥有私有的动态扩容方法，同时还对外提供了公有方法供调用者主动进行扩容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY,minCapacity);</div><div class="line">    &#125;</div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上所示，<strong>ensureCapacity()</strong>是供外部主动扩容调用的方法，<strong>ensureCapacityInternal()</strong>是供内部扩容调用的方法。这两个方法都是先预估出所需的最小容量，进而通过调用私有方法<strong>ensureExplicitCapacity()</strong>来保证这个容量需求得以满足。接下来看一下这个方法的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span>(minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//扩容到1.5倍</span></div><div class="line">    <span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span>(newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) <span class="comment">//overflow处理</span></div><div class="line">	    newCapacity = hugeCapacity(minCapacity);</div><div class="line">    elementData = Arrays.copyOf(elementData,newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(minCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? </div><div class="line">        Integer.MAX_VALUE : </div><div class="line">        MAX_ARRAY_SIZE; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ensureExplicitCapacity()</strong>方法会首先判定所需的最小容量是否超过当前数组长度，只有在肯定的情况下，才会调用<strong>grow()</strong>方法。观察此方法代码，首先默认将原先的数组长度扩充到1.5倍，接着将新容量与最小容量比较，如果发现新容量小于最小容量，那么将会把新容量赋值为最小容量。而后则是对容量扩充到1.5倍时可能发生的int值溢出的情况，进行一些处理。最后才是真正的进行新数组创建，旧数组元素拷贝的过程。</p>
<h3 id="3-2-收缩"><a href="#3-2-收缩" class="headerlink" title="3.2 收缩"></a>3.2 收缩</h3><p>由于列表在增加元素的时候会进行隐式扩容，从而导致底层数组容量往往超过实际所包含的元素，如果碰到资源敏感的场景下，那么可以使用<strong>trimToSize()</strong>方法进行收缩，使得底层数组容量和实际元素个数持平。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span></span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span>(size &lt; elementData.length)&#123;</div><div class="line">        elementData = Arrays.copyOf(elementData,size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-异常检测"><a href="#4-异常检测" class="headerlink" title="4 异常检测"></a>4 异常检测</h2><h3 id="4-1-rangeCheck"><a href="#4-1-rangeCheck" class="headerlink" title="4.1 rangeCheck"></a>4.1 rangeCheck</h3><p>针对索引范围的检查，ArrayList提供了两个版本的方法：<strong>rangeCheck()</strong>和<strong>rangeCheckForAdd()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index &gt;= size)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>rangeCheck()</strong>主要是针对<em>get()、set()、remove()</em>方法进行索引检测，注意到上面代码并没有对index为负的情况进行检测，这是因为紧跟本方法调用的是对底层数组的访问，而后者会直接检测索引为负的情况，但另外一方面由于隐式扩容的缘故，底层数组包含的实际元素个数往往小于数组长度，因此针对索引超出的情况只能在本方法里判定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>顾名思义，<strong>rangeCheckForAdd()</strong>方法在运行时会被<em>add()、addAll()</em>所调用。相比<strong>rangeCheck()</strong>方法，由于后续不是紧跟对底层数组的访问，因此增加了对于索引为负的情况的判定，同时因为允许元素可以末端添加，去掉了index = size这种情况。</p>
<h3 id="4-2-modCount"><a href="#4-2-modCount" class="headerlink" title="4.2 modCount"></a>4.2 modCount</h3><p><strong>modCount</strong>是ArrayList从父类AbstractList从继承过来的属性，这个属性用于记录列表经历的结构性修改的次数，主要被迭代器(<a href="#61-iterator">iterator</a>和<a href="#62-listiterator">listIterator</a>)使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>迭代器借助于它可以提供fast-fail行为，即当迭代器进行迭代时，如果检测它的值被意外修改，可以抛出ConcurrentModificationException异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount) <span class="comment">//与预期不符合，抛出异常</span></div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="5-增删改查"><a href="#5-增删改查" class="headerlink" title="5 增删改查"></a>5 增删改查</h2><h3 id="5-1-set-amp-get"><a href="#5-1-set-amp-get" class="headerlink" title="5.1 set &amp; get"></a>5.1 set &amp; get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>&#123;</div><div class="line">	rangeCheck(index);</div><div class="line">  	E oldValue = elementData(index);</div><div class="line">  	elementData[index] = element;</div><div class="line">  	<span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">  	rangeCheck(index);</div><div class="line">  	<span class="keyword">return</span> elementData(index);</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">  	reurn (E)elementData[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>众所周知，ArrayList的<strong>set()</strong>和<strong>get()</strong>方法均是常数消耗的操作，这是由于底层元素存储依赖于数组，因而在元素获取时可以直接利用数组随机访问的能力，这一点看上面的源码正好可以印证。</p>
<h3 id="5-2-add"><a href="#5-2-add" class="headerlink" title="5.2 add"></a>5.2 add</h3><p>在一般情况下，从算法分析的角度上说ArrayList的元素添加操作时间复杂度是O(n)，这是因为在当前元素添加元素，往往需要将原先在当前位置的元素以及后续元素，往后移动一位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;</div><div class="line">	rangeCheckForAdd(index);</div><div class="line">  	ensureCapacityInternal(size+<span class="number">1</span>);</div><div class="line">  	System.arraycopy(elementData,index,elementData,index+<span class="number">1</span>,size-index);</div><div class="line">  	elementData[index] = element;</div><div class="line">  	size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，针对只在末尾添加元素的场景，ArrayList做了特别处理，不需要移动元素位置，直接快速赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</div><div class="line">  	ensureCapacityInternal(size+<span class="number">1</span>);</div><div class="line">  	elementData[size++] = e;</div><div class="line">  	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是别忘记，不管是一般情况还是特殊情况，最开始都会进行容量检测，这里可能又是一次元素拷贝的开销，因此在容量预知的情况下，应该在ArrayList实例化的时候指定容量。</p>
<h3 id="5-3-remove"><a href="#5-3-remove" class="headerlink" title="5.3 remove"></a>5.3 remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">	rangeCheck(index);</div><div class="line">	modCount++;</div><div class="line">	E oldValue = elementData(index);<span class="comment">//elementData方法在5.1代码示例给出</span></div><div class="line">  	<span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;<span class="comment">//计算需要移动的元素个数</span></div><div class="line"> 	<span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)</div><div class="line">    	System.arraycopy(elementData,index+<span class="number">1</span>,elementData,index,numMoved);  </div><div class="line"> 	elementData[--size] = <span class="keyword">null</span>;<span class="comment">//实际元素个数-1且将原先末尾置空便于GC </span></div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同<strong>add()</strong>方法类似，<strong>remove()</strong>则是将被删除元素的后续元素前移了一位，达到删除元素的目的，可以看到，同样也是需要一次数组元素的拷贝。另外，还注意到modCount值发生了改变，这是因为<strong>remove()</strong>是一种结构性的修改。</p>
<h2 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="6 迭代器"></a>6 迭代器</h2><h3 id="6-1-iterator"><a href="#6-1-iterator" class="headerlink" title="6.1 iterator"></a><span id="61-iterator">6.1 iterator</span></h3><p>ArrayList声明了内部类<strong>Itr</strong>实现了Iterator接口,通过方法<strong>iterator()</strong>对外提供该迭代器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Itr</strong>在内部定义了三个属性：<strong>cursor</strong>用于表示下一个元素的索引，默认初始为0；<strong>lastRet</strong>用于表示上一个返回元素的索引，初始为-1；<strong>expectedModCount</strong>用于表示期望的修改次数，初始为迭代器实例化时外部列表的modCount值。对于<strong>hasNext()</strong>方法，只要判定<strong>cursor</strong>是否已经和当前列表的<strong>size</strong>相同，即可判定是否还存在下一个元素。对于<strong>next()</strong>方法，由于已经知道需要返回的元素的索引(cursor)，那么可以直接通过数组索引访问获取元素，当然对于索引的校验以及列表的结构修改检测也是必须的，且同时需要更新cursor和lastRet。下面主要详细看下<strong>remove()</strong>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">    checkForComodification();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);<span class="comment">//后续元素前移 &amp; modCount++</span></div><div class="line">        cursor = lastRet;<span class="comment">//元素前移，当前位置的元素的索引发生变化</span></div><div class="line">        lastRet = -<span class="number">1</span>;<span class="comment">//只有在next重新调用之后，才能再次调用remove</span></div><div class="line">        expectedModCount = modCount;<span class="comment">//由于modCount变化，需要重新赋值</span></div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Remove()</strong>方法首先对lastRet进行了检验，结合后续代码中对于lastRet赋值为-1的情况和<strong>next()</strong>方法实现情况，可以知道<strong>remove()</strong>方法只有在<strong>next()</strong>方法被调用一次才能调用并且不能连续连续调用<strong>remove()</strong>方法。接着是上面已经提过的modCount检测。然后才是真正的remove操作，它是通过调用外部对象的remove方法来实现移除最近返回的元素。但是这里要注意的是，调用这个方法，会有两个<strong>“副作用”</strong>：一，被移除元素的后续元素都会前移一位；二，modCount将会+1。因此在最后的代码中，才会看见cursor和expectedModCount被重新赋值，这实质上是为了抵消这两个副作用的影响。</p>
<h3 id="6-2-listIterator"><a href="#6-2-listIterator" class="headerlink" title="6.2 listIterator"></a><span id="62-listiterator">6.2 listIterator</span></h3><p>除了一般版本的迭代器，ArrayList还提供了listIterator，与一般版本相比，不仅可以往后进行迭代，还可以向前迭代。外部可以通过<strong>listIterator()</strong>方法获取该迭代器，该方法返回<strong>ListItr</strong>内部类的一个实例，<strong>ListItr</strong>继承关系如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ListItr</strong>继承了<strong>Itr</strong>，在<em>hasNext()、next()、remove()</em>这几个方法的实现上，并未改变其父类中的行为，仅仅是对<em>hasPrevious()、previous()、nextIndex()、previousIndex()、set()、add()</em>方法进行了实现。<strong>nextIndex()</strong>和<strong>previousIndex()</strong>两个方法都可以直接借助cursor属性进行返回。<strong>hasPrevious()</strong>方法同<strong>hasNext()</strong>实现类似，只不过这次是需要判定cursor是否同0相同,即可判断出是否还存在上一个元素。同样，对于<strong>previous()</strong>方法可参考<strong>next()</strong>，只不过需要返回的是数据中cursor-1位置的数据。<strong>set()</strong>方法则是简单的调用了外部列表的<strong>set()</strong>方法。最后主要来讲一下<strong>add()</strong>方法的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    checkForComodification();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = cursor;</div><div class="line">        ArrayList.<span class="keyword">this</span>.add(i, e);<span class="comment">//当前位置元素以及之后元素后移 &amp; modCount++</span></div><div class="line">        cursor = i + <span class="number">1</span>;<span class="comment">//重新赋值当前游标的值</span></div><div class="line">        lastRet = -<span class="number">1</span>;<span class="comment">//保证只有在next或者previous之后，才能重新调用set方法</span></div><div class="line">        expectedModCount = modCount;<span class="comment">//由于modCount变化，需要重新赋值</span></div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Add()</strong>方法首先照例进行列表结构性修改检测，接着实际上调用了外部ArrayList对象的add方法来进行元素添加，类似的，这个调用也会产生两个<strong>“副作用”</strong>：一、原有当前位置以及之后的元素被后移一位；二、modCount将会+1。因此，在后续代码中可以看到对cursor进行了+1操作，同时将新的modCount值赋予expectedModCount。</p>
<h2 id="7-子列表"><a href="#7-子列表" class="headerlink" title="7 子列表"></a>7 子列表</h2><p>ArrayList对外暴露了<strong>subList()</strong>方法来提供子列表的功能，但是子列表并不是重新创建的列表对象，它仅仅只是一个<em>视图</em>。<strong>SubList</strong>内部实际保存了父列表的对象引用，并定义了<strong>parentOffset</strong>和<strong>offset</strong>两个偏移量。其中<strong>parentOffset</strong>表示子列表相对于父列表的偏移量，<strong>offset</strong>表示子列表相对于根列表的偏移量。在实际调用时，子列表的<em>get()、set()</em>方法会通过使用<strong>offset</strong>来快速进行索引，而<em>add()、remove()</em>方法则会借助父对象引用和<strong>parentOffset</strong>来调用父类相应方法实现子列表的相应功能。</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/subList.png" alt="offset说明"></p>
<p>由于子列表和父列表实质上是共用同一份底层数据，那么对于子列表进行的元素添加、删除操作，父列表上也同样会得到体现，然而从反方向看却需要警惕，如果对父列表进行元素添加、删除等涉及结构性修改的操作，会导致已生成的子列表变成不可用(这是因为modCount机制导致)。</p>
<h2 id="8-序列化"><a href="#8-序列化" class="headerlink" title="8 序列化"></a>8 序列化</h2><p>从ArrayList的类声明中可以知道其实现了<strong>Serializable</strong>接口，能够序列化和反序列化，然而细心的可能已经发现<strong>elementData</strong>属性却是被transient修饰，但是实际序列化过程中，元素数据却并没有丢失。其实，这是因为<strong>elementData</strong>数组实际长度往往大于实际元素个数，如果直接采用默认序列化方式，那么其实除了会序列化实际元素之外，还会去序列化数组的剩余空间，并且在反序列化的时候会浪费额外空间来存储。所以，通过实现了<strong>writeObject()</strong>和<strong>readObject</strong>，ArrayList实现了自定义的序列化和反序列化过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">	<span class="keyword">throws</span> java.io.IOException&#123;</div><div class="line">        <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line">        s.defaultWriteObject();</div><div class="line">        s.writeInt(size);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">            s.writeObject(elementData[i]);<span class="comment">//根据实际size序列化数据</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></div><div class="line">	<span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</div><div class="line">        elementData = EMPTY_ELEMENTDATA;</div><div class="line">        s.defaultReadObject();</div><div class="line">        s.readInt();</div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</div><div class="line">            ensureCapacityInternal(size);</div><div class="line">            Object[] a = elementData;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">                a[i] = s.readObject();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从实际的源码不难看出，在实际序列化过程中，通过size来确定实际元素并逐个序列化，从而避免序列化不必要的元素，这不仅效率更高，且在反序列化重新构建ArrayList时可以给<strong>elementData</strong>设置合适的容量，避免空间浪费。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html" target="_blank" rel="external">ArrayList API</a></p>
<p><a href="http://stackoverflow.com/questions/38950203/why-does-arraylistrangecheck-not-check-if-the-index-is-negative" target="_blank" rel="external">why-does-arraylistrangecheck-not-check-if-the-index-is-negative</a></p>
<p><a href="http://stackoverflow.com/questions/9848129/why-does-arraylist-use-transient-storage" target="_blank" rel="external">why-does-arraylist-use-transient-storage</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;1 简介&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;RandomAccess&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Cloneable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ArrayList是List接口的一种可变长的数组实现，支持随机访问，它允许添加包括&lt;strong&gt;null&lt;/strong&gt;在内的所有元素。另外，ArrayList的实现并不是线程安全的，如果有多个线程访问，且其中至少一个会涉及&lt;strong&gt;结构性修改&lt;/strong&gt;，最好采用并发控制策略，或者采用&lt;em&gt;Collections.synchronizedList&lt;/em&gt;进行包装，防止意外的非同步访问。以下所述基于JDK1.7.0_79源码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java collections framework" scheme="https://lukaicheng.github.io/tags/Java-collections-framework/"/>
    
  </entry>
  
  <entry>
    <title>ABNF应知应会</title>
    <link href="https://lukaicheng.github.io/2016/11/02/ABNF/"/>
    <id>https://lukaicheng.github.io/2016/11/02/ABNF/</id>
    <published>2016-11-02T03:38:02.000Z</published>
    <updated>2017-05-17T02:16:43.999Z</updated>
    
    <content type="html"><![CDATA[<p>ABNF英文全称是Augmented Backus-Naur Form，这是一种基于BNF的元语言，在很多的Internet technical Specification中用于定义正式语法。</p>
<a id="more"></a>
<h2 id="1-规则定义"><a href="#1-规则定义" class="headerlink" title="1 规则定义"></a>1 规则定义</h2><h3 id="1-1-规则形式"><a href="#1-1-规则形式" class="headerlink" title="1.1 规则形式"></a>1.1 规则形式</h3><p>规则定义的形式如下所示</p>
<blockquote>
<p>name = elements crlf</p>
</blockquote>
<p>其中</p>
<ul>
<li>name 表示规则名称，对于它的解释可以参考<a href="#12-规则名称">1.2 规则名称</a>，</li>
<li>elements 可以是一个或者多个规则或者最终值的操作组合，关于最终值可以参考<a href="#13-最终值">1.3 最终值</a></li>
<li>crlf 行结束标志(回车换行)</li>
</ul>
<p>为了视觉效果，规则定义需要左对齐，如果碰上一个规则需要多行的情况，那么接下来的行需要缩进，而它们对齐和缩进的基准是ABNF规则的第一行。</p>
<h3 id="1-2-规则名称"><a href="#1-2-规则名称" class="headerlink" title="1.2 规则名称"></a><span id="12-规则名称">1.2 规则名称</span></h3><p>规则名称由字母开头，后续可以包含字母、数字和连字符(减号)组合的序列,其中需要注意的是规则名称<strong>不区分大小写</strong>。而且不像BNF，用尖括号(<strong>&lt;</strong>，<strong>&gt;</strong>)包围规则名称并不是必需的。</p>
<h3 id="1-3-最终值"><a href="#1-3-最终值" class="headerlink" title="1.3 最终值"></a><span id="13-最终值">1.3 最终值</span></h3><p>所有规则最终都会由最终值来解释，而所谓的最终值是由一个指定的基数再结合一个或者多个数值字符来指定。当前已经定义的基数有三种：</p>
<ul>
<li>b： 二进制 binary</li>
<li>d： 十进制 decimal</li>
<li>x： 十六进制 hexadecimal</li>
</ul>
<p>以回车CR为例，下面的规则分别采用十进制和十六进制为基数</p>
<blockquote>
<p>CR = %d13</p>
<p>CR = %x0D</p>
</blockquote>
<p>当碰到需要表示多个字符时，可以用<strong>“.”</strong>来进行串联</p>
<blockquote>
<p>false = %x66.61.6c.73.65</p>
</blockquote>
<p>同时ABNF也允许使用双引号来直接说明文字文本</p>
<blockquote>
<p>command = “pwd”</p>
</blockquote>
<p>但是需要注意的是，这里字符串是大小写不敏感，且使用的字符集是US-ASCII。因此上面的字符串会匹配”pwd”,”Pwd”,”pWd”,”pwD”,”PWd”,”pWD”,”PwD”和”PWD”。如果我们需要字符串具备大小写敏感特性，那么可以分别指定每个字符，有下面两种方式:</p>
<blockquote>
<p>command = %d112.119.100</p>
<p>command = %d112 %d119 %d109</p>
</blockquote>
<h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h2><h3 id="2-1-级联-R1-R2"><a href="#2-1-级联-R1-R2" class="headerlink" title="2.1 级联 R1 R2"></a>2.1 级联 R1 R2</h3><p>可以将已经定义的规则和最终值按顺序列出来，元素之间用空白字符来进行区分。</p>
<blockquote>
<p>foo = %x61</p>
<p>bar = %x62</p>
<p>mumble = foo bar foo</p>
</blockquote>
<p>在上面的示例里规则foo匹配a，bar匹配b，mumble将匹配aba。</p>
<h3 id="2-2-选择-R1-R2"><a href="#2-2-选择-R1-R2" class="headerlink" title="2.2 选择 R1 / R2"></a>2.2 选择 R1 / R2</h3><p>可以通过在规则之间插入/，让规则变成可选。</p>
<blockquote>
<p>ws = %x20 / %x09 / %x0A / %x0D</p>
</blockquote>
<p>在上面的示例里，规则ws会匹配空格、制表符、换行、回车。</p>
<h3 id="2-3-增量选择-R1-R2"><a href="#2-3-增量选择-R1-R2" class="headerlink" title="2.3 增量选择 R1 =/ R2"></a>2.3 增量选择 R1 =/ R2</h3><p>有时候，我们可能希望有一种增量的方式，可以在旧规则里添加新的功能可选项，这个时候增量选择就比较适用，它通过<strong>=/</strong>来将新规则变成旧规则的可选项之一。</p>
<blockquote>
<p>ruleset = alt1 / alt2</p>
<p>ruleset =/ alt3</p>
<p>ruleset =/ alt4 / alt5</p>
</blockquote>
<p>最终ruleset等价于下面所示：</p>
<blockquote>
<p>ruleset = alt1 / alt2 / alt3 / alt4 / alt5</p>
</blockquote>
<h3 id="2-4-值范围"><a href="#2-4-值范围" class="headerlink" title="2.4 值范围"></a>2.4 值范围</h3><p>通过使用连字符(-),ABNF还可以实现指定一个范围的值。</p>
<blockquote>
<p>DIGIT = %x30-39</p>
</blockquote>
<p>上面的示例规则，实际上等价于下面的规则</p>
<blockquote>
<p>DIGIT = “0” / “1” / “2” / “3” / “4” / “5” / “6” / “7” / “8” / “9”</p>
</blockquote>
<h3 id="2-5-序列组合-R1-R2"><a href="#2-5-序列组合-R1-R2" class="headerlink" title="2.5 序列组合 (R1 R2)"></a>2.5 序列组合 (R1 R2)</h3><p>用括号将连个规则包围起来，这样的组合会被当成单个元素，对于一些优先级比较容易混淆的情况尤其推荐使用它。</p>
<blockquote>
<p>group = elem (foo / bar) blat</p>
</blockquote>
<p>上面的示例会匹配 elem foo blat 或者 elem bar blat，但是如果我们不使用括号的话</p>
<blockquote>
<p>group = elem foo / bar blat</p>
</blockquote>
<p>由于操作符优先级的关系，其实group会匹配elem foo或bar blat。</p>
<h3 id="2-6-不定量重复-Rule"><a href="#2-6-不定量重复-Rule" class="headerlink" title="2.6 不定量重复 *Rule"></a>2.6 不定量重复 *Rule</h3><p>我们可以在规则的前面添加*，来表示重复这个规则，完整的形式是m*nRule。其中m和n都是可选的，m表示至少重复多少次，n表示最多重复多少次。两者默认的值分别是0和无穷大，所以*Rule表示允许任意次数的重复包括零次。1*Rule表示规则至少重复一次，1*2Rule表示规则重复一次或两次,3*3Rule表示规则必须且仅允许重复3次。</p>
<h3 id="2-7-定量重复-nRule"><a href="#2-7-定量重复-nRule" class="headerlink" title="2.7 定量重复 nRule"></a>2.7 定量重复 nRule</h3><p>除了不定量重复之外，ABNF也允许指定次数的重复，完整形式是nRule，其实等价于n*nRule。运用这个方式，2DIGIT就表示2位数字，3ALPHA表示长度为3的字符串。</p>
<h3 id="2-8-可选序列-Rule"><a href="#2-8-可选序列-Rule" class="headerlink" title="2.8 可选序列 [Rule]"></a>2.8 可选序列 [Rule]</h3><p>可以使用方括号来圈定一个可选序列</p>
<blockquote>
<p>rule = [foo bar]</p>
</blockquote>
<p>等价于</p>
<blockquote>
<p>rule = *1(foo bar)</p>
</blockquote>
<h3 id="2-9-注释"><a href="#2-9-注释" class="headerlink" title="2.9 注释"></a>2.9 注释</h3><p>对于规则的说明，也提供了注释方式，以分号<strong>;</strong>开始，并到此行的结束。</p>
<blockquote>
<p>false = %x66.61.6c.73.65   ; false</p>
</blockquote>
<h2 id="3-操作优先级"><a href="#3-操作优先级" class="headerlink" title="3.操作优先级"></a>3.操作优先级</h2><p>以下给出了从高(结合最紧密)到低(结合最松散)的优先级:</p>
<ol>
<li>规则名、最终值</li>
<li>注释</li>
<li>值范围</li>
<li>重复</li>
<li>序列组合、可选序列</li>
<li>级联</li>
<li>选择</li>
</ol>
<p>由于级联和选择混用时，往往会让人困惑，建议使用序列组合来消除歧义。</p>
<h2 id="4-核心规则"><a href="#4-核心规则" class="headerlink" title="4.核心规则"></a>4.核心规则</h2><table>
<thead>
<tr>
<th style="text-align:left">规则</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ALPHA</td>
<td style="text-align:left">%x41-5A / %x61-7A</td>
<td style="text-align:left">A-Z / a-z</td>
</tr>
<tr>
<td style="text-align:left">BIT</td>
<td style="text-align:left">“0” / “1”</td>
<td style="text-align:left">二进制字符</td>
</tr>
<tr>
<td style="text-align:left">CHAR</td>
<td style="text-align:left">%x01-7F</td>
<td style="text-align:left">任何7位的US-ASCII字符，不包括Nul(%x00)</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR</td>
<td style="text-align:left">%x21-7E</td>
<td style="text-align:left">可见(可打印)字符</td>
</tr>
<tr>
<td style="text-align:left">CR</td>
<td style="text-align:left">%x0D</td>
<td style="text-align:left">回车</td>
</tr>
<tr>
<td style="text-align:left">LF</td>
<td style="text-align:left">%x0A</td>
<td style="text-align:left">换行</td>
</tr>
<tr>
<td style="text-align:left">CRLF</td>
<td style="text-align:left">CR LF</td>
<td style="text-align:left">回车换行</td>
</tr>
<tr>
<td style="text-align:left">CTL</td>
<td style="text-align:left">%x00-1F / %x7F</td>
<td style="text-align:left">控制字符</td>
</tr>
<tr>
<td style="text-align:left">DIGIT</td>
<td style="text-align:left">%x30-39</td>
<td style="text-align:left">数字0-9</td>
</tr>
<tr>
<td style="text-align:left">DQUOTE</td>
<td style="text-align:left">%x22</td>
<td style="text-align:left">双引号</td>
</tr>
<tr>
<td style="text-align:left">HEXDIG</td>
<td style="text-align:left">DIGIT / “A” / “B” / “C” / “D” / “E” / “F”</td>
<td style="text-align:left">十六进制字符</td>
</tr>
<tr>
<td style="text-align:left">OCTET</td>
<td style="text-align:left">%x00-FF</td>
<td style="text-align:left">8位数据</td>
</tr>
<tr>
<td style="text-align:left">HTAB</td>
<td style="text-align:left">%x09</td>
<td style="text-align:left">横向制表符</td>
</tr>
<tr>
<td style="text-align:left">SP</td>
<td style="text-align:left">%x20</td>
<td style="text-align:left">空格</td>
</tr>
<tr>
<td style="text-align:left">WSP</td>
<td style="text-align:left">SP / HTAB</td>
<td style="text-align:left">空格或者横向制表符</td>
</tr>
<tr>
<td style="text-align:left">LWSP</td>
<td style="text-align:left">*(WSP / CRLF WSP)</td>
<td style="text-align:left">空白行(不要用于邮件头，另外在其他上下文中使用也需要小心)</td>
</tr>
</tbody>
</table>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://tools.ietf.org/html/rfc5234" target="_blank" rel="external">RFC 5234</a><br><a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%85%85%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F" target="_blank" rel="external">维基百科 扩充巴科斯范式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ABNF英文全称是Augmented Backus-Naur Form，这是一种基于BNF的元语言，在很多的Internet technical Specification中用于定义正式语法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RCFile文件格式下的Hive表bigint类型列值读取问题</title>
    <link href="https://lukaicheng.github.io/2016/10/25/Hive-VLong-to-Java-long/"/>
    <id>https://lukaicheng.github.io/2016/10/25/Hive-VLong-to-Java-long/</id>
    <published>2016-10-25T02:25:39.000Z</published>
    <updated>2017-05-17T02:16:30.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景缘起"><a href="#背景缘起" class="headerlink" title="背景缘起"></a>背景缘起</h2><p>目前在将hive部分列数据采集到hbase时，由于平台将原来hive表的文件格式从SequenceFile调整到RCFile，因此需要对原来的离线数据采集程序进行修改。然而在实际修改开发过程中，却碰到了程序读取hive列字段，值为乱码的问题。</p>
<a id="more"></a>
<h2 id="初步诊断"><a href="#初步诊断" class="headerlink" title="初步诊断"></a>初步诊断</h2><p>由于之前的文件格式是SequenceFile，不管列在hive中数据类型是什么，程序都可以以统一的读取String方式来读取。因此在变更为RCFile方式时，仅仅调整了输入部分，转换依然采用了Bytes.toString方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convertHiveBigint</span><span class="params">(BytesRefWritable brw)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    <span class="keyword">return</span> Bytes.toString(brw.getData(),brw.getStart(),brw.getLength());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是针对乱码的字段，查看了hive表对应列的数据类型，发现是Bigint，那么我想可能不仅仅需要调整输入，最终转换的地方也需要调整为Bytes.toLong。于是将代码修改如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">convertHiveBigint</span><span class="params">(BytesRefWritable brw)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    <span class="keyword">return</span> Bytes.toLong(brw.getData(),brw.getStart(),brw.getLength());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="奇怪的-118"><a href="#奇怪的-118" class="headerlink" title="奇怪的-118"></a>奇怪的-118</h2><p>就在我以为上面的修改可以奏效之时，实际运行时却抛出了鲜红的异常</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/exception.png" alt="异常信息"></p>
<p>从异常信息里不难看出，对于Java long来说，已经规定是需要8个字节，然而在上面代码里，最终转换时确变成了7个字节。为此，对程序进行了调试，将原始的brw.getData打印了出来</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/bytesarray.png" alt="原始字节数据"></p>
<p>结合调试得到的offset和length值，获知到程序真实运行时取值为 <strong>-118 1 58 92 103 58 -127</strong>，而我直接通过hive sql查询列原始值，并转换成字节数组为 <strong>0 0 1 58 92 103 58 -127</strong>。观察这两组数据不难发现，不同之处在于前者开头是-118，而后者是0 0。而再仔细观察上面的字节数组，会很惊讶的发现，好像每隔6位，就会出现-118。这个时候，我就猜测假如能够弄明白-118的来源，那么我们的问题有很大概率就可以解决了。</p>
<h2 id="无心插柳"><a href="#无心插柳" class="headerlink" title="无心插柳"></a>无心插柳</h2><p>正当我对这个问题陷入困顿的时候，无意间发现了下图的信息(莫非这个是hive序列化类(⊙o⊙)？)</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/hive.png" alt="hive信息"></p>
<p>于是，我马上翻开了这个类的源码，根据类上面的注释确认了该类确实能将hive column序列化为BytesRefArrayWritable。该类只有initialize和serialize这两个方法，针对序列化过程，不难猜到入口肯定是serialize这个方法，由于需要序列化的列类型是Bigint，因此判定进入如下分支:</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/serialize.png" alt="序列化"></p>
<p>进入此方法后，是一个switch case分支选择，根据bigint和long对应关系，判定进入如下case：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/caselong.png" alt="Long"></p>
<p>最终代码导航下去，你会发现实际的转换过程在方法<strong>LazyBinaryUtils.writeVLongToByteArray</strong>,这也解开了上面-118的问题,不过限于水平目前还不太理解这段代码的含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">writeVLongToByteArray</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">long</span> l)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (l &gt;= -<span class="number">112</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123;</div><div class="line">    bytes[offset] = (<span class="keyword">byte</span>) l;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> len = -<span class="number">112</span>;</div><div class="line">  <span class="keyword">if</span> (l &lt; <span class="number">0</span>) &#123;</div><div class="line">    l ^= -<span class="number">1L</span>; <span class="comment">// take one's complement'</span></div><div class="line">    len = -<span class="number">120</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> tmp = l;</div><div class="line">  <span class="keyword">while</span> (tmp != <span class="number">0</span>) &#123;</div><div class="line">    tmp = tmp &gt;&gt; <span class="number">8</span>;</div><div class="line">    len--;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  bytes[offset] = (<span class="keyword">byte</span>) len;</div><div class="line"></div><div class="line">  len = (len &lt; -<span class="number">120</span>) ? -(len + <span class="number">120</span>) : -(len + <span class="number">112</span>);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = len; idx != <span class="number">0</span>; idx--) &#123;</div><div class="line">    <span class="keyword">int</span> shiftbits = (idx - <span class="number">1</span>) * <span class="number">8</span>;</div><div class="line">    <span class="keyword">long</span> mask = <span class="number">0xFFL</span> &lt;&lt; shiftbits;</div><div class="line">    bytes[offset+<span class="number">1</span>-(idx - len)] = (<span class="keyword">byte</span>) ((l &amp; mask) &gt;&gt; shiftbits);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span> + len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>最后，LazyBinaryUtils不仅提供了VLong序列化成字节数组的过程，同时也提供反序列化的过程，实际程序中只需调用LazyBinaryUtils.readVLongFromByteArray方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">readVLongFromByteArray</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset)</span> </span>&#123;</div><div class="line">  <span class="keyword">byte</span> firstByte = bytes[offset++];</div><div class="line">  <span class="keyword">int</span> len = WritableUtils.decodeVIntSize(firstByte);</div><div class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> firstByte;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">long</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; len-<span class="number">1</span>; idx++) &#123;</div><div class="line">    <span class="keyword">byte</span> b = bytes[offset++];</div><div class="line">    i = i &lt;&lt; <span class="number">8</span>;</div><div class="line">    i = i | (b &amp; <span class="number">0xFF</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (WritableUtils.isNegativeVInt(firstByte) ? ~i : i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结扩展"><a href="#总结扩展" class="headerlink" title="总结扩展"></a>总结扩展</h2><p>序列化和反序列化是相对的，在不了解具体序列化规则的情况下，去进行反序列化，有时候可能碰到问题。而在这个场景里，hive在序列化bigint时，是按照不定长的VLONG形式进行转换，如果我们依然按照原先读取long类型方式，那么就会碰到问题，因此一定要选择对应的反序列化方式才能获取到正确的值。在以后碰到hive不同列类型转换成Java中的类型时，可以参考LazyBinarySerDe.serialize对应类型的序列化方式，来寻找API中对应的反序列化方式，抑或自己动手造轮子。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景缘起&quot;&gt;&lt;a href=&quot;#背景缘起&quot; class=&quot;headerlink&quot; title=&quot;背景缘起&quot;&gt;&lt;/a&gt;背景缘起&lt;/h2&gt;&lt;p&gt;目前在将hive部分列数据采集到hbase时，由于平台将原来hive表的文件格式从SequenceFile调整到RCFile，因此需要对原来的离线数据采集程序进行修改。然而在实际修改开发过程中，却碰到了程序读取hive列字段，值为乱码的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RCFile" scheme="https://lukaicheng.github.io/tags/RCFile/"/>
    
      <category term="Hive" scheme="https://lukaicheng.github.io/tags/Hive/"/>
    
  </entry>
  
</feed>
