<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Lucifer"><meta name="description" content="背景缘起目前在将hive部分列数据采集到hbase时，由于平台将原来hive表的文件格式从SequenceFile调整到RCFile，因此需要对原来的离线数据采集程序进行修改。然而在实际修改开发过程中，却碰到了程序读取hive列字段，值为乱码的问题。"><meta name="keywords" content="RCFile,Hive"><title>RCFile文件格式下的Hive表bigint类型列值读取问题 · Way to architect</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="https://lukaicheng.github.io/2016/10/25/Hive-VLong-to-Java-long/"><link rel="alternate" href="/atom.xml" title="Way to architect"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Way to architect</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">RCFile文件格式下的Hive表bigint类型列值读取问题</h1><span class="post-time">Oct 25, 2016</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Contents</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景缘起"><span class="toc-text">背景缘起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初步诊断"><span class="toc-text">初步诊断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#奇怪的-118"><span class="toc-text">奇怪的-118</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#无心插柳"><span class="toc-text">无心插柳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决问题"><span class="toc-text">解决问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结扩展"><span class="toc-text">总结扩展</span></a></li></ol></div><div class="post-content"><h2 id="背景缘起"><a href="#背景缘起" class="headerlink" title="背景缘起"></a>背景缘起</h2><p>目前在将hive部分列数据采集到hbase时，由于平台将原来hive表的文件格式从SequenceFile调整到RCFile，因此需要对原来的离线数据采集程序进行修改。然而在实际修改开发过程中，却碰到了程序读取hive列字段，值为乱码的问题。</p>
<a id="more"></a>
<h2 id="初步诊断"><a href="#初步诊断" class="headerlink" title="初步诊断"></a>初步诊断</h2><p>由于之前的文件格式是SequenceFile，不管列在hive中数据类型是什么，程序都可以以统一的读取String方式来读取。因此在变更为RCFile方式时，仅仅调整了输入部分，转换依然采用了Bytes.toString方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convertHiveBigint</span><span class="params">(BytesRefWritable brw)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    <span class="keyword">return</span> Bytes.toString(brw.getData(),brw.getStart(),brw.getLength());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是针对乱码的字段，查看了hive表对应列的数据类型，发现是Bigint，那么我想可能不仅仅需要调整输入，最终转换的地方也需要调整为Bytes.toLong。于是将代码修改如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">convertHiveBigint</span><span class="params">(BytesRefWritable brw)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    <span class="keyword">return</span> Bytes.toLong(brw.getData(),brw.getStart(),brw.getLength());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="奇怪的-118"><a href="#奇怪的-118" class="headerlink" title="奇怪的-118"></a>奇怪的-118</h2><p>就在我以为上面的修改可以奏效之时，实际运行时却抛出了鲜红的异常</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/exception.png" alt="异常信息"></p>
<p>从异常信息里不难看出，对于Java long来说，已经规定是需要8个字节，然而在上面代码里，最终转换时确变成了7个字节。为此，对程序进行了调试，将原始的brw.getData打印了出来</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/bytesarray.png" alt="原始字节数据"></p>
<p>结合调试得到的offset和length值，获知到程序真实运行时取值为 <strong>-118 1 58 92 103 58 -127</strong>，而我直接通过hive sql查询列原始值，并转换成字节数组为 <strong>0 0 1 58 92 103 58 -127</strong>。观察这两组数据不难发现，不同之处在于前者开头是-118，而后者是0 0。而再仔细观察上面的字节数组，会很惊讶的发现，好像每隔6位，就会出现-118。这个时候，我就猜测假如能够弄明白-118的来源，那么我们的问题有很大概率就可以解决了。</p>
<h2 id="无心插柳"><a href="#无心插柳" class="headerlink" title="无心插柳"></a>无心插柳</h2><p>正当我对这个问题陷入困顿的时候，无意间发现了下图的信息(莫非这个是hive序列化类(⊙o⊙)？)</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/hive.png" alt="hive信息"></p>
<p>于是，我马上翻开了这个类的源码，根据类上面的注释确认了该类确实能将hive column序列化为BytesRefArrayWritable。该类只有initialize和serialize这两个方法，针对序列化过程，不难猜到入口肯定是serialize这个方法，由于需要序列化的列类型是Bigint，因此判定进入如下分支:</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/serialize.png" alt="序列化"></p>
<p>进入此方法后，是一个switch case分支选择，根据bigint和long对应关系，判定进入如下case：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/caselong.png" alt="Long"></p>
<p>最终代码导航下去，你会发现实际的转换过程在方法<strong>LazyBinaryUtils.writeVLongToByteArray</strong>,这也解开了上面-118的问题,不过限于水平目前还不太理解这段代码的含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">writeVLongToByteArray</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">long</span> l)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (l &gt;= -<span class="number">112</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123;</div><div class="line">    bytes[offset] = (<span class="keyword">byte</span>) l;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> len = -<span class="number">112</span>;</div><div class="line">  <span class="keyword">if</span> (l &lt; <span class="number">0</span>) &#123;</div><div class="line">    l ^= -<span class="number">1L</span>; <span class="comment">// take one's complement'</span></div><div class="line">    len = -<span class="number">120</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> tmp = l;</div><div class="line">  <span class="keyword">while</span> (tmp != <span class="number">0</span>) &#123;</div><div class="line">    tmp = tmp &gt;&gt; <span class="number">8</span>;</div><div class="line">    len--;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  bytes[offset] = (<span class="keyword">byte</span>) len;</div><div class="line"></div><div class="line">  len = (len &lt; -<span class="number">120</span>) ? -(len + <span class="number">120</span>) : -(len + <span class="number">112</span>);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = len; idx != <span class="number">0</span>; idx--) &#123;</div><div class="line">    <span class="keyword">int</span> shiftbits = (idx - <span class="number">1</span>) * <span class="number">8</span>;</div><div class="line">    <span class="keyword">long</span> mask = <span class="number">0xFFL</span> &lt;&lt; shiftbits;</div><div class="line">    bytes[offset+<span class="number">1</span>-(idx - len)] = (<span class="keyword">byte</span>) ((l &amp; mask) &gt;&gt; shiftbits);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span> + len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>最后，LazyBinaryUtils不仅提供了VLong序列化成字节数组的过程，同时也提供反序列化的过程，实际程序中只需调用LazyBinaryUtils.readVLongFromByteArray方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">readVLongFromByteArray</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset)</span> </span>&#123;</div><div class="line">  <span class="keyword">byte</span> firstByte = bytes[offset++];</div><div class="line">  <span class="keyword">int</span> len = WritableUtils.decodeVIntSize(firstByte);</div><div class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> firstByte;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">long</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; len-<span class="number">1</span>; idx++) &#123;</div><div class="line">    <span class="keyword">byte</span> b = bytes[offset++];</div><div class="line">    i = i &lt;&lt; <span class="number">8</span>;</div><div class="line">    i = i | (b &amp; <span class="number">0xFF</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (WritableUtils.isNegativeVInt(firstByte) ? ~i : i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结扩展"><a href="#总结扩展" class="headerlink" title="总结扩展"></a>总结扩展</h2><p>序列化和反序列化是相对的，在不了解具体序列化规则的情况下，去进行反序列化，有时候可能碰到问题。而在这个场景里，hive在序列化bigint时，是按照不定长的VLONG形式进行转换，如果我们依然按照原先读取long类型方式，那么就会碰到问题，因此一定要选择对应的反序列化方式才能获取到正确的值。在以后碰到hive不同列类型转换成Java中的类型时，可以参考LazyBinarySerDe.serialize对应类型的序列化方式，来寻找API中对应的反序列化方式，抑或自己动手造轮子。</p>
</div></article><div class="tags"><a href="/tags/RCFile/">RCFile</a><a href="/tags/Hive/">Hive</a></div><div class="paginator"><a href="/2016/11/02/ABNF/" class="prev"><i class="iconfont icon-left"></i><span> Prev</span></a></div><section id="comments"><div id="disqus_thread"></div></section><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://lukaicheng.github.io/2016/10/25/Hive-VLong-to-Java-long/';
    this.page.identifier = '2016/10/25/Hive-VLong-to-Java-long/';
    this.page.title = 'RCFile文件格式下的Hive表bigint类型列值读取问题';
};
(function() {
var d = document, s = d.createElement('script');

s.src = '//Your disqus ID.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();</script></section><footer><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2017<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Lucifer</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>