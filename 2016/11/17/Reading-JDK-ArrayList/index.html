<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Lucifer"><meta name="description" content="1简介12publicclassArrayList&amp;lt;E&amp;gt;extendsAbstractList&amp;lt;E&amp;gt;implementsList&amp;lt;E&amp;gt;,RandomAccess,Cloneable,java.io.Serial"><meta name="keywords" content="Java collections framework"><title>JDK源码阅读总结--ArrayList · Way to architect</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="https://lukaicheng.github.io/2016/11/17/Reading-JDK-ArrayList/"><link rel="alternate" href="/atom.xml" title="Way to architect"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Way to architect</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Accueil</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">JDK源码阅读总结--ArrayList</h1><span class="post-time">Nov 17, 2016</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Sommaire</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-简介"><span class="toc-text">1 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-基本属性"><span class="toc-text">2 基本属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-elementData"><span class="toc-text">2.1 elementData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-size"><span class="toc-text">2.2 size</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-容量调整"><span class="toc-text">3 容量调整</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-扩容"><span class="toc-text">3.1 扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-收缩"><span class="toc-text">3.2 收缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-异常检测"><span class="toc-text">4 异常检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-rangeCheck"><span class="toc-text">4.1 rangeCheck</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-modCount"><span class="toc-text">4.2 modCount</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-增删改查"><span class="toc-text">5 增删改查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-set-amp-get"><span class="toc-text">5.1 set & get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-add"><span class="toc-text">5.2 add</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-remove"><span class="toc-text">5.3 remove</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-迭代器"><span class="toc-text">6 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-iterator"><span class="toc-text">6.1 iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-listIterator"><span class="toc-text">6.2 listIterator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-子列表"><span class="toc-text">7 子列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-序列化"><span class="toc-text">8 序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div><div class="post-content"><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure>
<p>ArrayList是List接口的一种可变长的数组实现，支持随机访问，它允许添加包括<strong>null</strong>在内的所有元素。另外，ArrayList的实现并不是线程安全的，如果有多个线程访问，且其中至少一个会涉及<strong>结构性修改</strong>，最好采用并发控制策略，或者采用<em>Collections.synchronizedList</em>进行包装，防止意外的非同步访问。以下所述基于JDK1.7.0_79源码。</p>
<a id="more"></a>
<h2 id="2-基本属性"><a href="#2-基本属性" class="headerlink" title="2 基本属性"></a>2 基本属性</h2><h3 id="2-1-elementData"><a href="#2-1-elementData" class="headerlink" title="2.1 elementData"></a>2.1 elementData</h3><p><strong>elementData</strong>属性是实际存储列表元素的数组缓存区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>
<p>尽管从声明上看它是数组类型，然而它的长度却并不固定，这里的意思并不说是可以在数组创建之后再改变它的大小，而是指当进行容量评估时，如果发现需要扩容或者收缩，那么会重新创建一个数组并伴随一次拷贝，然后将<strong>elementData</strong>指向新数组，从而达到扩容或者收缩的目的。</p>
<h3 id="2-2-size"><a href="#2-2-size" class="headerlink" title="2.2 size"></a>2.2 size</h3><p><strong>size</strong>属性就是列表实际所包含的元素个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>这是因为一般情况下，<strong>elementData</strong>数组并不会被完全占满，所以无法用数组长度等价于元素个数，而又需要有一种机制能够快速反馈元素个数，因此设置了<strong>size</strong>属性来缓存这个信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>size()</strong>方法和<strong>isEmpty()</strong>方法就是通过它才保证调用只需花费常数时间。</p>
<h2 id="3-容量调整"><a href="#3-容量调整" class="headerlink" title="3 容量调整"></a>3 容量调整</h2><h3 id="3-1-扩容"><a href="#3-1-扩容" class="headerlink" title="3.1 扩容"></a>3.1 扩容</h3><p>在新版本JDK中，ArrayList不仅像之前一样拥有私有的动态扩容方法，同时还对外提供了公有方法供调用者主动进行扩容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY,minCapacity);</div><div class="line">    &#125;</div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上所示，<strong>ensureCapacity()</strong>是供外部主动扩容调用的方法，<strong>ensureCapacityInternal()</strong>是供内部扩容调用的方法。这两个方法都是先预估出所需的最小容量，进而通过调用私有方法<strong>ensureExplicitCapacity()</strong>来保证这个容量需求得以满足。接下来看一下这个方法的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span>(minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//扩容到1.5倍</span></div><div class="line">    <span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span>(newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) <span class="comment">//overflow处理</span></div><div class="line">	    newCapacity = hugeCapacity(minCapacity);</div><div class="line">    elementData = Arrays.copyOf(elementData,newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(minCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? </div><div class="line">        Integer.MAX_VALUE : </div><div class="line">        MAX_ARRAY_SIZE; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ensureExplicitCapacity()</strong>方法会首先判定所需的最小容量是否超过当前数组长度，只有在肯定的情况下，才会调用<strong>grow()</strong>方法。观察此方法代码，首先默认将原先的数组长度扩充到1.5倍，接着将新容量与最小容量比较，如果发现新容量小于最小容量，那么将会把新容量赋值为最小容量。而后则是对容量扩充到1.5倍时可能发生的int值溢出的情况，进行一些处理。最后才是真正的进行新数组创建，旧数组元素拷贝的过程。</p>
<h3 id="3-2-收缩"><a href="#3-2-收缩" class="headerlink" title="3.2 收缩"></a>3.2 收缩</h3><p>由于列表在增加元素的时候会进行隐式扩容，从而导致底层数组容量往往超过实际所包含的元素，如果碰到资源敏感的场景下，那么可以使用<strong>trimToSize()</strong>方法进行收缩，使得底层数组容量和实际元素个数持平。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span></span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span>(size &lt; elementData.length)&#123;</div><div class="line">        elementData = Arrays.copyOf(elementData,size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-异常检测"><a href="#4-异常检测" class="headerlink" title="4 异常检测"></a>4 异常检测</h2><h3 id="4-1-rangeCheck"><a href="#4-1-rangeCheck" class="headerlink" title="4.1 rangeCheck"></a>4.1 rangeCheck</h3><p>针对索引范围的检查，ArrayList提供了两个版本的方法：<strong>rangeCheck()</strong>和<strong>rangeCheckForAdd()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index &gt;= size)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>rangeCheck()</strong>主要是针对<em>get()、set()、remove()</em>方法进行索引检测，注意到上面代码并没有对index为负的情况进行检测，这是因为紧跟本方法调用的是对底层数组的访问，而后者会直接检测索引为负的情况，但另外一方面由于隐式扩容的缘故，底层数组包含的实际元素个数往往小于数组长度，因此针对索引超出的情况只能在本方法里判定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>顾名思义，<strong>rangeCheckForAdd()</strong>方法在运行时会被<em>add()、addAll()</em>所调用。相比<strong>rangeCheck()</strong>方法，由于后续不是紧跟对底层数组的访问，因此增加了对于索引为负的情况的判定，同时因为允许元素可以末端添加，去掉了index = size这种情况。</p>
<h3 id="4-2-modCount"><a href="#4-2-modCount" class="headerlink" title="4.2 modCount"></a>4.2 modCount</h3><p><strong>modCount</strong>是ArrayList从父类AbstractList从继承过来的属性，这个属性用于记录列表经历的结构性修改的次数，主要被迭代器(<a href="#61-iterator">iterator</a>和<a href="#62-listiterator">listIterator</a>)使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>迭代器借助于它可以提供fast-fail行为，即当迭代器进行迭代时，如果检测它的值被意外修改，可以抛出ConcurrentModificationException异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount) <span class="comment">//与预期不符合，抛出异常</span></div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="5-增删改查"><a href="#5-增删改查" class="headerlink" title="5 增删改查"></a>5 增删改查</h2><h3 id="5-1-set-amp-get"><a href="#5-1-set-amp-get" class="headerlink" title="5.1 set &amp; get"></a>5.1 set &amp; get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>&#123;</div><div class="line">	rangeCheck(index);</div><div class="line">  	E oldValue = elementData(index);</div><div class="line">  	elementData[index] = element;</div><div class="line">  	<span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">  	rangeCheck(index);</div><div class="line">  	<span class="keyword">return</span> elementData(index);</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">  	reurn (E)elementData[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>众所周知，ArrayList的<strong>set()</strong>和<strong>get()</strong>方法均是常数消耗的操作，这是由于底层元素存储依赖于数组，因而在元素获取时可以直接利用数组随机访问的能力，这一点看上面的源码正好可以印证。</p>
<h3 id="5-2-add"><a href="#5-2-add" class="headerlink" title="5.2 add"></a>5.2 add</h3><p>在一般情况下，从算法分析的角度上说ArrayList的元素添加操作时间复杂度是O(n)，这是因为在当前元素添加元素，往往需要将原先在当前位置的元素以及后续元素，往后移动一位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;</div><div class="line">	rangeCheckForAdd(index);</div><div class="line">  	ensureCapacityInternal(size+<span class="number">1</span>);</div><div class="line">  	System.arraycopy(elementData,index,elementData,index+<span class="number">1</span>,size-index);</div><div class="line">  	elementData[index] = element;</div><div class="line">  	size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，针对只在末尾添加元素的场景，ArrayList做了特别处理，不需要移动元素位置，直接快速赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</div><div class="line">  	ensureCapacityInternal(size+<span class="number">1</span>);</div><div class="line">  	elementData[size++] = e;</div><div class="line">  	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是别忘记，不管是一般情况还是特殊情况，最开始都会进行容量检测，这里可能又是一次元素拷贝的开销，因此在容量预知的情况下，应该在ArrayList实例化的时候指定容量。</p>
<h3 id="5-3-remove"><a href="#5-3-remove" class="headerlink" title="5.3 remove"></a>5.3 remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">	rangeCheck(index);</div><div class="line">	modCount++;</div><div class="line">	E oldValue = elementData(index);<span class="comment">//elementData方法在5.1代码示例给出</span></div><div class="line">  	<span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;<span class="comment">//计算需要移动的元素个数</span></div><div class="line"> 	<span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)</div><div class="line">    	System.arraycopy(elementData,index+<span class="number">1</span>,elementData,index,numMoved);  </div><div class="line"> 	elementData[--size] = <span class="keyword">null</span>;<span class="comment">//实际元素个数-1且将原先末尾置空便于GC </span></div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同<strong>add()</strong>方法类似，<strong>remove()</strong>则是将被删除元素的后续元素前移了一位，达到删除元素的目的，可以看到，同样也是需要一次数组元素的拷贝。另外，还注意到modCount值发生了改变，这是因为<strong>remove()</strong>是一种结构性的修改。</p>
<h2 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="6 迭代器"></a>6 迭代器</h2><h3 id="6-1-iterator"><a href="#6-1-iterator" class="headerlink" title="6.1 iterator"></a><span id="61-iterator">6.1 iterator</span></h3><p>ArrayList声明了内部类<strong>Itr</strong>实现了Iterator接口,通过方法<strong>iterator()</strong>对外提供该迭代器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Itr</strong>在内部定义了三个属性：<strong>cursor</strong>用于表示下一个元素的索引，默认初始为0；<strong>lastRet</strong>用于表示上一个返回元素的索引，初始为-1；<strong>expectedModCount</strong>用于表示期望的修改次数，初始为迭代器实例化时外部列表的modCount值。对于<strong>hasNext()</strong>方法，只要判定<strong>cursor</strong>是否已经和当前列表的<strong>size</strong>相同，即可判定是否还存在下一个元素。对于<strong>next()</strong>方法，由于已经知道需要返回的元素的索引(cursor)，那么可以直接通过数组索引访问获取元素，当然对于索引的校验以及列表的结构修改检测也是必须的，且同时需要更新cursor和lastRet。下面主要详细看下<strong>remove()</strong>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">    checkForComodification();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);<span class="comment">//后续元素前移 &amp; modCount++</span></div><div class="line">        cursor = lastRet;<span class="comment">//元素前移，当前位置的元素的索引发生变化</span></div><div class="line">        lastRet = -<span class="number">1</span>;<span class="comment">//只有在next重新调用之后，才能再次调用remove</span></div><div class="line">        expectedModCount = modCount;<span class="comment">//由于modCount变化，需要重新赋值</span></div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Remove()</strong>方法首先对lastRet进行了检验，结合后续代码中对于lastRet赋值为-1的情况和<strong>next()</strong>方法实现情况，可以知道<strong>remove()</strong>方法只有在<strong>next()</strong>方法被调用一次才能调用并且不能连续连续调用<strong>remove()</strong>方法。接着是上面已经提过的modCount检测。然后才是真正的remove操作，它是通过调用外部对象的remove方法来实现移除最近返回的元素。但是这里要注意的是，调用这个方法，会有两个<strong>“副作用”</strong>：一，被移除元素的后续元素都会前移一位；二，modCount将会+1。因此在最后的代码中，才会看见cursor和expectedModCount被重新赋值，这实质上是为了抵消这两个副作用的影响。</p>
<h3 id="6-2-listIterator"><a href="#6-2-listIterator" class="headerlink" title="6.2 listIterator"></a><span id="62-listiterator">6.2 listIterator</span></h3><p>除了一般版本的迭代器，ArrayList还提供了listIterator，与一般版本相比，不仅可以往后进行迭代，还可以向前迭代。外部可以通过<strong>listIterator()</strong>方法获取该迭代器，该方法返回<strong>ListItr</strong>内部类的一个实例，<strong>ListItr</strong>继承关系如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ListItr</strong>继承了<strong>Itr</strong>，在<em>hasNext()、next()、remove()</em>这几个方法的实现上，并未改变其父类中的行为，仅仅是对<em>hasPrevious()、previous()、nextIndex()、previousIndex()、set()、add()</em>方法进行了实现。<strong>nextIndex()</strong>和<strong>previousIndex()</strong>两个方法都可以直接借助cursor属性进行返回。<strong>hasPrevious()</strong>方法同<strong>hasNext()</strong>实现类似，只不过这次是需要判定cursor是否同0相同,即可判断出是否还存在上一个元素。同样，对于<strong>previous()</strong>方法可参考<strong>next()</strong>，只不过需要返回的是数据中cursor-1位置的数据。<strong>set()</strong>方法则是简单的调用了外部列表的<strong>set()</strong>方法。最后主要来讲一下<strong>add()</strong>方法的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    checkForComodification();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = cursor;</div><div class="line">        ArrayList.<span class="keyword">this</span>.add(i, e);<span class="comment">//当前位置元素以及之后元素后移 &amp; modCount++</span></div><div class="line">        cursor = i + <span class="number">1</span>;<span class="comment">//重新赋值当前游标的值</span></div><div class="line">        lastRet = -<span class="number">1</span>;<span class="comment">//保证只有在next或者previous之后，才能重新调用set方法</span></div><div class="line">        expectedModCount = modCount;<span class="comment">//由于modCount变化，需要重新赋值</span></div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Add()</strong>方法首先照例进行列表结构性修改检测，接着实际上调用了外部ArrayList对象的add方法来进行元素添加，类似的，这个调用也会产生两个<strong>“副作用”</strong>：一、原有当前位置以及之后的元素被后移一位；二、modCount将会+1。因此，在后续代码中可以看到对cursor进行了+1操作，同时将新的modCount值赋予expectedModCount。</p>
<h2 id="7-子列表"><a href="#7-子列表" class="headerlink" title="7 子列表"></a>7 子列表</h2><p>ArrayList对外暴露了<strong>subList()</strong>方法来提供子列表的功能，但是子列表并不是重新创建的列表对象，它仅仅只是一个<em>视图</em>。<strong>SubList</strong>内部实际保存了父列表的对象引用，并定义了<strong>parentOffset</strong>和<strong>offset</strong>两个偏移量。其中<strong>parentOffset</strong>表示子列表相对于父列表的偏移量，<strong>offset</strong>表示子列表相对于根列表的偏移量。在实际调用时，子列表的<em>get()、set()</em>方法会通过使用<strong>offset</strong>来快速进行索引，而<em>add()、remove()</em>方法则会借助父对象引用和<strong>parentOffset</strong>来调用父类相应方法实现子列表的相应功能。</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/subList.png" alt="offset说明"></p>
<p>由于子列表和父列表实质上是共用同一份底层数据，那么对于子列表进行的元素添加、删除操作，父列表上也同样会得到体现，然而从反方向看却需要警惕，如果对父列表进行元素添加、删除等涉及结构性修改的操作，会导致已生成的子列表变成不可用(这是因为modCount机制导致)。</p>
<h2 id="8-序列化"><a href="#8-序列化" class="headerlink" title="8 序列化"></a>8 序列化</h2><p>从ArrayList的类声明中可以知道其实现了<strong>Serializable</strong>接口，能够序列化和反序列化，然而细心的可能已经发现<strong>elementData</strong>属性却是被transient修饰，但是实际序列化过程中，元素数据却并没有丢失。其实，这是因为<strong>elementData</strong>数组实际长度往往大于实际元素个数，如果直接采用默认序列化方式，那么其实除了会序列化实际元素之外，还会去序列化数组的剩余空间，并且在反序列化的时候会浪费额外空间来存储。所以，通过实现了<strong>writeObject()</strong>和<strong>readObject</strong>，ArrayList实现了自定义的序列化和反序列化过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">	<span class="keyword">throws</span> java.io.IOException&#123;</div><div class="line">        <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line">        s.defaultWriteObject();</div><div class="line">        s.writeInt(size);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">            s.writeObject(elementData[i]);<span class="comment">//根据实际size序列化数据</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></div><div class="line">	<span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</div><div class="line">        elementData = EMPTY_ELEMENTDATA;</div><div class="line">        s.defaultReadObject();</div><div class="line">        s.readInt();</div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</div><div class="line">            ensureCapacityInternal(size);</div><div class="line">            Object[] a = elementData;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">                a[i] = s.readObject();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从实际的源码不难看出，在实际序列化过程中，通过size来确定实际元素并逐个序列化，从而避免序列化不必要的元素，这不仅效率更高，且在反序列化重新构建ArrayList时可以给<strong>elementData</strong>设置合适的容量，避免空间浪费。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html" target="_blank" rel="external">ArrayList API</a></p>
<p><a href="http://stackoverflow.com/questions/38950203/why-does-arraylistrangecheck-not-check-if-the-index-is-negative" target="_blank" rel="external">why-does-arraylistrangecheck-not-check-if-the-index-is-negative</a></p>
<p><a href="http://stackoverflow.com/questions/9848129/why-does-arraylist-use-transient-storage" target="_blank" rel="external">why-does-arraylist-use-transient-storage</a></p>
</div></article><div class="tags"><a href="/tags/Java-collections-framework/">Java collections framework</a></div><div class="paginator"><a href="/2017/05/13/Spring5-validation-translate/" class="prev"><i class="iconfont icon-left"></i><span> Précédent</span></a><a href="/2016/11/02/ABNF/" class="next"><span>Suivant</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div id="disqus_thread"></div></section><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://lukaicheng.github.io/2016/11/17/Reading-JDK-ArrayList/';
    this.page.identifier = '2016/11/17/Reading-JDK-ArrayList/';
    this.page.title = 'JDK源码阅读总结--ArrayList';
};
(function() {
var d = document, s = d.createElement('script');

s.src = '//Your disqus ID.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();</script></section><footer><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2017<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Lucifer</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>