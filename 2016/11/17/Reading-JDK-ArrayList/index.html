<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Lucifer"><meta name="description" content="1简介ArrayList是List接口的一种可增长数组实现。以下基于JDK1.7.0_79。2基本属性2.1elementDataelementData属性是实际存储列表元素的数组缓存区。1privatetransientObject[]elementData;"><meta name="keywords" content=""><title>JDK源码阅读--ArrayList · 羽逝神伤</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="https://lukaicheng.github.io/2016/11/17/Reading-JDK-ArrayList/"><link rel="alternate" href="/atom.xml" title="羽逝神伤"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">羽逝神伤</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">JDK源码阅读--ArrayList</h1><span class="post-time">Nov 17, 2016</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Contents</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-简介"><span class="toc-text">1 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-基本属性"><span class="toc-text">2 基本属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-elementData"><span class="toc-text">2.1 elementData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-size"><span class="toc-text">2.2 size</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-容量调整"><span class="toc-text">3 容量调整</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-扩容"><span class="toc-text">3.1 扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-收缩"><span class="toc-text">3.2 收缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-异常检测"><span class="toc-text">4 异常检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-rangeCheck"><span class="toc-text">4.1 rangeCheck</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-modCount"><span class="toc-text">4.2 modCount</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-迭代器"><span class="toc-text">5 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-iterator"><span class="toc-text">5.1 iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-listIterator"><span class="toc-text">5.2 listIterator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div><div class="post-content"><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>ArrayList是List接口的一种可增长数组实现。<br>以下基于JDK1.7.0_79。</p>
<h2 id="2-基本属性"><a href="#2-基本属性" class="headerlink" title="2 基本属性"></a>2 基本属性</h2><h3 id="2-1-elementData"><a href="#2-1-elementData" class="headerlink" title="2.1 elementData"></a>2.1 elementData</h3><p><strong>elementData</strong>属性是实际存储列表元素的数组缓存区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>
<p>尽管从声明上看它是数组类型，然而它的长度却并不固定，这里的意思并不说是可以在数组创建之后再改变它的大小，而是指当进行容量评估时，如果发现需要扩容或者收缩，那么会重新创建一个数组并伴随一次拷贝，然后将<strong>elementData</strong>指向新数组，从而达到扩容或者收缩的目的。</p>
<h3 id="2-2-size"><a href="#2-2-size" class="headerlink" title="2.2 size"></a>2.2 size</h3><p><strong>size</strong>属性就是列表实际所包含的元素个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>这是因为一般情况下，<strong>elementData</strong>数组并不会被完全占满，所以无法用数组长度等价于元素个数，而又需要有一种机制能够快速反馈元素个数，因此设置了<strong>size</strong>属性来缓存这个信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>size()</strong>方法和<strong>isEmpty()</strong>方法就是通过它才保证调用只需花费常数时间。</p>
<h2 id="3-容量调整"><a href="#3-容量调整" class="headerlink" title="3 容量调整"></a>3 容量调整</h2><h3 id="3-1-扩容"><a href="#3-1-扩容" class="headerlink" title="3.1 扩容"></a>3.1 扩容</h3><p>在新版本JDK中，ArrayList不仅像之前一样拥有私有的动态扩容方法，同时还对外提供了公有方法供调用者主动进行扩容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY,minCapacity);</div><div class="line">    &#125;</div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上所示，<strong>ensureCapacity()</strong>是供外部主动扩容调用的方法，<strong>ensureCapacityInternal()</strong>是供内部扩容调用的方法。这两个方法都是先预估出所需的最小容量，进而通过调用私有方法<strong>ensureExplicitCapacity()</strong>来保证这个容量需求得以满足。接下来看一下这个方法的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span>(minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//扩容到1.5倍</span></div><div class="line">    <span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span>(newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) <span class="comment">//overflow处理</span></div><div class="line">	    newCapacity = hugeCapacity(minCapacity);</div><div class="line">    elementData = Arrays.copyOf(elementData,newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(minCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? </div><div class="line">        Integer.MAX_VALUE : </div><div class="line">        MAX_ARRAY_SIZE; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ensureExplicitCapacity()</strong>方法会首先判定所需的最小容量是否超过当前数组长度，只有在肯定的情况下，才会调用<strong>grow()</strong>方法。观察此方法代码，首先默认将原先的数组长度扩充到1.5倍，接着将新容量与最小容量比较，如果发现新容量小于最小容量，那么将会把新容量赋值为最小容量。而后则是对容量扩充到1.5倍时可能发生的int值溢出的情况，进行一些处理。最后才是真正的进行新数组创建，旧数组元素拷贝的过程。</p>
<h3 id="3-2-收缩"><a href="#3-2-收缩" class="headerlink" title="3.2 收缩"></a>3.2 收缩</h3><p>由于列表在增加元素的时候会进行隐式扩容，从而导致底层数组容量往往超过实际所包含的元素，如果碰到资源敏感的场景下，那么可以使用<strong>trimToSize()</strong>方法进行收缩，使得底层数组容量和实际元素个数持平。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span></span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span>(size &lt; elementData.length)&#123;</div><div class="line">        elementData = Arrays.copyOf(elementData,size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-异常检测"><a href="#4-异常检测" class="headerlink" title="4 异常检测"></a>4 异常检测</h2><h3 id="4-1-rangeCheck"><a href="#4-1-rangeCheck" class="headerlink" title="4.1 rangeCheck"></a>4.1 rangeCheck</h3><p>针对索引范围的检查，ArrayList提供了两个版本的方法：<strong>rangeCheck()</strong>和<strong>rangeCheckForAdd()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index &gt;= size)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>rangeCheck()</strong>主要是针对<em>get()、set()、remove()</em>方法进行索引检测，注意到上面代码并没有对index为负的情况进行检测，这是因为紧跟本方法调用的是对底层数组的访问，而后者会直接检测索引为负的情况，但另外一方面由于隐式扩容的缘故，底层数组包含的实际元素个数往往小于数组长度，因此针对索引超出的情况只能在本方法里判定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>顾名思义，<strong>rangeCheckForAdd()</strong>方法在运行时会被<em>add()、addAll()</em>所调用。相比<strong>rangeCheck()</strong>方法，由于后续不是紧跟对底层数组的访问，因此增加了对于索引为负的情况的判定，同时因为允许元素可以末端添加，去掉了index = size这种情况。</p>
<h3 id="4-2-modCount"><a href="#4-2-modCount" class="headerlink" title="4.2 modCount"></a>4.2 modCount</h3><p><strong>modCount</strong>是ArrayList从父类AbstractList从继承过来的属性，这个属性用于记录列表经历的结构性修改的次数，主要被迭代器(<a href="#51-iterator">iterator</a>和<a href="#52-listiterator">listIterator</a>)使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>迭代器借助于它可以提供fast-fail行为，即当迭代器进行迭代时，如果检测它的值被意外修改，可以抛出ConcurrentModificationException异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount) <span class="comment">//与预期不符合，抛出异常</span></div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5 迭代器"></a>5 迭代器</h2><h3 id="5-1-iterator"><a href="#5-1-iterator" class="headerlink" title="5.1 iterator"></a><span id="51-iterator">5.1 iterator</span></h3><p>ArrayList声明了内部类<strong>Itr</strong>实现了Iterator接口,通过方法<strong>iterator()</strong>对外提供该迭代器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Itr</strong>在内部定义了三个属性：<strong>cursor</strong>用于表示下一个元素的索引，默认初始为0；<strong>lastRet</strong>用于表示上一个返回元素的索引，初始为-1；<strong>expectedModCount</strong>用于表示期望的修改次数，初始为迭代器实例化时外部列表的modCount值。对于<strong>hasNext()</strong>方法，只要判定<strong>cursor</strong>是否已经和当前列表的<strong>size</strong>相同，即可判定是否还存在下一个元素。对于<strong>next()</strong>方法，由于已经知道需要返回的元素的索引(cursor)，那么可以直接通过数组索引访问获取元素，当然对于索引的校验以及列表的结构修改检测也是必须的，且同时需要更新cursor和lastRet。下面主要详细看下<strong>remove()</strong>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">    checkForComodification();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);<span class="comment">//后续元素前移 &amp; modCount++</span></div><div class="line">        cursor = lastRet;<span class="comment">//元素前移，当前位置的元素的索引发生变化</span></div><div class="line">        lastRet = -<span class="number">1</span>;<span class="comment">//只有在next重新调用之后，才能再次调用remove</span></div><div class="line">        expectedModCount = modCount;<span class="comment">//由于modCount变化，需要重新赋值</span></div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Remove()</strong>方法首先对lastRet进行了检验，结合后续代码中对于lastRet赋值为-1的情况和<strong>next()</strong>方法实现情况，可以知道<strong>remove()</strong>方法只有在<strong>next()</strong>方法被调用一次才能调用并且不能连续连续调用<strong>remove()</strong>方法。接着是上面已经提过的modCount检测。然后才是真正的remove操作，它是通过调用外部对象的remove方法来实现移除最近返回的元素。但是这里要注意的是，调用这个方法，会有两个<strong>“副作用”</strong>：一，被移除元素的后续元素都会前移一位；二，modCount将会+1。因此在最后的代码中，才会看见cursor和expectedModCount被重新赋值，这实质上是为了抵消这两个副作用的影响。</p>
<h3 id="5-2-listIterator"><a href="#5-2-listIterator" class="headerlink" title="5.2 listIterator"></a><span id="52-listiterator">5.2 listIterator</span></h3><p>除了一般版本的迭代器，ArrayList还提供了listIterator，与一般版本相比，不仅可以往后进行迭代，还可以向前迭代。外部可以通过<strong>listIterator()</strong>方法获取该迭代器，该方法返回<strong>ListItr</strong>内部类的一个实例，<strong>ListItr</strong>继承关系如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ListItr</strong>继承了<strong>Itr</strong>，在<em>hasNext()、next()、remove()</em>这几个方法的实现上，并未改变其父类中的行为，仅仅是对<em>hasPrevious()、previous()、nextIndex()、previousIndex()、set()、add()</em>方法进行了实现。<strong>nextIndex()</strong>和<strong>previousIndex()</strong>两个方法都可以直接借助cursor属性进行返回。<strong>hasPrevious()</strong>方法同<strong>hasNext()</strong>实现类似，只不过这次是需要判定cursor是否同0相同,即可判断出是否还存在上一个元素。同样，对于<strong>previous()</strong>方法可参考<strong>next()</strong>，只不过需要返回的是数据中cursor-1位置的数据。<strong>set()</strong>方法则是简单的调用了外部列表的<strong>set()</strong>方法。最后主要来讲一下<strong>add()</strong>方法的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    checkForComodification();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = cursor;</div><div class="line">        ArrayList.<span class="keyword">this</span>.add(i, e);<span class="comment">//当前位置元素以及之后元素后移 &amp; modCount++</span></div><div class="line">        cursor = i + <span class="number">1</span>;<span class="comment">//重新赋值当前游标的值</span></div><div class="line">        lastRet = -<span class="number">1</span>;<span class="comment">//保证只有在next或者previous之后，才能重新调用set方法</span></div><div class="line">        expectedModCount = modCount;<span class="comment">//由于modCount变化，需要重新赋值</span></div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Add()</strong>方法首先照例进行列表结构性修改检测，接着实际上调用了外部ArrayList对象的add方法来进行元素添加，类似的，这个调用也会产生两个<strong>“副作用”</strong>：一、原有当前位置以及之后的元素被后移一位；二、modCount将会+1。因此，在后续代码中可以看到对cursor进行了+1操作，同时将新的modCount值赋予expectedModCount。</p>
<p><strong>未完待续…</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://stackoverflow.com/questions/38950203/why-does-arraylistrangecheck-not-check-if-the-index-is-negative" target="_blank" rel="external">why-does-arraylistrangecheck-not-check-if-the-index-is-negative</a></p>
</div></article><div class="tags"></div><div class="paginator"><a href="/2016/11/02/ABNF/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div id="disqus_thread"></div></section><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://lukaicheng.github.io/2016/11/17/Reading-JDK-ArrayList/';
    this.page.identifier = '2016/11/17/Reading-JDK-ArrayList/';
    this.page.title = 'JDK源码阅读--ArrayList';
};
(function() {
var d = document, s = d.createElement('script');

s.src = '//Your disqus ID.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();</script></section><footer><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Lucifer</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>