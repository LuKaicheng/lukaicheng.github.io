<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Lucifer"><meta name="description" content="引言HashMap是程序开发中经常被使用到的一个哈希表实现，然而在多线程情况下，使用HashMap却可能引发程序异常，这是因为它被设计为非线程安全。如果想要确保在多线程场景下的正确性，那么早些时候可能除了使用sychronized或者HashTable之外，并没有太好的选择。但是"><meta name="keywords" content="JUC,ConcurrentHashMap"><title>并发容器－理解ConcurrentHashMap(JDK7版本) · Way to architect</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="https://lukaicheng.github.io/2017/07/27/ConcurrentHashMap-JDK7-comprehension/"><link rel="alternate" href="/atom.xml" title="Way to architect"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Way to architect</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">并发容器－理解ConcurrentHashMap(JDK7版本)</h1><span class="post-time">Jul 27, 2017</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Contents</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整体概述"><span class="toc-text">整体概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Segment的惰性初始化"><span class="toc-text">Segment的惰性初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get方法分析"><span class="toc-text">get方法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#元素均匀分布的考虑"><span class="toc-text">元素均匀分布的考虑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Segment的定位"><span class="toc-text">Segment的定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashEntry的定位"><span class="toc-text">HashEntry的定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put方法分析"><span class="toc-text">put方法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#scanAndLockForPut"><span class="toc-text">scanAndLockForPut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩容"><span class="toc-text">扩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#先乐观后悲观的size"><span class="toc-text">先乐观后悲观的size</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div><div class="post-content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>HashMap</code>是程序开发中经常被使用到的一个哈希表实现，然而在多线程情况下，使用<code>HashMap</code>却可能引发程序异常，这是因为它被设计为非线程安全。如果想要确保在多线程场景下的正确性，那么早些时候可能除了使用<code>sychronized</code>或者<code>HashTable</code>之外，并没有太好的选择。但是当1.5版本引入JUC包之后，在你的工具库里就多了一个更好的选择：<code>ConcurrentHashMap</code>。 </p>
<a id="more"></a>
<h2 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h2><p>作为一个哈希表实现，<code>ConcurrentHashMap</code>解决冲突的方法采用的是和<code>HashMap</code>一样的链址法(<em>数组+链表</em>)：不同hash值的项位于数组的不同索引位置，相同hash的项在数组同一个索引位置通过链表串联起来。同时为了满足多线程安全且提供比<code>HashTable</code>更好的并发性能，它引入了分段锁，使得锁的粒度更小，以支持更多的线程可以同时对其进行读写操作。其整体的数据结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/ConcurrentHashMap_Jdk7.png" alt="整体数据结构视图"></p>
<p>其中<code>HashEntry</code>代表了实际存储的元素，声明了键值属性以及一个指向冲突节点的next属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">	<span class="keyword">final</span> K key;</div><div class="line">	<span class="keyword">volatile</span> V value;</div><div class="line">	<span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</div><div class="line">	<span class="comment">//省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Segment</code>是整个类的核心，它是<code>ReentrantLock</code>的子类，一个实例代表了一个分段锁，它的内部声明了其负责管理的集合子集<code>table</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="comment">//实际管理的HashEntry数组</span></div><div class="line">	<span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</div><div class="line">	<span class="comment">//HashEntry数组实际包含的元素数量</span></div><div class="line">	<span class="keyword">transient</span> <span class="keyword">int</span> count;</div><div class="line">	<span class="comment">//HashEntry修改次数</span></div><div class="line">	<span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line">	<span class="comment">//元素临届值，当超过这个值需要进行rehash</span></div><div class="line">  	<span class="keyword">transient</span> <span class="keyword">int</span> threshold;</div><div class="line">	<span class="comment">//省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ConcurrentHashMap</code>在类中声明了<code>Segment</code>数组用来分段管理整个集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ConcurrentHashMap声明分段锁集合</span></div><div class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</div></pre></td></tr></table></figure>
<h2 id="Segment的惰性初始化"><a href="#Segment的惰性初始化" class="headerlink" title="Segment的惰性初始化"></a>Segment的惰性初始化</h2><p>为了减少空间的占用，<code>Segment</code>分段锁数组被设计成惰性初始化，除了在构造阶段会创建起始位置的<code>Segment</code>分段锁，剩下的分段锁根据需要才进行创建。(<em>个人猜测应该是考虑到<code>Segment</code>对象里包含了<code>HashEntry</code>数组，后者会占用不少空间</em>)</p>
<p>查看构造器可以看到，尽管创建了<code>Segment</code>分段锁数组，但是其中只有s0被真正赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line">						<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel) &#123;</div><div class="line">	<span class="comment">//省略部分代码</span></div><div class="line">	Segment&lt;K,V&gt; s0 =</div><div class="line">		<span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</div><div class="line">						(HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</div><div class="line">	Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</div><div class="line">	UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></div><div class="line">	<span class="keyword">this</span>.segments = ss;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剩余分段锁的创建会发生在方法<code>ensureSegment</code>中，主要是往<code>ConcurrentHashMap</code>添加数据的时候触发(<em>另外，方法<code>size</code>和<code>containsValue</code>如果碰上需要加锁尝试的情况，也会触发此方法</em>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</div><div class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></div><div class="line">    Segment&lt;K,V&gt; seg;</div><div class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</div><div class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></div><div class="line">        <span class="keyword">int</span> cap = proto.table.length;</div><div class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</div><div class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</div><div class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</div><div class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</div><div class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></div><div class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</div><div class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</div><div class="line">                   == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> seg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建<code>Segment</code>对象并没有使用锁，而是基于volatile+CAS的方式：首先根据索引计算要新创建的<code>Segment</code>对象的偏移位置，通过<code>UNSAFE.getObjectVolatile</code>方法(<em>具有volatile读的内存语义</em>)来获取此位置的最新值，如果返回值为空，则判定还未初始化，那么以构造器阶段创建的<code>Segment</code>对象为原型，创建<code>HashEntry</code>数组，再构造新的<code>Segment</code>对象，最后用CAS的方式尝试赋值。另外需要注意的是，在构建新的<code>Segment</code>过程中之所以需要重新检测，是因为整个过程中并没有加锁，不保证原子性，其他线程也同样有机会抢修改此偏移位置的值，所以需要持续检测最新值。</p>
<h2 id="get方法分析"><a href="#get方法分析" class="headerlink" title="get方法分析"></a>get方法分析</h2><p> 同<code>HashMap</code>相比，<code>ConcurrentHashMap</code>的读操作需要先经历<code>Segment</code>定位的过程，而在<code>Segment</code>内部的查找行为与<code>HashMap</code>类似，另外，对于哈希算法的考虑也有所不同。</p>
<h3 id="元素均匀分布的考虑"><a href="#元素均匀分布的考虑" class="headerlink" title="元素均匀分布的考虑"></a>元素均匀分布的考虑</h3><p>众所周知，实现一个哈希表最重要的一点是<strong>让所有的元素尽可能均匀分布</strong>，由于<code>ConcurrentHashMap</code>引入了<code>Segment</code>数组，那么不仅需要满足元素在<code>Segment</code>数组中能够均匀分布，而且在每个<code>Segment</code>内部的 <code>HashEntry</code>数组中也同样需要如此，所以我们看到<code>ConcurrentHashMap</code>在计算哈希值时，采用了特别的哈希算法，其计算出来的哈希值同时考虑了元素在<code>Segment</code>和<code>HashEntry</code>的均匀分布：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = hashSeed;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</div><div class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    h ^= k.hashCode();</div><div class="line"></div><div class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></div><div class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></div><div class="line">    h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</div><div class="line">    h += (h &lt;&lt;   <span class="number">3</span>);</div><div class="line">    h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</div><div class="line">    h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> (<em>这个算法过于复杂，有兴趣可以找相关资料进一步进行了解</em>)</p>
<h3 id="Segment的定位"><a href="#Segment的定位" class="headerlink" title="Segment的定位"></a>Segment的定位</h3><p>由于在实际运行中，定位<code>Segment</code>是很多方法必须经过的一个步骤，因此为了尽可能优化性能，约定了<code>Segment</code>数组的容量只能是2的倍数，这样一来就可以利用位操作来取代原本需要的取模操作。</p>
<p>(<em>当y是2的幂时，x % y = x &amp; (y - 1)，这个思路其实和取掩码的方式一样，不过我没找到严格的数学证明</em>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</div><div class="line">	++sshift;</div><div class="line"> 	ssize &lt;&lt;= <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</div><div class="line"><span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>在实际初始化阶段，首先会计算出<code>Segment</code>数组的容量：<code>ssize</code>，这个值最终会是一个大于或等于所传入并发级别的数当中最小的2的倍数。而另外一个变量<code>sshift</code>表示实际需要多少位来表示<code>Segment</code>数组的容量，两者之间的关系：<strong>ssize = 1 &lt;&lt; sshift</strong>。</p>
<p>借助这两个临时变量，我们就可以设定全局变量<code>segmentShift</code>和<code>segmentMask</code>的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//段掩码，用于参与与运算以快速定位在Segment数组中的索引位置</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</div><div class="line"><span class="comment">//段偏移量，用于指示哈希值中不需要参与定位的低位位数</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentShift;</div></pre></td></tr></table></figure>
<p>那么实际定位的时候是就可以快速的使用位运算来获取具体的索引，这里需要注意的是由哈希算法计算出来的哈希值，最终会排除<code>segmentShift</code>数量的低位，只使用剩余的高位来参与定位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//计算分段锁的索引</span></div><div class="line"><span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div></pre></td></tr></table></figure>
<h3 id="HashEntry的定位"><a href="#HashEntry的定位" class="headerlink" title="HashEntry的定位"></a>HashEntry的定位</h3><p>同<code>Segment</code>数组类似，<code>HashEntry</code>数组容量也必须是2的倍数，其会根据指定的初始容量和<code>Segment</code>数组的大小，来确定初始情况下每个<code>Segment</code>中包含的<code>HashEntry</code>数组大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</div><div class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</div><div class="line">	++c;</div><div class="line"><span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</div><div class="line"><span class="keyword">while</span> (cap &lt; c)</div><div class="line">	cap &lt;&lt;= <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>最后，结合全部来全面分析一下<code>get</code>方法(<em><code>containsKey</code>方法也是类似思路</em>)：</p>
<ol>
<li>首先，计算出传入键的哈希值，并根据位运算计算出可能负责管理此键的<code>Segment</code>分段锁索引。</li>
<li>接着，需要注意的是这里利用<code>UNSAFE.getObjectVolatile</code>方法提供<code>volatile</code>读的内存语义来实现获取最新的<code>Segment</code>值，并判定其是否为空。</li>
<li>然后，如果获取到的分段锁不为空，进一步再利用位运算定位在<code>HashEntry</code>数组上的索引，和步骤2一样的方式获取最新值，并判定其是否匹配。</li>
<li>最后可以看到，如果步骤3第一次尝试失败，那么还会去检测是否有冲突链，再循着冲突链查看是否有匹配元素，否则返回null。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></div><div class="line">    HashEntry&lt;K,V&gt;[] tab;</div><div class="line">    <span class="keyword">int</span> h = hash(key);</div><div class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</div><div class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</div><div class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</div><div class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            K k;</div><div class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="put方法分析"><a href="#put方法分析" class="headerlink" title="put方法分析"></a>put方法分析</h2><p><code>put</code>方法可能是除了<code>get</code>方法之外另一个出镜率比较高的方法，<code>ConcurrentHashMap</code>对外公开的<code>put</code>方法首先会定位<code>Segment</code>，然后确认是否需要进行<code>Segment</code>的初始化行为，这两个过程在上文已经分析过了，在此不再复述，最后我们看到实际的方法功能是由<code>Segment</code>内部的<code>put</code>方法来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Segment&lt;K,V&gt; s;</div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> hash = hash(key);</div><div class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div><div class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></div><div class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></div><div class="line">        s = ensureSegment(j);</div><div class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么就让我们来详细了解一下<code>Segment</code>内部的<code>put</code>方法，以下是整体流程图：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/ConcurrentHashMap_Jdk7_put.png" alt="put方法处理流程"></p>
<p>从图中可以看出，整个方法由锁确保了在并发情况下的正确性，主要的业务逻辑其实比较简单：根据传入元素的哈希值，判断是否已经存在相同键值的元素，如果没有的话，那么就会新建一个<code>HashEntry</code>对象插入(<em>值得注意的是，这个新节点会成为链条的起始节点</em>)，否则根据参数<code>onlyIfAbsent</code>来确定是否更新旧值。整个流程图中，值得我们关注的有两个方法：一个是锁获取方法<code>scanAndLockForPut</code>，另一个扩容方法<code>rehash</code>。</p>
<h3 id="scanAndLockForPut"><a href="#scanAndLockForPut" class="headerlink" title="scanAndLockForPut"></a>scanAndLockForPut</h3><p><code>scanAndLockForPut</code>方法的逻辑同<code>scanAndLock</code>方法非常相似，两者都是先以非阻塞的方式尝试获取锁，当超过有限次数之后，会进入阻塞方式的锁请求。在这个过程当中，两个方法都会对此节点可能的位置进行定位(<em>根据文档的注释，貌似是一种<strong>代码预热</strong>行为，因为在获取锁之后，接下来的动作也将是对节点的定位</em>)。此外，如果节点定位成功之后发现首节点发生变化的话，那么又会重新进行定位(<em>这其中<code>entryForHash</code>方法内部确保了总是能及时看见最新值，由<code>UNSAFE.getObjectVolatile</code>提供友情支持</em>)。而<code>scanAndLockForPut</code>多出来的一个功能点是，它会根据实际情况推测，在一定的条件下预先创建新节点(<em>熟悉hadoop的同学一定不陌生，专门有关于<strong>推测执行</strong>的配置</em>)。以下是完整的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</div><div class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</div><div class="line">    HashEntry&lt;K,V&gt; e = first;</div><div class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></div><div class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</div><div class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></div><div class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></div><div class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                retries = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</div><div class="line">                retries = <span class="number">0</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                e = e.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</div><div class="line">            lock();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</div><div class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</div><div class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></div><div class="line">            retries = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>扩容的基本思路比较简单：创建一个新数组，容量是当前数组的2倍，然后将旧数组的项经过重新散列赋值到新数组，最终将<code>Segment</code>内部的<code>table</code>属性指向新数组。不过有一点需要注意，<strong>由于扩容采用的是倍数2，那么节点经过重新计算的索引值，要么和原先相同，要么新索引＝原索引＋原数组容量</strong>(<em>美团的<a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">这篇文章</a>对这个问题说明的比较清楚</em>)。利用这一点，在碰到冲突链的时候，会首先寻找冲突链中第一个所有后续节点新索引值和其保持一致的节点，然后直接把这部分链赋值到新数组，这样可以避免一些不必要的节点创建行为，下面我将通过源码和图片结合的方式进行一下说明。</p>
<p>我们假设冲突链有5个节点：A、B、C、D、E，其中A和C新索引值是2保持不变，B、D、E新索引值是18：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/chm_rehash_step1.png" alt="初始状态"></p>
<p>扩容过程如果发现冲突链，那么为了减少不必要的节点创建，首先会循着冲突链寻找可复用的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HashEntry&lt;K,V&gt; lastRun = e;</div><div class="line"><span class="keyword">int</span> lastIdx = idx;</div><div class="line"><span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="keyword">null</span>; last = last.next) &#123;</div><div class="line">	<span class="keyword">int</span> k = last.hash &amp; sizeMask;</div><div class="line">	<span class="keyword">if</span> (k != lastIdx) &#123;</div><div class="line">		lastIdx = k;</div><div class="line">		lastRun = last;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段循环结束之后，<code>lastIdx</code>为18，<code>lastRun</code>指向D，这意味着D节点及其后续所有节点都有相同的索引值：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/chm_rehash_step2.png" alt="循环处理"></p>
<p>找到可复用的链之后，先将其赋值到新数组，然后再处理原先冲突链的前半部分，这里值得注意的是插入到新数组之后，节点的顺序会同原先在旧数组的顺序相反：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">newTable[lastIdx] = lastRun;</div><div class="line"><span class="comment">// Clone remaining nodes</span></div><div class="line"><span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</div><div class="line">	V v = p.value;</div><div class="line">	<span class="keyword">int</span> h = p.hash;</div><div class="line">	<span class="keyword">int</span> k = h &amp; sizeMask;</div><div class="line">	HashEntry&lt;K,V&gt; n = newTable[k];</div><div class="line">	newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终结果如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LuKaicheng/lukaicheng.github.io/hexo/source/images/chm_rehash_step3.png" alt="迁移完成"></p>
<h2 id="先乐观后悲观的size"><a href="#先乐观后悲观的size" class="headerlink" title="先乐观后悲观的size"></a>先乐观后悲观的size</h2><p>为了避免热点域问题，<code>ConcurrentHashMap</code> 并没有定义一个统一的<code>size</code>属性，而是在每个<code>Segment</code>对象里定义了<code>size</code>属性，这样一来使得获取整个集合的元素总数不是那么的容易。出于性能以及准确性的权衡，实际中采用的是先乐观后悲观的理念：首先尝试三次在不加锁的情况下，对所有<code>Segment</code>的<code>size</code>和<code>modCount</code>进行累加，如果连续两次<code>modCount</code>的累加结果一致，则认定统计的<code>size</code>总和有效，否则所有的<code>Segment</code>分段锁都进行加锁操作，再进行统计。(<em>方法<code>containsValue</code>也采用了类似的策略</em>)</p>
<p>结合源代码，再好好理解一下整个过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></div><div class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></div><div class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></div><div class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></div><div class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></div><div class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</div><div class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></div><div class="line">            &#125;</div><div class="line">            sum = <span class="number">0L</span>;</div><div class="line">            size = <span class="number">0</span>;</div><div class="line">            overflow = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</div><div class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div><div class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</div><div class="line">                    sum += seg.modCount;</div><div class="line">                    <span class="keyword">int</span> c = seg.count;</div><div class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</div><div class="line">                        overflow = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (sum == last)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            last = sum;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</div><div class="line">                segmentAt(segments, j).unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>顺便提一下，查看相关资料的时候，看见有人提到为何去掉了<code>size</code>属性的<code>volatile</code>修饰符。我根据文档注释猜测，应该是出于性能方面的考虑，因为对于<code>size</code>属性的修改一般都是在加锁的情况下(<em>方法<code>put</code>和方法<code>remove</code>都会先加锁</em>)，因此对于写<code>size</code>的情况下即使去掉<code>volatile</code>的修饰也没有影响，关键在于读取<code>size</code>的场景往往不会加锁(<em>方法<code>isEmpty</code>和方法<code>size</code></em>)，然而内存可见性的保证又是必须的，那么我们回头看看上面的代码解决这个场景的思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div></pre></td></tr></table></figure>
<p><code>Segment</code>对象的获取是通过<code>segmentAt</code>方法，那么再深入看一下此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Segment&lt;K,V&gt; <span class="title">segmentAt</span><span class="params">(Segment&lt;K,V&gt;[] ss, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> u = (j &lt;&lt; SSHIFT) + SBASE;</div><div class="line">    <span class="keyword">return</span> ss == <span class="keyword">null</span> ? <span class="keyword">null</span> :</div><div class="line">        (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(ss, u);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以明显看到，在读取具体的<code>Segment</code>使用了<code>UNSAFE.getObjectVolatile</code>来内存可见性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要分析了<code>ConcurrentHashMap</code>基本原理和的几个常用方法，可以看到除了使用分段锁的概念对锁粒度进行拆分，在几个方法内部还包含了不少的优化之处(<em>代码预热、推测执行、先乐观后悲观等</em>)，其中的思想有不少值得我们学习体会和借鉴。另外，JDK从7升级到8之后，除了带来FP、Stream等一系列新概念之外，<code>ConcurrentHashMap</code>也进行了翻天覆地的重构，新的实现方式已经抛弃了目前的分段锁概念，关于对新的<code>ConcurrentHashMap</code>的学习将留待后期有时间再继续总结。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="external">Java并发编程实战</a></p>
<p><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="external">Java并发编程的艺术</a></p>
<p><a href="https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/sun/misc/Unsafe.java" target="_blank" rel="external">Unsafe</a></p>
<p><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></p>
</div></article><div class="tags"><a href="/tags/JUC/">JUC</a><a href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a></div><div class="paginator"><a href="/2017/07/23/Comprehend-volatile/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div id="disqus_thread"></div></section><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://lukaicheng.github.io/2017/07/27/ConcurrentHashMap-JDK7-comprehension/';
    this.page.identifier = '2017/07/27/ConcurrentHashMap-JDK7-comprehension/';
    this.page.title = '并发容器－理解ConcurrentHashMap(JDK7版本)';
};
(function() {
var d = document, s = d.createElement('script');

s.src = '//Your disqus ID.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();</script></section><footer><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2017<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Lucifer</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>