<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Lucifer"><meta name="description" content="发布于并发编程网，文章链接5.1介绍JSR-303/JSR-349BeanValidation在设置支持方面，SpringFramework4.0支持BeanValidation1.0(JSR-303)和BeanValidation1.1(JSR-349)"><meta name="keywords" content="Spring"><title>Spring 5 验证、数据绑定和类型转换[译] · 羽逝神伤</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="https://lukaicheng.github.io/2017/05/13/Spring5-validation-translate/"><link rel="alternate" href="/atom.xml" title="羽逝神伤"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">羽逝神伤</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">Spring 5 验证、数据绑定和类型转换[译]</h1><span class="post-time">May 13, 2017</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Contents</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-介绍"><span class="toc-text">5.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-使用Spring的验证器接口进行验证"><span class="toc-text">5.2 使用Spring的验证器接口进行验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-将代码解析成错误消息"><span class="toc-text">5.3 将代码解析成错误消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Bean操作和BeanWrapper"><span class="toc-text">5.4 Bean操作和BeanWrapper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-设置并获取基本和嵌套属性"><span class="toc-text">5.4.1 设置并获取基本和嵌套属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-内置PropertyEditor实现"><span class="toc-text">5.4.2 内置PropertyEditor实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#注册额外的自定义PropertyEditor"><span class="toc-text">注册额外的自定义PropertyEditor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用PropertyEditorRegistrar"><span class="toc-text">使用PropertyEditorRegistrar</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-Spring类型转换"><span class="toc-text">5.5 Spring类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-Converter-SPI"><span class="toc-text">5.5.1 Converter SPI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2-ConverterFactory"><span class="toc-text">5.5.2 ConverterFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-3-GenericConverter"><span class="toc-text">5.5.3 GenericConverter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConditionalGenericConverter"><span class="toc-text">ConditionalGenericConverter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-4-ConversionService-API"><span class="toc-text">5.5.4 ConversionService API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-5-配置ConversionService"><span class="toc-text">5.5.5 配置ConversionService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-6-编程方式使用ConversionService"><span class="toc-text">5.5.6 编程方式使用ConversionService</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-Spring字段格式化"><span class="toc-text">5.6 Spring字段格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-1-Formatter-SPI"><span class="toc-text">5.6.1 Formatter SPI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-2-注解驱动的格式化"><span class="toc-text">5.6.2 注解驱动的格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Format-Annotation-API"><span class="toc-text">Format Annotation API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-3-FormatterRegistry-SPI"><span class="toc-text">5.6.3 FormatterRegistry SPI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-4-FormatterRegistrar-SPI"><span class="toc-text">5.6.4 FormatterRegistrar SPI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-5-在Spring-MVC中配置格式化"><span class="toc-text">5.6.5 在Spring MVC中配置格式化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-配置一个全局的日期-amp-时间格式"><span class="toc-text">5.7 配置一个全局的日期&时间格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-Spring验证"><span class="toc-text">5.8 Spring验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-1-JSR-303-Bean-Validation-API概述"><span class="toc-text">5.8.1 JSR-303 Bean Validation API概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-2-配置Bean验证器提供程序"><span class="toc-text">5.8.2 配置Bean验证器提供程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#注入验证器"><span class="toc-text">注入验证器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置自定义约束"><span class="toc-text">配置自定义约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring驱动的方法验证"><span class="toc-text">Spring驱动的方法验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#附加配置选项"><span class="toc-text">附加配置选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-3-配置DataBinder"><span class="toc-text">5.8.3 配置DataBinder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-4-Spring-MVC-3-验证"><span class="toc-text">5.8.4 Spring MVC 3 验证</span></a></li></ol></li></ol></div><div class="post-content"><p>发布于并发编程网，文章<a href="http://ifeve.com/spring-5-validation/" target="_blank" rel="external">链接</a></p>
<h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><blockquote>
<p>JSR-303/JSR-349 Bean Validation</p>
<p>在设置支持方面，Spring Framework 4.0支持Bean Validation 1.0(JSR-303)和Bean Validation 1.1(JSR-349)，也将其改写成了Spring的<code>Validator</code>接口。</p>
<p>正如<a href="#5.8 Spring Validation">5.8 Spring验证</a>所述，应用程序可以选择一次性全局启用Bean验证，并使其专门用于所有的验证需求。</p>
<p>正如<a href="#5.8.3 Configuring a DataBinder">5.8.3 配置DataBinder</a>所述，应用程序也可以为每个<code>DataBinder</code>实例注册额外的Spring <code>Validator</code>实例，这可能有助于不通过使用注解而插入验证逻辑。</p>
</blockquote>
<a id="more"></a>
<p>考虑将验证作为业务逻辑是有利有弊的，Spring提供了一种不排除利弊的用于验证(和数据绑定)的设计。具体的验证不应该捆绑在web层，应该容易本地化并且它应该能够插入任何可用的验证器。考虑到以上这些，Spring想出了一个<code>Validator</code>接口，它在应用程序的每一层基本都是可用的。数据绑定对于将用户输入动态绑定到应用程序的领域模型上(或者任何你用于处理用户输入的对象)是非常有用的。Spring提供了所谓的<code>DataBinder</code>来处理这个。<code>Validator</code>和<code>DataBinder</code>组成了<code>validation</code>包，其主要用于但并不局限于MVC框架。</p>
<p><code>BeanWrapper</code>是Spring框架中的一个基本概念且在很多地方使用。然而，你可能并不需要直接使用<code>BeanWrapper</code>。尽管这是参考文档，我们仍然觉得有一些说明需要一步步来。我们将会在本章中解释<code>BeanWrapper</code>，因为你极有可能会在尝试将数据绑定到对象的时候使用它。</p>
<p>Spring的DataBinder和底层的BeanWrapper都使用PropertyEditor来解析和格式化属性值。<code>PropertyEditor</code>概念是JavaBeans规范的一部分，并会在本章进行说明。Spring 3不仅引入了”core.convert”包来提供一套通用类型转换工具，还有一个高层次的”format”包用于格式化UI字段值。可以将这些新包视作更简单的PropertyEditor替代方式来使用，本章还会对此进行讨论。</p>
<h2 id="5-2-使用Spring的验证器接口进行验证"><a href="#5-2-使用Spring的验证器接口进行验证" class="headerlink" title="5.2 使用Spring的验证器接口进行验证"></a>5.2 使用Spring的验证器接口进行验证</h2><p>Spring具有一个<code>Validator</code>接口可以让你用于验证对象。<code>Validator</code>接口在工作时需要使用一个<code>Errors</code>对象，以便于在验证过程中，验证器可以将验证失败的信息报告给这个<code>Errors</code>对象。</p>
<p>让我们考虑一个小的数据对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    </div><div class="line">    <span class="comment">// the usual getters and setters...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过实现<code>org.springframework.validation.Validator</code>的下列两个接口，我们打算为<code>Person</code>类提供验证行为：</p>
<ul>
<li><code>support(Class)</code> - 这个<code>Validator</code>是否可以验证给定<code>Class</code>的实例</li>
<li><code>validate(Object,org.springframework.validation.Errors)</code> - 验证给定的对象并且万一验证错误，可以将这些错误注册到给定的<code>Errors</code>对象</li>
</ul>
<p>实现一个<code>Validator</code>是相当简单的，特别是当你知道Spring框架还提供了<code>ValidationUtils</code>辅助类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * This Validator validates *just* Person instances</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class clazz)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> Person.class.equals(clazz);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object obj, Errors e)</span> </span>&#123;</div><div class="line">		ValidationUtils.rejectIfEmpty(e, <span class="string">"name"</span>, <span class="string">"name.empty"</span>);</div><div class="line">		Person p = (Person) obj;</div><div class="line">		<span class="keyword">if</span> (p.getAge() &lt; <span class="number">0</span>) &#123;</div><div class="line">			e.rejectValue(<span class="string">"age"</span>, <span class="string">"negativevalue"</span>);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.getAge() &gt; <span class="number">110</span>) &#123;</div><div class="line">			e.rejectValue(<span class="string">"age"</span>, <span class="string">"too.darn.old"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如你看到的，<code>ValidationUtils</code>类的<code>static</code>  <code>rejectIfEmpty(..)</code>方法被用于拒绝那些值为<code>null</code>或者空字符串的<code>&#39;name&#39;</code>属性。除了上面展示的例子之外，去看一看<code>ValidationUtils</code>的java文档有助于了解它提供的功能。</p>
<p>通过实现单个的<code>Validator</code>类来逐个验证富对象中的嵌套对象当然是有可能的，然而将验证逻辑封装在每个嵌套类对象自身的<code>Validator</code>实现中可能是一种更好的选择。<code>Customer</code>就是一个<em>‘富’</em>对象的简单示例，它由两个字符串属性(姓和名)以及一个复杂对象<code>Address</code>组成。<code>Address</code>对象可能独立于<code>Customer</code>对象使用，因此已经实现了一个独特的<code>AddressValidator</code>。如果你想要你的<code>CustomerValidator</code>不借助于复制粘贴而重用包含在<code>AddressValidator</code>中的逻辑，那么你可以通过依赖注入或者实例化你的<code>CustomerValidator</code>中的<code>AddressValidator</code>，然后像这样使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Validator addressValidator;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomerValidator</span><span class="params">(Validator addressValidator)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (addressValidator == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The supplied [Validator] is "</span> +</div><div class="line">				<span class="string">"required and must not be null."</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (!addressValidator.supports(Address.class)) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The supplied [Validator] must "</span> +</div><div class="line">				<span class="string">"support the validation of [Address] instances."</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.addressValidator = addressValidator;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * This Validator validates Customer instances, and any subclasses of Customer too</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class clazz)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> Customer.class.isAssignableFrom(clazz);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</div><div class="line">		ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">"firstName"</span>, <span class="string">"field.required"</span>);</div><div class="line">		ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">"surname"</span>, <span class="string">"field.required"</span>);</div><div class="line">		Customer customer = (Customer) target;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			errors.pushNestedPath(<span class="string">"address"</span>);</div><div class="line">			ValidationUtils.invokeValidator(<span class="keyword">this</span>.addressValidator, customer.getAddress(), errors);</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			errors.popNestedPath();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>验证错误被报告给传递到验证器的<code>Errors</code>对象。在使用Spring Web MVC的情况下，你可以使用<code>&lt;spring:bind/&gt;</code>标签来检查错误信息，不过当然你也可以自己检查错误对象。有关它提供的方法的更多信息可以在java文档中找到。</p>
<h2 id="5-3-将代码解析成错误消息"><a href="#5-3-将代码解析成错误消息" class="headerlink" title="5.3 将代码解析成错误消息"></a>5.3 将代码解析成错误消息</h2><p>在之前我们已经谈论了数据绑定和验证，最后一件值得讨论的事情是输出对应于验证错误的消息。在我们上面展示的例子里，我们拒绝了<code>name</code>和<code>age</code>字段。如果我们要使用<code>MessageSource</code>来输出错误消息，我们将会使用我们在拒绝该字段(这个情况下是’姓名’和’年龄’)时给出的错误代码。当你调用(不管是直接调用还是间接通过使用<code>ValidationUtils</code>类调用)来自<code>Errors</code>接口的<code>rejectValue</code>或者其他<code>reject</code>方法时，其底层实现不仅会注册你传入的代码，还会注册一些额外的错误代码。注册怎样的错误代码取决于它所使用的<code>MessageCodesResolver</code>，默认情况下，会使用<code>DefaultMessageCodesResolver</code>，其不仅会使用你提供的代码注册消息，还会注册包含你传递给拒绝方法的字段名称的消息。所以如果你使用<code>rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;)</code>来拒绝一个字段，除了<code>too.darn.old</code>代码，Spring还会注册<code>too.darn.old.age</code>和<code>too.darn.old.age.int</code>(第一个会包含字段名称且第二个会包含字段类型)。这样做是为了方便开发人员来定位错误消息等。</p>
<p>有关<code>MessageCodesResolver</code>和其默认策略的更多信息可以分别在<code>MessageCodesResolver</code>以及<code>DefaultMessageCodesResolver</code>的在线java文档中找到。</p>
<h2 id="5-4-Bean操作和BeanWrapper"><a href="#5-4-Bean操作和BeanWrapper" class="headerlink" title="5.4 Bean操作和BeanWrapper"></a>5.4 Bean操作和BeanWrapper</h2><p><code>org.springframework.beans</code>包遵循Oracle提供的JavaBeans标准。一个JavaBean只是一个包含默认无参构造器的类，它遵循一个命名约定(通过一个例子)：一个名为<code>bingoMadness</code>属性将有一个设置方法<code>setBingoMadness(..)</code>和一个获取方法<code>getBingoMadness(..)</code>。有关JavaBeans和其规范的更多信息，请参考Oracle的网站(<a href="https://docs.oracle.com/javase/6/docs/api/java/beans/package-summary.html" target="_blank" rel="external">javabeans</a>)。</p>
<p>beans包里一个非常重要的类是<code>BeanWrapper</code>接口和它的相应实现(<code>BeanWrapperImpl</code>)。引用自java文档，<code>BeanWrapper</code>提供了设置和获取属性值(单独或批量)、获取属性描述符以及查询属性以确定它们是可读还是可写的功能。<code>BeanWrapper</code>还提供对嵌套属性的支持，能够不受嵌套深度的限制启用子属性的属性设置。然后，<code>BeanWrapper</code>提供了无需目标类代码的支持就能够添加标准JavaBeans的<code>PropertyChangeListeners</code>和<code>VetoableChangeListeners</code>的能力。最后然而并非最不重要的是，<code>BeanWrapper</code>提供了对索引属性设置的支持。<code>BeanWrapper</code>通常不会被应用程序的代码直接使用，而是由<code>DataBinder</code>和<code>BeanFactory</code>使用。</p>
<p><code>BeanWrapper</code>的名字已经部分暗示了它的工作方式：它包装一个bean以对其执行操作，比如设置和获取属性。</p>
<h3 id="5-4-1-设置并获取基本和嵌套属性"><a href="#5-4-1-设置并获取基本和嵌套属性" class="headerlink" title="5.4.1 设置并获取基本和嵌套属性"></a>5.4.1 设置并获取基本和嵌套属性</h3><p>使用<code>setPropertyValue(s)</code>和<code>getPropertyValue(s)</code>可以设置并获取属性，两者都带有几个重载方法。在Spring自带的java文档中对它们有更详细的描述。重要的是要知道对象属性指示的几个约定。几个例子：</p>
<p><strong>表 5.1. 属性示例</strong></p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>表示属性<code>name</code>与方法<code>getName()</code>或<code>isName()</code>和<code>setName()</code>相对应</td>
</tr>
<tr>
<td><code>account.name</code></td>
<td>表示属性<code>account</code>的嵌套属性<code>name</code>与方法<code>getAccount().setName()</code>或<code>getAccount().getName()</code>相对应</td>
</tr>
<tr>
<td><code>account[2]</code></td>
<td>表示索引属性<code>account</code>的第三个元素。索引属性可以是<code>array</code>、<code>list</code>或其他自然排序的集合</td>
</tr>
<tr>
<td><code>account[COMPANYNAME]</code></td>
<td>表示映射属性<code>account</code>被键<em>COMPANYNAME</em>索引到的映射项的值</td>
</tr>
</tbody>
</table>
<p>下面你会发现一些使用<code>BeanWrapper</code>来获取和设置属性的例子。</p>
<p><em>(如果你不打算直接使用<code>BeanWrapper</code>，那么下一部分对你来说并不重要。如果你仅使用<code>DataBinder</code>和<code>BeanFactory</code>以及它们开箱即用的实现，你应该跳到关于<code>PropertyEditor</code>部分的开头)。</em></p>
<p>考虑下面两个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> Employee managingDirector;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Employee <span class="title">getManagingDirector</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.managingDirector;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setManagingDirector</span><span class="params">(Employee managingDirector)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.managingDirector = managingDirector;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">float</span> salary;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> salary;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">float</span> salary)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.salary = salary;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下的代码片段展示了如何检索和操纵实例化的<code>Companies</code>和<code>Employees</code>的某些属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">BeanWrapper company = <span class="keyword">new</span> BeanWrapperImpl(<span class="keyword">new</span> Company());</div><div class="line"><span class="comment">// setting the company name..</span></div><div class="line">company.setPropertyValue(<span class="string">"name"</span>, <span class="string">"Some Company Inc."</span>);</div><div class="line"><span class="comment">// ... can also be done like this:</span></div><div class="line">PropertyValue value = <span class="keyword">new</span> PropertyValue(<span class="string">"name"</span>, <span class="string">"Some Company Inc."</span>);</div><div class="line">company.setPropertyValue(value);</div><div class="line"></div><div class="line"><span class="comment">// ok, let's create the director and tie it to the company:</span></div><div class="line">BeanWrapper jim = <span class="keyword">new</span> BeanWrapperImpl(<span class="keyword">new</span> Employee());</div><div class="line">jim.setPropertyValue(<span class="string">"name"</span>, <span class="string">"Jim Stravinsky"</span>);</div><div class="line">company.setPropertyValue(<span class="string">"managingDirector"</span>, jim.getWrappedInstance());</div><div class="line"></div><div class="line"><span class="comment">// retrieving the salary of the managingDirector through the company</span></div><div class="line">Float salary = (Float) company.getPropertyValue(<span class="string">"managingDirector.salary"</span>);</div></pre></td></tr></table></figure>
<h3 id="5-4-2-内置PropertyEditor实现"><a href="#5-4-2-内置PropertyEditor实现" class="headerlink" title="5.4.2 内置PropertyEditor实现"></a>5.4.2 内置PropertyEditor实现</h3><p>Spring使用<code>PropertyEditor</code>的概念来实现<code>Object</code>和<code>String</code>之间的转换。如果你考虑到它，有时候换另一种方式表示属性可能比对象本身更方便。举个例子，一个<code>Date</code>可以以人类可读的方式表示(如<code>String</code> <code>&#39;2007-14-09&#39;</code>)，同时我们依然能把人类可读的形式转换回原始的时间(甚至可能更好：将任何以人类可读形式输入的时间转换回<code>Date</code>对象)。这种行为可以通过注册类型为<code>PropertyEditor</code>的自定义编辑器来实现。在<code>BeanWrapper</code>或上一章提到的特定IoC容器中注册自定义编辑器，可以使其了解如何将属性转换为期望的类型。请阅读Oracle为<code>java.beans</code>包提供的java文档来获取更多关于<code>PropertyEditor</code>的信息。</p>
<p>这是Spring使用属性编辑的两个例子：</p>
<ul>
<li>使用<code>PropertyEditor</code>来完成<em>bean的属性设置</em>。当提到将<code>java.lang.String</code>作为你在XML文件中声明的某些bean的属性值时，Spring将会(如果相应的属性的设置方法具有一个<code>Class</code>参数)使用<code>ClassEditor</code>尝试将参数解析成<code>Class</code>对象。</li>
<li>在Spring的MVC框架中<em>解析HTTP请求的参数</em>是由各种<code>PropertyEditor</code>完成的，你可以把它们手动绑定到<code>CommandController</code>的所有子类。</li>
</ul>
<p>Spring有一些内置的<code>PropertyEditor</code>使生活变得轻松。它们中的每一个都已列在下面，并且它们都被放在<code>org.springframework.beans.propertyeditors</code>包中。大部分但并不是全部(如下所示)，默认情况下会由<code>BeanWrapperImpl</code>注册。在某种方式下属性编辑器是可配置的，那么理所当然，你可以注册你自己的变种来覆盖默认编辑器：</p>
<p><span id="5.4.2-Built-in PropertyEditor implementations"><strong>Table 5.2. 内置PropertyEditor</strong></span></p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ByteArrayPropertyEditor</code></td>
<td>针对字节数组的编辑器。字符串会简单地转换成相应的字节表示。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>ClassEditor</code></td>
<td>将类的字符串表示形式解析成实际的类形式并且也能返回实际类的字符串表示形式。如果找不到类，会抛出一个<code>IllegalArgumentException</code>。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>CustomBooleanEditor</code></td>
<td>针对<code>Boolean</code>属性的可定制的属性编辑器。默认情况下由<code>BeanWrapperImpl</code>注册，但是可以作为一种自定义编辑器通过注册其自定义实例来进行覆盖。</td>
</tr>
<tr>
<td><code>CustomCollectionEditor</code></td>
<td>针对集合的属性编辑器，可以将原始的<code>Collection</code>转换成给定的目标<code>Collection</code>类型。</td>
</tr>
<tr>
<td><code>CustomDateEditor</code></td>
<td>针对java.util.Date的可定制的属性编辑器，支持自定义的时间格式。不会被默认注册，用户必须使用适当格式进行注册。</td>
</tr>
<tr>
<td><code>CustomNumberEditor</code></td>
<td>针对任何Number子类(比如<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>)的可定制的属性编辑器。默认情况下由<code>BeanWrapperImpl</code>注册，但是可以作为一种自定义编辑器通过注册其自定义实例来进行覆盖。</td>
</tr>
<tr>
<td><code>FileEditor</code></td>
<td>能够将字符串解析成<code>java.io.File</code>对象。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>InputStreamEditor</code></td>
<td>一次性的属性编辑器，能够读取文本字符串并生成(通过中间的<code>ResourceEditor</code>以及<code>Resource</code>)一个<code>InputStream</code>对象，因此*<code>InputStream</code>类型的属性可以直接以字符串设置。请注意默认的使用方式不会为你关闭<code>InputStream</code>！默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>LocaleEditor</code></td>
<td>能够将字符串解析成<code>Locale</code>对象，反之亦然(字符串格式是<em>[country]</em>[variant]，这与Locale提供的toString()方法是一样的)。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>PatternEditor</code></td>
<td>能够将字符串解析成<code>java.util.regex.Pattern</code>对象，反之亦然。</td>
</tr>
<tr>
<td><code>PropertiesEditor</code></td>
<td>能够将字符串(按照<code>java.util.Properties</code>类的java文档定义的格式进行格式化)解析成<code>Properties</code>对象。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>StringTrimmerEditor</code></td>
<td>用于缩减字符串的属性编辑器。有选择性允许将一个空字符串转变成<code>null</code>值。不会进行默认注册，需要在用户有需要的时候注册。</td>
</tr>
<tr>
<td><code>URLEditor</code></td>
<td>能够将一个URL的字符串表示解析成实际的<code>URL</code>对象。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
</tbody>
</table>
<p>Spring使用<code>java.beans.PropertyEditorManager</code>来设置可能需要的属性编辑器的搜索路径。搜索路径中还包括了<code>sun.bean.editors</code>，这个包里面包含如<code>Font</code>、<code>Color</code>类型以及其他大部分基本类型的<code>PropertyEditor</code>实现。还要注意的是，如果<code>PropertyEditor</code>类与它们所处理的类位于同一个包并且除了’Editor’后缀之外拥有相同的名字，那么标准的JavaBeans基础设施会自动发现这些它们(不需要你显式的注册它们)。例如，有人可能会有以下的类和包结构，这已经足够识别出<code>FooEditor</code>类并将其作为<strong><code>Foo</code></strong>类型属性的<code>PropertyEditor</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">com</div><div class="line">  chank</div><div class="line">    pop</div><div class="line">      Foo</div><div class="line">      FooEditor // the PropertyEditor for the Foo class</div></pre></td></tr></table></figure>
<p>要注意的是在这里你也可以使用标准JavaBeans机制的<code>BeanInfo</code>(在<a href="https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html" target="_blank" rel="external">in not-amazing-detail here</a>有描述)。在下面的示例中，你可以看到使用<code>BeanInfo</code>机制为一个关联类的属性显式注册一个或多个<code>PropertyEditor</code>实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">com</div><div class="line">  chank</div><div class="line">    pop</div><div class="line">      Foo</div><div class="line">      FooBeanInfo // the BeanInfo for the Foo class</div></pre></td></tr></table></figure>
<p>这是被引用到的<code>FooBeanInfo</code>类的Java源代码。它会将一个<code>CustomNumberEditor</code>同<code>Foo</code>类的<code>age</code>属性关联。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBeanInfo</span> <span class="keyword">extends</span> <span class="title">SimpleBeanInfo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">final</span> PropertyEditor numberPE = <span class="keyword">new</span> CustomNumberEditor(Integer.class, <span class="keyword">true</span>);</div><div class="line">			PropertyDescriptor ageDescriptor = <span class="keyword">new</span> PropertyDescriptor(<span class="string">"age"</span>, Foo.class) &#123;</div><div class="line">				<span class="function"><span class="keyword">public</span> PropertyEditor <span class="title">createPropertyEditor</span><span class="params">(Object bean)</span> </span>&#123;</div><div class="line">					<span class="keyword">return</span> numberPE;</div><div class="line">				&#125;;</div><div class="line">			&#125;;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> PropertyDescriptor[] &#123; ageDescriptor &#125;;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (IntrospectionException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Error(ex.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><span id="Registering additional custom PropertyEditors"></span></p>
<h4 id="注册额外的自定义PropertyEditor"><a href="#注册额外的自定义PropertyEditor" class="headerlink" title="注册额外的自定义PropertyEditor"></a>注册额外的自定义PropertyEditor</h4><p>当bean属性设置成一个字符串值时，Spring IoC容器最终会使用标准JavaBeans的<code>PropertyEditor</code>将这些字符串转换成复杂类型的属性。Spring预先注册了一些自定义<code>PropertyEditor</code>(例如将一个以字符串表示的类名转换成真正的<code>Class</code>对象)。此外，Java的标准JavaBeans <code>PropertyEditor</code>查找机制允许一个<code>PropertyEditor</code>只需要恰当的命名并同它支持的类位于相同的包，就能够自动发现它。</p>
<p>如果需要注册其他自定义的<code>PropertyEditor</code>，还有几种可用机制。假设你有一个<code>BeanFactory</code>引用，最人工化的方式(但通常并不方便或者推荐)是直接使用<code>ConfigurableBeanFactory</code>接口的<code>registerCustomEditor()</code>方法。另一种略为方便的机制是使用一个被称为<code>CustomEditorConfigurer</code>的特殊的bean factory后置处理器(<em>post-processor</em>)。虽然bean factory后置处理器可以与<code>BeanFactory</code>实现一起使用，但是因为<code>CustomEditorConfigurer</code>有一个嵌套属性设置过程，所以强烈推荐它与<code>ApplicationContext</code>一起使用，这样就可以采用与其他bean类似的方式来部署它，并自动检测和应用。</p>
<p>请注意所有的bean工厂和应用上下文都会自动地使用一些内置属性编辑器，这些编辑器通过一个被称为<code>BeanWrapper</code>的接口来处理属性转换。<code>BeanWrapper</code>注册的那些标准属性编辑器已经列在<a href="#5.4.2-Built-in PropertyEditor implementations">上一部分</a>。 此外，针对特定的应用程序上下文类型，<code>ApplicationContext</code>会用适当的方法覆盖或添加一些额外的编辑器来处理资源查找。</p>
<p>标准的JavaBeans <code>PropertyEditor</code>实例用于将字符串表示的属性值转换成实际的复杂类型属性。<code>CustomEditorConfigurer</code>，一个bean factory后处理器，可以为添加额外的<code>PropertyEditor</code>到<code>ApplicationContext</code>提供便利支持。</p>
<p>考虑一个用户类<code>ExoticType</code>和另外一个需要将<code>ExoticType</code>设为属性的类<code>DependsOnExoticType</code>： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> example;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExoticType</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ExoticType</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependsOnExoticType</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ExoticType type;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(ExoticType type)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.type = type;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当东西都被正确设置时，我们希望能够分配字符串给type属性，而<code>PropertyEditor</code>会在背后将其转换成实际的<code>ExoticType</code>实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sample"</span> <span class="attr">class</span>=<span class="string">"example.DependsOnExoticType"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"type"</span> <span class="attr">value</span>=<span class="string">"aNameForExoticType"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>PropertyEditor</code>实现可能与此类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// converts string representation to ExoticType object</span></div><div class="line"><span class="keyword">package</span> example;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExoticTypeEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> </span>&#123;</div><div class="line">		setValue(<span class="keyword">new</span> ExoticType(text.toUpperCase()));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我们使用<code>CustomEditorConfigurer</code>将一个新的<code>PropertyEditor</code>注册到<code>ApplicationContext</code>，那么在需要的时候就能够使用它：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomEditorConfigurer"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"customEditors"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"example.ExoticType"</span> <span class="attr">value</span>=<span class="string">"example.ExoticTypeEditor"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="使用PropertyEditorRegistrar"><a href="#使用PropertyEditorRegistrar" class="headerlink" title="使用PropertyEditorRegistrar"></a>使用PropertyEditorRegistrar</h4><p>另一种将属性编辑器注册到Spring容器的机制是创建和使用一个<code>PropertyEditorRegistrar</code>。当你需要在几个不同场景里使用同一组属性编辑器，这个接口会特别有用：编写一个相应的registrar并在每个用例里重用。<code>PropertyEditorRegistrar</code>与一个被称为<code>PropertyEditorRegistry</code>的接口配合工作，后者被Spring的<code>BeanWrapper</code>(以及<code>DataBinder</code>)实现。当与<code>CustomEditorConfigurer</code>配合使用的时候，<code>PropertyEditorRegistrar</code>特别方便(<a href="#Registering additional custom PropertyEditors">这里</a>有介绍)，因为前者暴露了一个方法<code>setPropertyEditorRegistrars(..)</code>：以这种方式添加到<code>CustomEditorConfigurerd</code>的<code>PropertyEditorRegistrar</code>可以很容易地在<code>DataBinder</code>和Spring MVC <code>Controllers</code>之间共享。另外，它避免了在自定义编辑器上的同步需求：一个<code>PropertyEditorRegistrar</code>可以为每一次bean创建尝试创建新的<code>PropertyEditor</code>实例。</p>
<p>使用<code>PropertyEditorRegistrar</code>可能最好还是以一个例子来说明。首先，你需要创建你自己的<code>PropertyEditorRegistrar</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.foo.editors.spring;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPropertyEditorRegistrar</span> <span class="keyword">implements</span> <span class="title">PropertyEditorRegistrar</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCustomEditors</span><span class="params">(PropertyEditorRegistry registry)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">// it is expected that new PropertyEditor instances are created</span></div><div class="line">		registry.registerCustomEditor(ExoticType.class, <span class="keyword">new</span> ExoticTypeEditor());</div><div class="line"></div><div class="line">		<span class="comment">// you could register as many custom property editors as are required here...</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以查看<code>org.springframework.beans.support.ResourceEditorRegistrar</code>当作一个<code>PropertyEditorRegistrar</code>实现的示例。注意在它的<code>registerCustomEditors(..)</code>方法实现里是如何为每个属性编辑器创建新的实例的。</p>
<p>接着我们配置了一个<code>CustomEditorConfigurerd</code>并将我们的<code>CustomPropertyEditorRegistrar</code>注入其中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomEditorConfigurer"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"propertyEditorRegistrars"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"customPropertyEditorRegistrar"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customPropertyEditorRegistrar"</span></span></div><div class="line">	<span class="attr">class</span>=<span class="string">"com.foo.editors.spring.CustomPropertyEditorRegistrar"</span>/&gt;</div></pre></td></tr></table></figure>
<p>最后，有点偏离本章的重点，针对你们之中使用<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html" target="_blank" rel="external">Spring’s MVC web framework</a>的那些人，使用<code>PropertyEditorRegistrar</code>与数据绑定的<code>Controller</code>(比如<code>SimpleFormController</code>)配合使用会非常方便。下面是一个在<code>initBinder(..)</code>方法的实现里使用<code>PropertyEditorRegistrar</code>的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterUserController</span> <span class="keyword">extends</span> <span class="title">SimpleFormController</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> PropertyEditorRegistrar customPropertyEditorRegistrar;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RegisterUserController</span><span class="params">(PropertyEditorRegistrar propertyEditorRegistrar)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.customPropertyEditorRegistrar = propertyEditorRegistrar;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(HttpServletRequest request,</span></span></div><div class="line">			ServletRequestDataBinder binder) <span class="keyword">throws</span> Exception &#123;</div><div class="line">		<span class="keyword">this</span>.customPropertyEditorRegistrar.registerCustomEditors(binder);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// other methods to do with registering a User</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种<code>PropertyEditor</code>注册的风格可以导致简洁的代码(<code>initBinder(..)</code>的实现仅仅只有一行！)，同时也允许将通用的<code>PropertyEditor</code>注册代码封装到一个类里然后根据需要在尽可能多的<code>Controller</code>之间共享。</p>
<h2 id="5-5-Spring类型转换"><a href="#5-5-Spring类型转换" class="headerlink" title="5.5 Spring类型转换"></a>5.5 Spring类型转换</h2><p>Spring 3引入了<code>core.convert</code>包来提供一个一般类型的转换系统。这个系统定义了实现类型转换逻辑的服务提供接口(SPI)以及在运行时执行类型转换的API。在Spring容器内，这个系统可以当作是PropertyEditor的替代选择，用于将外部bean的属性值字符串转换成所需的属性类型。这个公共的API也可以在你的应用程序中任何需要类型转换的地方使用。</p>
<h3 id="5-5-1-Converter-SPI"><a href="#5-5-1-Converter-SPI" class="headerlink" title="5.5.1 Converter SPI"></a>5.5.1 Converter SPI</h3><p>实现类型转换逻辑的SPI是简单并且强类型的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要创建属于你自己的转换器，只需要简单的实现以上接口即可。泛型参数S表示你想要进行转换的源类型，而泛型参数T表示你想要转换的目标类型。如果一个包含S类型元素的集合或数组需要转换为一个包含T类型的数组或集合，那么这个转换器也可以被透明地应用，前提是已经注册了一个委托数组或集合的转换器(默认情况下会是<code>DefaultConversionService</code>处理)。</p>
<p>对每次方法<code>convert(S)</code>的调用，source参数值必须确保不为空。如果转换失败，你的转换器可以抛出任何非受检异常(<em>unchecked exception</em>)；具体来说，为了报告一个非法的source参数值，应该抛出一个<code>IllegalArgumentException</code>。还有要注意确保你的<code>Converter</code>实现必须是线程安全的。</p>
<p>为方便起见，<code>core.convert.support</code>包已经提供了一些转换器实现，这些实现包括了从字符串到数字以及其他常见类型的转换。考虑将<code>StringToInteger</code>作为一个典型的<code>Converter</code>实现示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.support;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToInteger</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> Integer.valueOf(source);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-5-2-ConverterFactory"><a href="#5-5-2-ConverterFactory" class="headerlink" title="5.5.2 ConverterFactory"></a>5.5.2 ConverterFactory</h3><p>当你需要集中整个类层次结构的转换逻辑时，例如，碰到将String转换到java.lang.Enum对象的时候，请实现<code>ConverterFactory</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	&lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>泛型参数S表示你想要转换的源类型，泛型参数R表示你可以转换的那些范围内的类型的基类。然后实现getConverter(Class<t>)，其中T就是R的一个子类。</t></p>
<p>考虑将<code>StringToEnum</code>作为ConverterFactory的一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.support;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToEnumConverterFactory</span> <span class="keyword">implements</span> <span class="title">ConverterFactory</span>&lt;<span class="title">String</span>, <span class="title">Enum</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> &lt;T extends Enum&gt; <span class="function">Converter&lt;String, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StringToEnumConverter(targetType);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToEnumConverter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Enum</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">		<span class="keyword">private</span> Class&lt;T&gt; enumType;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">StringToEnumConverter</span><span class="params">(Class&lt;T&gt; enumType)</span> </span>&#123;</div><div class="line">			<span class="keyword">this</span>.enumType = enumType;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> (T) Enum.valueOf(<span class="keyword">this</span>.enumType, source.trim());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-5-3-GenericConverter"><a href="#5-5-3-GenericConverter" class="headerlink" title="5.5.3 GenericConverter"></a>5.5.3 GenericConverter</h3><p>当你需要一个复杂的转换器实现时，请考虑GenericConverter接口。GenericConverter具备更加灵活但是不太强的类型签名，以支持在多种源类型和目标类型之间的转换。此外，当实现你的转换逻辑时，GenericConverter还可以使源字段和目标字段的上下文对你可用，这样的上下文允许类型转换由字段上的注解或者字段声明中的泛型信息来驱动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要实现一个GenericConverter，getConvertibleTypes()方法要返回支持的源-目标类型对，然后实现convert(Object,TypeDescriptor,TypeDescriptor)方法来实现你的转换逻辑。源TypeDescriptor提供了对持有被转换值的源字段的访问，目标TypeDescriptor提供了对设置转换值的目标字段的访问。</p>
<p>一个很好的GenericConverter的示例是一个在Java数组和集合之间进行转换的转换器。这样一个ArrayToCollectionConverter可以通过内省声明了目标集合类型的字段以解析集合元素的类型，这将允许原数组中每个元素可以在集合被设置到目标字段之前转换成集合元素的类型。</p>
<blockquote>
<p>由于GenericConverter是一个更复杂的SPI接口，所以对基本类型的转换需求优先使用Converter或者ConverterFactory。 </p>
</blockquote>
<h4 id="ConditionalGenericConverter"><a href="#ConditionalGenericConverter" class="headerlink" title="ConditionalGenericConverter"></a>ConditionalGenericConverter</h4><p>有时候你只想要在特定条件成立的情况下<code>Converter</code>才执行，例如，你可能只想要在目标字段存在特定注解的情况下才执行<code>Converter</code>，或者你可能只想要在目标类中定义了特定方法，比如<code>static</code> <code>valueOf</code>方法，才执行<code>Converter</code>。<code>ConditionalGenericConverter</code>是<code>GenericConverter</code>和<code>ConditionalConveter</code>接口的联合，允许你定义这样的自定义匹配条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionalGenericConverter</span></span></div><div class="line">        <span class="keyword">extends</span> <span class="title">GenericConverter</span>, <span class="title">ConditionalConverter</span> &#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ConditionalGenericConverter</code>的一个很好的例子是一个在持久化实体标识和实体引用之间进行转换的实体转换器。这个实体转换器可能只匹配这样的条件–目标实体类声明了一个静态的查找方法，例如<code>findAccount(Long)</code>，你将在<code>matches(TypeDescriptor,TypeDescriptor)</code>方法实现里执行这样的查找方法的检测。</p>
<h3 id="5-5-4-ConversionService-API"><a href="#5-5-4-ConversionService-API" class="headerlink" title="5.5.4 ConversionService API"></a>5.5.4 ConversionService API</h3><p>ConversionService接口定义了运行时执行类型转换的统一API，转换器往往是在这个门面(<em>facade</em>)接口背后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.convert;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConversionService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</div><div class="line"></div><div class="line">	&lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(Object source, Class&lt;T&gt; targetType)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">	<span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大多数ConversionService实现也会实现<code>ConverterRegistry</code>接口，这个接口提供一个用于注册转换器的服务提供接口(SPI)。在内部，一个ConversionService实现会以委托给注册其中的转换器的方式来执行类型转换逻辑。</p>
<p><code>core.convert.support</code>包已经提供了一个强大的ConversionService实现，<code>GenericConversionService</code>是适用于大多数环境的通用实现，<code>ConversionServiceFactory</code>以工厂的方式为创建常见的ConversionService配置提供了便利。</p>
<h3 id="5-5-5-配置ConversionService"><a href="#5-5-5-配置ConversionService" class="headerlink" title="5.5.5 配置ConversionService"></a>5.5.5 配置ConversionService</h3><p>ConversionService是一个被设计成在应用程序启动时会进行实例化的无状态对象，随后可以在多个线程之间共享。在一个Spring应用程序中，你通常会为每一个Spring容器(或者应用程序上下文ApplicationContext)配置一个ConversionService实例，它会被Spring接收并在框架需要执行一个类型转换时使用。你也可以将这个ConversionService直接注入到你任何的Bean中并直接调用。</p>
<blockquote>
<p>如果Spring没有注册ConversionService，则会使用原始的基于PropertyEditor的系统。</p>
</blockquote>
<p>要向Spring注册默认的ConversionService，可以用<code>conversionService</code>作为id来添加如下的bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></div><div class="line">	<span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>/&gt;</div></pre></td></tr></table></figure>
<p>默认的ConversionService可以在字符串、数字、枚举、映射和其他常见类型之间进行转换。为了使用你自己的自定义转换器来补充或者覆盖默认的转换器，可以设置<code>converters</code>属性，该属性值可以是Converter、ConverterFactory或者GenericConverter之中任何一个的接口实现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></div><div class="line">		<span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.MyCustomConverter"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在一个Spring MVC应用程序中使用ConversionService也是比较常见的，可以去看Spring MVC章节的<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-config-conversion" target="_blank" rel="external">Section 18.16.3 “Conversion and Formatting”</a>。</p>
<p>在某些情况下，你可能希望在转换期间应用格式化，可以看<a href="#5.6.3 FormatterRegistry SPI">5.6.3 “FormatterRegistry SPI”</a>获取使用<code>FormattingConversionServiceFactoryBean</code>的细节。</p>
<h3 id="5-5-6-编程方式使用ConversionService"><a href="#5-5-6-编程方式使用ConversionService" class="headerlink" title="5.5.6 编程方式使用ConversionService"></a>5.5.6 编程方式使用ConversionService</h3><p>要以编程方式使用ConversionService，你只需要像处理其他bean一样注入一个引用即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(ConversionService conversionService)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.conversionService = conversionService;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.conversionService.convert(...)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对大多数用例来说，<code>convert</code>方法指定了可以使用的目标类型，但是它不适用于更复杂的类型比如参数化元素的集合。例如，如果你想要以编程方式将一个<code>Integer</code>的<code>List</code>转换成一个<code>String</code>的<code>List</code>，就需要为原类型和目标类型提供一个正式的定义。</p>
<p>幸运的是，<code>TypeDescriptor</code>提供了多种选项使事情变得简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DefaultConversionService cs = <span class="keyword">new</span> DefaultConversionService();</div><div class="line"></div><div class="line">List&lt;Integer&gt; input = ....</div><div class="line">cs.convert(input,</div><div class="line">	TypeDescriptor.forObject(input), <span class="comment">// List&lt;Integer&gt; type descriptor</span></div><div class="line">	TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));</div></pre></td></tr></table></figure>
<p>注意<code>DefaultConversionService</code>会自动注册对大部分环境都适用的转换器，这其中包括了集合转换器、标量转换器还有基本的<code>Object</code>到<code>String</code>的转换器。可以通过调用<code>DefaultConversionService</code>类上的静态方法<code>addDefaultConverters</code>来向任意的<code>ConverterRegistry</code>注册相同的转换器。</p>
<p>因为值类型的转换器可以被数组和集合重用，所以假设标准集合处理是恰当的，就没有必要创建将一个<code>S</code>的<code>Collection</code>转换成一个<code>T</code>的<code>Collection</code>的特定转换器。</p>
<h2 id="5-6-Spring字段格式化"><a href="#5-6-Spring字段格式化" class="headerlink" title="5.6 Spring字段格式化"></a>5.6 Spring字段格式化</h2><p>如上一节所述，<code>core.convert</code>包是一个通用类型转换系统，它提供了统一的ConversionService API以及强类型的Converter SPI用于实现将一种类型转换成另外一种的转换逻辑。Spring容器使用这个系统来绑定bean属性值，此外，Spring表达式语言(SpEL)和DataBinder也都使用这个系统来绑定字段值。举个例子，当SpEL需要将<code>Short</code>强制转换成<code>Long</code>来完成一次<code>expression.setValue(Object bean, Object value)</code>尝试时，core.convert系统就会执行这个强制转换。</p>
<p>现在让我们考虑一个典型的客户端环境如web或桌面应用程序的类型转换要求，在这样的环境里，你通常会经历将字符串进行转换以支持客户端回传的过程以及转换回字符串以支持视图渲染的过程。此外，你经常需要对字符串值进行本地化。更通用的<em>core.convert</em>包中的Converter SPI不直接解决这种格式化要求。Spring 3为此引入了一个方便的Formatter SPI来直接解决这些问题，这个接口为客户端环境提供一种简单强大并且替代PropertyEditor的方案。</p>
<p>一般来说，当你需要实现通用的类型转换逻辑时请使用Converter SPI，例如，在java.util.Date和java.lang.Long之间进行转换。当你在一个客户端环境(比如web应用程序)工作并且需要解析和打印本地化的字段值时，请使用Formatter SPI。ConversionService接口为这两者提供了一套统一的类型转换API。</p>
<h3 id="5-6-1-Formatter-SPI"><a href="#5-6-1-Formatter-SPI" class="headerlink" title="5.6.1 Formatter SPI"></a>5.6.1 Formatter SPI</h3><p>Formatter SPI实现字段格式化逻辑是简单并且强类型的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formatter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Formatter接口扩展了Printer和Parser这两个基础接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="function">String <span class="title">print</span><span class="params">(T fieldValue, Locale locale)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.text.ParseException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="function">T <span class="title">parse</span><span class="params">(String clientValue, Locale locale)</span> <span class="keyword">throws</span> ParseException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要创建你自己的格式化器，只需要实现上面的Formatter接口。泛型参数T代表你想要格式化的对象的类型，例如，<code>java.util.Date</code>。实现<code>print()</code>操作可以将类型T的实例按客户端区域设置的显示方式打印出来。实现<code>parse()</code>操作可以从依据客户端区域设置返回的格式化表示中解析出类型T的实例。如果解析尝试失败，你的格式化器应该抛出一个ParseException或者IllegalArgumentException。请注意确保你的格式化器实现是线程安全的。</p>
<p>为方便起见，<code>format</code>子包中已经提供了一些格式化器实现。<code>number</code>包提供了<code>NumberFormatter</code>、<code>CurrencyFormatter</code>和<code>PercentFormatter</code>，它们通过使用<code>java.text.NumberFormat</code>来格式化<code>java.lang.Number</code>对象 。<code>datetime</code>包提供了<code>DateFormatter</code>，其通过使用<code>java.text.DateFormat</code>来格式化<code>java.util.Date</code>。<code>datetime.joda</code>包基于<a href="http://www.joda.org/joda-time/" target="_blank" rel="external">Joda Time library</a>提供了全面的日期时间格式化支持。</p>
<p>考虑将<code>DateFormatter</code>作为<code>Formatter</code>实现的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format.datetime;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String pattern;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DateFormatter</span><span class="params">(String pattern)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.pattern = pattern;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">(Date date, Locale locale)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (date == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> getDateFormat(locale).format(date);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String formatted, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</div><div class="line">		<span class="keyword">if</span> (formatted.length() == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> getDateFormat(locale).parse(formatted);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">protected</span> DateFormat <span class="title">getDateFormat</span><span class="params">(Locale locale)</span> </span>&#123;</div><div class="line">		DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="keyword">this</span>.pattern, locale);</div><div class="line">		dateFormat.setLenient(<span class="keyword">false</span>);</div><div class="line">		<span class="keyword">return</span> dateFormat;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring团队欢迎社区驱动的<code>Formatter</code>贡献，可以登陆网站<a href="https://jira.spring.io/browse/SPR" target="_blank" rel="external">jira.spring.io</a>了解如何参与贡献。 </p>
<h3 id="5-6-2-注解驱动的格式化"><a href="#5-6-2-注解驱动的格式化" class="headerlink" title="5.6.2 注解驱动的格式化"></a>5.6.2 注解驱动的格式化</h3><p>如你所见，字段格式化可以通过字段类型或者注解进行配置，要将一个注解绑定到一个格式化器，可以实现AnnotationFormatterFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	Set&lt;Class&lt;?&gt;&gt; getFieldTypes();</div><div class="line"></div><div class="line">	Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);</div><div class="line"></div><div class="line">	Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>泛型参数A代表你想要关联格式化逻辑的字段注解类型，例如<code>org.springframework.format.annotation.DateTimeFormat</code>。让<code>getFieldTypes()</code>方法返回可能使用注解的字段类型，让<code>getPrinter()</code>方法返回一个可以打印被注解字段的值的打印机(Printer)，让<code>getParser()</code>方法返回一个可以解析被注解字段的客户端值的解析器(Parser)。</p>
<p>下面这个AnnotationFormatterFactory实现的示例把@NumberFormat注解绑定到一个格式化器，此注解允许指定数字样式或模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFormatAnnotationFormatterFactory</span></span></div><div class="line">		<span class="keyword">implements</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">NumberFormat</span>&gt; &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;(asList(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;</div><div class="line">			Short.class, Integer.class, Long.class, Float.class,</div><div class="line">			Double.class, BigDecimal.class, BigInteger.class &#125;));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Printer&lt;Number&gt; <span class="title">getPrinter</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Parser&lt;Number&gt; <span class="title">getParser</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> Formatter&lt;Number&gt; <span class="title">configureFormatterFrom</span><span class="params">(NumberFormat annotation,</span></span></div><div class="line">			Class&lt;?&gt; fieldType) &#123;</div><div class="line">		<span class="keyword">if</span> (!annotation.pattern().isEmpty()) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> NumberFormatter(annotation.pattern());</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			Style style = annotation.style();</div><div class="line">			<span class="keyword">if</span> (style == Style.PERCENT) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> PercentFormatter();</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (style == Style.CURRENCY) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> CurrencyFormatter();</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> NumberFormatter();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要触发格式化，只需要使用@NumberFormat对字段进行注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyModel</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@NumberFormat</span>(style=Style.CURRENCY)</div><div class="line">	<span class="keyword">private</span> BigDecimal decimal;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Format-Annotation-API"><a href="#Format-Annotation-API" class="headerlink" title="Format Annotation API"></a>Format Annotation API</h4><p><code>org.springframework.format.annotation</code>包中存在一套可移植(portable)的格式化注解API。请使用@NumberFormat格式化java.lang.Number字段，使用@DateTimeFormat格式化java.util.Date、java.util.Calendar、java.util.Long(注：此处可能是原文错误，应为java.lang.Long)或者Joda Time字段。</p>
<p>下面这个例子使用@DateTimeFormat将java.util.Date格式化为ISO时间(yyyy-MM-dd)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyModel</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@DateTimeFormat</span>(iso=ISO.DATE)</div><div class="line">	<span class="keyword">private</span> Date date;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><span id="5.6.3 FormatterRegistry SPI"></span></p>
<h3 id="5-6-3-FormatterRegistry-SPI"><a href="#5-6-3-FormatterRegistry-SPI" class="headerlink" title="5.6.3 FormatterRegistry SPI"></a>5.6.3 FormatterRegistry SPI</h3><p>FormatterRegistry是一个用于注册格式化器和转换器的服务提供接口(SPI)。<code>FormattingConversionService</code>是一个适用于大多数环境的FormatterRegistry实现，可以以编程方式或利用<code>FormattingConversionServiceFactoryBean</code>声明成Spring bean的方式来进行配置。由于它也实现了<code>ConversionService</code>，所以可以直接配置它与Spring的DataBinder以及Spring表达式语言(SpEL)一起使用。</p>
<p>请查看下面的FormatterRegistry SPI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistry</span> <span class="keyword">extends</span> <span class="title">ConverterRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Formatter&lt;?&gt; formatter)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFormatterForAnnotation</span><span class="params">(AnnotationFormatterFactory&lt;?, ?&gt; factory)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上所示，格式化器可以通过字段类型或者注解进行注册。</p>
<p>FormatterRegistry SPI允许你集中地配置格式化规则，而不是在你的控制器之间重复这样的配置。例如，你可能要强制所有的时间字段以某种方式被格式化，或者是带有特定注解的字段以某种方式被格式化。通过一个共享的FormatterRegistry，你可以只定义这些规则一次，而在需要格式化的时候应用它们。</p>
<h3 id="5-6-4-FormatterRegistrar-SPI"><a href="#5-6-4-FormatterRegistrar-SPI" class="headerlink" title="5.6.4 FormatterRegistrar SPI"></a>5.6.4 FormatterRegistrar SPI</h3><p>FormatterRegistrar是一个通过FormatterRegistry注册格式化器和转换器的服务提供接口(SPI)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.format;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistrar</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerFormatters</span><span class="params">(FormatterRegistry registry)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当要为一个给定的格式化类别(比如时间格式化)注册多个关联的转换器和格式化器时，FormatterRegistrar会非常有用。</p>
<p>下一部分提供了更多关于转换器和格式化器注册的信息。</p>
<h3 id="5-6-5-在Spring-MVC中配置格式化"><a href="#5-6-5-在Spring-MVC中配置格式化" class="headerlink" title="5.6.5 在Spring MVC中配置格式化"></a>5.6.5 在Spring MVC中配置格式化</h3><p>请查看Spring MVC章节的<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-config-conversion" target="_blank" rel="external">Section 18.16.3 “Conversion and Formatting”</a>。 </p>
<h2 id="5-7-配置一个全局的日期-amp-时间格式"><a href="#5-7-配置一个全局的日期-amp-时间格式" class="headerlink" title="5.7 配置一个全局的日期&amp;时间格式"></a>5.7 配置一个全局的日期&amp;时间格式</h2><p>默认情况下，未被<code>@DateTimeFormat</code>注解的日期和时间字段会使用<code>DateFormat.SHORT</code>风格从字符串转换。如果你愿意，你可以定义你自己的全局格式来改变这种默认行为。</p>
<p>你将需要确保Spring不会注册默认的格式化器，取而代之的是你应该手动注册所有的格式化器。请根据你是否依赖Joda Time库来确定是使用<code>org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</code>类还是<code>org.springframework.format.datetime.DateFormatterRegistrar</code>类。</p>
<p>例如，下面的Java配置会注册一个全局的’yyyyMMdd’格式，这个例子不依赖于Joda Time库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Bean</span></div><div class="line">	<span class="function"><span class="keyword">public</span> FormattingConversionService <span class="title">conversionService</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">// Use the DefaultFormattingConversionService but do not register defaults</span></div><div class="line">		DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">		<span class="comment">// Ensure @NumberFormat is still supported</span></div><div class="line">		conversionService.addFormatterForFieldAnnotation(<span class="keyword">new</span> NumberFormatAnnotationFormatterFactory());</div><div class="line"></div><div class="line">		<span class="comment">// Register date conversion with a specific global format</span></div><div class="line">		DateFormatterRegistrar registrar = <span class="keyword">new</span> DateFormatterRegistrar();</div><div class="line">		registrar.setFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">"yyyyMMdd"</span>));</div><div class="line">		registrar.registerFormatters(conversionService);</div><div class="line"></div><div class="line">		<span class="keyword">return</span> conversionService;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你更喜欢基于XML的配置，你可以使用一个<code>FormattingConversionServiceFactoryBean</code>，这是同一个例子，但这次使用了Joda Time：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">		http://www.springframework.org/schema/beans</div><div class="line">		http://www.springframework.org/schema/beans/spring-beans.xsd&gt;</div><div class="line"></div><div class="line">	&lt;bean id="<span class="attr">conversionService</span>" <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"registerDefaultFormatters"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"formatters"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.number.NumberFormatAnnotationFormatterFactory"</span> /&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"formatterRegistrars"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormatter"</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean"</span>&gt;</span></div><div class="line">							<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"yyyyMMdd"</span>/&gt;</span></div><div class="line">						<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">					<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Joda Time提供了不同的类型来表示<code>date</code>、<code>time</code>和<code>date-time</code>的值，<code>JodaTimeFormatterRegistrar</code>中的<code>dateFormatter</code>、<code>timeFormatter</code>和<code>dateTimeFormatter</code>属性应该为每种类型配置不同的格式。<code>DateTimeFormatterFactoryBean</code>提供了一种方便的方式来创建格式化器。</p>
</blockquote>
<p>如果你在使用Spring MVC，请记住要明确配置所使用的转换服务。针对基于<code>@Configuration</code>的Java配置方式这意味着要继承<code>WebMvcConfigurationSupport</code>并且覆盖<code>mvcConversionService()</code>方法。针对XML的方式，你应该使用<code>mvc:annotation-drive</code>元素的<code>&#39;conversion-service&#39;</code>属性。更多细节请看<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-config-conversion" target="_blank" rel="external">Section 18.16.3 “Conversion and Formatting”</a>。 </p>
<p><span id="5.8 Spring Validation"></span></p>
<h2 id="5-8-Spring验证"><a href="#5-8-Spring验证" class="headerlink" title="5.8 Spring验证"></a>5.8 Spring验证</h2><p>Spring  3对验证支持引入了几个增强功能。首先，现在全面支持JSR-303 Bean Validation API；其次，当采用编程方式时，Spring的DataBinder现在不仅可以绑定对象还能够验证它们；最后，Spring MVC现在已经支持声明式地验证<code>@Controller</code>的输入。</p>
<h3 id="5-8-1-JSR-303-Bean-Validation-API概述"><a href="#5-8-1-JSR-303-Bean-Validation-API概述" class="headerlink" title="5.8.1 JSR-303 Bean Validation API概述"></a>5.8.1 JSR-303 Bean Validation API概述</h3><p>JSR-303对Java平台的验证约束声明和元数据进行了标准化定义。使用此API，你可以用声明性的验证约束对领域模型的属性进行注解，并在运行时强制执行它们。现在已经有一些内置的约束供你使用，当然你也可以定义你自己的自定义约束。</p>
<p>为了说明这一点，考虑一个拥有两个属性的简单的PersonForm模型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonForm</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JSR-303允许你针对这些属性定义声明性的验证约束：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonForm</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@NotNull</span></div><div class="line">	<span class="meta">@Size</span>(max=<span class="number">64</span>)</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="meta">@Min</span>(<span class="number">0</span>)</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当此类的一个实例被实现JSR-303规范的验证器进行校验的时候，这些约束就会被强制执行。</p>
<p>有关JSR-303/JSR-349的一般信息，可以访问网站<a href="http://beanvalidation.org/" target="_blank" rel="external">Bean Validation website</a>去查看。有关默认参考实现的具体功能的信息，可以参考网站<a href="http://hibernate.org/validator/" target="_blank" rel="external">Hibernate Validator</a>的文档。想要了解如何将Bean验证器提供程序设置为Spring bean，请继续保持阅读。</p>
<h3 id="5-8-2-配置Bean验证器提供程序"><a href="#5-8-2-配置Bean验证器提供程序" class="headerlink" title="5.8.2 配置Bean验证器提供程序"></a>5.8.2 配置Bean验证器提供程序</h3><p>Spring提供了对Bean Validation API的全面支持，这包括将实现JSR-303/JSR-349规范的Bean验证提供程序引导为Spring Bean的方便支持。这样就允许在应用程序任何需要验证的地方注入<code>javax.validation.ValidatorFactory</code>或者<code>javax.validation.Validator</code>。</p>
<p>把<code>LocalValidatorFactoryBean</code>当作Spring bean来配置成默认的验证器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"validator"</span></span></div><div class="line">	<span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"</span>/&gt;</div></pre></td></tr></table></figure>
<p>以上的基本配置会触发Bean Validation使用它默认的引导机制来进行初始化。作为实现JSR-303/JSR-349规范的提供程序，如Hibernate Validator，可以存在于类路径以使它能被自动检测到。</p>
<h4 id="注入验证器"><a href="#注入验证器" class="headerlink" title="注入验证器"></a>注入验证器</h4><p><code>LocalValidatorFactoryBean</code>实现了<code>javax.validation.ValidatorFactory</code>和<code>javax.validation.Validator</code>这两个接口，以及Spring的<code>org.springframework.validation.Validator</code>接口，你可以将这些接口当中的任意一个注入到需要调用验证逻辑的Bean里。</p>
<p>如果你喜欢直接使用Bean Validtion API，那么就注入<code>javax.validation.Validator</code>的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.validation.Validator;</div><div class="line"></div><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="keyword">private</span> Validator validator;</div></pre></td></tr></table></figure>
<p>如果你的Bean需要Spring Validation API，那么就注入<code>org.springframework.validation.Validator</code>的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.validation.Validator;</div><div class="line"></div><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="keyword">private</span> Validator validator;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="配置自定义约束"><a href="#配置自定义约束" class="headerlink" title="配置自定义约束"></a>配置自定义约束</h4><p>每一个Bean验证约束由两部分组成，第一部分是声明了约束和其可配置属性的<code>@Constraint</code>注解，第二部分是实现约束行为的<code>javax.validation.ConstraintValidator</code>接口实现。为了将声明与实现关联起来，每个<code>@Constraint</code>注解会引用一个相应的验证约束的实现类。在运行期间，<code>ConstraintValidatorFactory</code>会在你的领域模型遇到约束注解的情况下实例化被引用到的实现。</p>
<p>默认情况下，<code>LocalValidatorFactoryBean</code>会配置一个<code>SpringConstraintValidatorFactory</code>，其使用Spring来创建约束验证器实例。这允许你的自定义约束验证器可以像其他Spring bean一样从依赖注入中受益。</p>
<p>下面显示了一个自定义的<code>@Constraint</code>声明的例子，紧跟着是一个关联的<code>ConstraintValidator</code>实现，其使用Spring进行依赖注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.FIELD&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Constraint</span>(validatedBy=MyConstraintValidator.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyConstraint &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span>;</div><div class="line">	<span class="keyword">private</span> Foo aDependency;</div><div class="line"></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所见，一个约束验证器实现可以像其他Spring bean一样使用@Autowired注解来自动装配它的依赖。</p>
<h4 id="Spring驱动的方法验证"><a href="#Spring驱动的方法验证" class="headerlink" title="Spring驱动的方法验证"></a>Spring驱动的方法验证</h4><p>被Bean Validation 1.1以及作为Hibernate Validator 4.3中的自定义扩展所支持的方法验证功能可以通过配置<code>MethodValidationPostProcessor</code>的bean定义集成到Spring的上下文中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.MethodValidationPostProcessor"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>为了符合Spring驱动的方法验证，需要对所有目标类用Spring的<code>@Validated</code>注解进行注解，且有选择地对其声明验证组，这样才可以使用。请查阅<code>MethodValidationPostProcessor</code>的java文档来了解针对Hibernate Validator和Bean Validation 1.1提供程序的设置细节。</p>
<h4 id="附加配置选项"><a href="#附加配置选项" class="headerlink" title="附加配置选项"></a>附加配置选项</h4><p>对于大多数情况，默认的<code>LocalValidatorFactoryBean</code>配置应该足够。有许多配置选项来处理从消息插补到遍历解析的各种Bean验证结构。请查看<code>LocalValidatorFactoryBean</code>的java文档来获取关于这些选项的更多信息。</p>
<p><span id="5.8.3 Configuring a DataBinder"></span></p>
<h3 id="5-8-3-配置DataBinder"><a href="#5-8-3-配置DataBinder" class="headerlink" title="5.8.3 配置DataBinder"></a>5.8.3 配置DataBinder</h3><p>从Spring 3开始，DataBinder的实例可以配置一个验证器。一旦配置完成，那么可以通过调用<code>binder.validate()</code>来调用验证器，任何的验证错误都会自动添加到DataBinder的绑定结果(BindingResult)。</p>
<p>当以编程方式处理DataBinder时，可以在绑定目标对象之后调用验证逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Foo target = <span class="keyword">new</span> Foo();</div><div class="line">DataBinder binder = <span class="keyword">new</span> DataBinder(target);</div><div class="line">binder.setValidator(<span class="keyword">new</span> FooValidator());</div><div class="line"></div><div class="line"><span class="comment">// bind to the target object</span></div><div class="line">binder.bind(propertyValues);</div><div class="line"></div><div class="line"><span class="comment">// validate the target object</span></div><div class="line">binder.validate();</div><div class="line"></div><div class="line"><span class="comment">// get BindingResult that includes any validation errors</span></div><div class="line">BindingResult results = binder.getBindingResult();</div></pre></td></tr></table></figure>
<p>通过<code>dataBinder.addValidators</code>和<code>dataBinder.replaceValidators</code>，一个DataBinder也可以配置多个<code>Validator</code>实例。当需要将全局配置的Bean验证与一个DataBinder实例上局部配置的Spring <code>Validator</code>结合时，这一点是非常有用的。</p>
<h3 id="5-8-4-Spring-MVC-3-验证"><a href="#5-8-4-Spring-MVC-3-验证" class="headerlink" title="5.8.4 Spring MVC 3 验证"></a>5.8.4 Spring MVC 3 验证</h3><p>请查看Spring MVC章节的<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-config-validation" target="_blank" rel="external">Section 18.16.4 “Validation”</a>。 </p>
</div></article><div class="tags"><a href="/tags/Spring/">Spring</a></div><div class="paginator"><a href="/2017/05/15/Spring-BeanPostProcessor/" class="prev"><i class="iconfont icon-left"></i><span> Prev</span></a><a href="/2016/11/17/Reading-JDK-ArrayList/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div id="disqus_thread"></div></section><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://lukaicheng.github.io/2017/05/13/Spring5-validation-translate/';
    this.page.identifier = '2017/05/13/Spring5-validation-translate/';
    this.page.title = 'Spring 5 验证、数据绑定和类型转换[译]';
};
(function() {
var d = document, s = d.createElement('script');

s.src = '//Your disqus ID.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();</script></section><footer><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2017<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Lucifer</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>