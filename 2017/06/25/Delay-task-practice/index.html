<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Lucifer"><meta name="description" content="背景在实际开发项目过程中，可能会碰到类似这样的需求：期望一个任务不是马上执行，而是可以在给定的时间段之后才执行，通常这被称为延迟任务。解决这个问题的方案已经有不少，最直接的是采用定时任务的方式扫描数据库，或者考虑使用时间轮算法，或者基于RabbitMQ来实现延迟队列。最近我在项目"><meta name="keywords" content="DelayQueue,Redis"><title>延迟任务实践总结 · 羽逝神伤</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="https://lukaicheng.github.io/2017/06/25/Delay-task-practice/"><link rel="alternate" href="/atom.xml" title="羽逝神伤"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">羽逝神伤</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">延迟任务实践总结</h1><span class="post-time">Jun 25, 2017</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Contents</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景"><span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于DelayQueue实现延迟队列"><span class="toc-text">基于DelayQueue实现延迟队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于Redis实现延迟队列"><span class="toc-text">基于Redis实现延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设计思路"><span class="toc-text">设计思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#背后考虑"><span class="toc-text">背后考虑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在实际开发项目过程中，可能会碰到类似这样的需求：期望一个任务不是马上执行，而是可以在给定的时间段之后才执行，通常这被称为<strong>延迟任务</strong>。解决这个问题的方案已经有不少，最直接的是采用定时任务的方式扫描数据库，或者考虑使用时间轮算法，或者基于RabbitMQ来实现延迟队列。最近我在项目中就碰到了同样的问题：当新内容添加到系统时，会带有一个过期时间，一旦到达此过期时间，那么需要自动下架该内容。对于此问题，在实际项目演变过程中我采用了与上述不同的两种方式来解决。</p>
<a id="more"></a>
<h2 id="基于DelayQueue实现延迟队列"><a href="#基于DelayQueue实现延迟队列" class="headerlink" title="基于DelayQueue实现延迟队列"></a>基于DelayQueue实现延迟队列</h2><p>由于项目最开始服务器资源较为紧张，初步预估先采用单实例部署，故最初想到的方案是使用JDK自带的<code>java.util.concurrent.DelayQueue</code>来实现。<code>DelayQueue</code>实质上是一个<strong>无界的带有优先级的阻塞队列</strong>，其包含的元素必须实现<code>java.util.concurrent.Delayed</code>接口(<em>实际由内部的<code>PriorityQueue</code>持有元素</em>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合实际问题，创建出具体的<code>DelayTask</code>类，它包含过期时间和任务唯一标识，其中，过期时间会参与到方法<code>compareTo</code>和<code>getDelay</code>的实现，而任务唯一标识除了用于表达任务的唯一性，还用于后续获取该任务的相关信息，从而进行实际的业务处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</div><div class="line">    <span class="comment">//任务唯一标识</span></div><div class="line">    <span class="keyword">private</span> String uniqueIdentity;</div><div class="line">    <span class="comment">//过期时间</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTime;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedTask</span><span class="params">(String uniqueIdentity, <span class="keyword">long</span> expireTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.uniqueIdentity = uniqueIdentity;</div><div class="line">        <span class="keyword">this</span>.expireTime = expireTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//在插入优先队列时被调用，以决定元素具体的插入位置</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.expireTime &lt; ((DelayedTask) o).expireTime)</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.expireTime &gt; ((DelayedTask) o).expireTime)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//当前时间减去过期时间，假如小于等于零，则表示该任务已过去</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> unit.convert(expireTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUniqueIdentity</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> uniqueIdentity;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来基于生产者-消费者模式，使用Spring的<code>@Service</code>注解来定义一个延迟队列的单例，这样可以方便我们在多个生产者和消费者之间共享同一个延迟队列。这个类里我们定义了一个任务入队方法<code>enqueue</code>和任务出队<code>dequeue</code>方法，其中后者实际使用<code>DelayQueue.take</code>获取超时任务，如果队列暂时没有任务超时将会导致线程阻塞，因此实际消费者必须在单独线程中获取任务以免影响主线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentDelayQueue</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//延迟队列</span></div><div class="line">    <span class="keyword">private</span> DelayQueue&lt;DelayedTask&gt; queue = <span class="keyword">new</span> DelayQueue&lt;DelayedTask&gt;();</div><div class="line"></div><div class="line">    <span class="comment">//将需要延迟处理的对象放入队列</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(DelayedTask task)</span> </span>&#123;</div><div class="line">        queue.offer(task);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//返回将要超时的对象，如果暂时没有，则会进行阻塞，因此建议在一个独立的线程中进行处理</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DelayedTask <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.take();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后还有一点需要注意，使用这种方式实现的延迟队列，当程序运行时数据存在于内存之中，一旦程序停止，整个队列的数据就会消失，因此需要有一个初始化行为保证在程序重启之后可以从数据库获取信息恢复原来的延迟队列。如果使用了Spring的话，可以考虑实现<code>InitializingBean</code>接口，把初始化行为放在<code>afterPropertiesSet</code>方法里实现。</p>
<h2 id="基于Redis实现延迟队列"><a href="#基于Redis实现延迟队列" class="headerlink" title="基于Redis实现延迟队列"></a>基于Redis实现延迟队列</h2><p>尽管采用<code>DelayQueue</code>可以实现延迟任务的处理，然而如果需要部署多个程序实例，不经过修改是无法满足需求的，但是如果要修改可能并不是一件简单的事情。于是随着项目推进，分布式环境下实现延迟队列这个问题摆在了我的面前。由于之前没有引入RabbitMQ，现有组件只有Redis和Kafka，经过研究，最终决定利用Redis实现分布式环境下的的延迟队列方案。</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>参考网上已有的方案(<a href="https://redislabs.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-4-task-queues/6-4-2-delayed-tasks/" target="_blank" rel="external">Delayd tasks</a>)，并结合项目实际情况，确定了最终的总体设计思路，如下所述：</p>
<ol>
<li>以任务过期时间毫秒数作为分值，将延迟任务添加到Redis Sorted Set，从而使得任务可以根据过期时间的先后顺序进行排序。</li>
<li>利用Redis Sorted Set的<code>ZRANGEBYSCORE</code>命令，获取分值在零至当前时间之间的任务(即已经到期的延迟任务)，接着将其插入到Redis Set。</li>
<li>利用Redis Set的<code>SPOP</code>命令可以获取并移除Set上的一个到期的延迟任务，处理完业务逻辑之后，再使用Redis Sorted Set的<code>ZREM</code>命令移除原始的延迟任务。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>对于延迟任务的定义，依然沿用上一节的思路，只不过这次不需要实现<code>Delayed</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//任务唯一标识</span></div><div class="line">    <span class="keyword">private</span> String uniqueIdentity;</div><div class="line">    <span class="comment">//过期时间毫秒数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTime;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedTask</span><span class="params">(String uniqueIdentity, <span class="keyword">long</span> expireTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.uniqueIdentity = uniqueIdentity;</div><div class="line">        <span class="keyword">this</span>.expireTime = expireTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUniqueIdentity</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> uniqueIdentity;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpireTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> expireTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExpireTime</span><span class="params">(<span class="keyword">long</span> expireTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.expireTime = expireTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先实现步骤1，将任务添加到Redis有序集合。由于项目使用的Redis是集群方式配置，因此这里连接Redis的API使用的是Jedis库的<code>JedisCluster</code>，注意分值是过期时间，对应内容是延迟任务对象格式化成JSON之后的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTaskProducer</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(DelayedTaskProducer.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SORTED_SET = <span class="string">"SortedSetForDelayedTask"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SET = <span class="string">"SetForDelayedTask"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JedisCluster client;</div><div class="line">    <span class="comment">//用于将对象格式化成JSON字符串</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDelayedTask</span><span class="params">(String uniqueIdentitfy, <span class="keyword">long</span> expireTime)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//构建延迟任务</span></div><div class="line">        DelayedTask task = <span class="keyword">new</span> DelayedTask(uniqueIdentitfy, expireTime);</div><div class="line">        <span class="comment">//以过期时间为分值，将延迟任务添加到Redis有序集合</span></div><div class="line">        client.zadd(KEY_SORTED_SET, expireTime, mapper.writeValueAsString(task));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TransferWorker(), <span class="string">"DelayTaskTransferThread"</span>);</div><div class="line">        t1.start();</div><div class="line">        LOGGER.info(<span class="string">"DelayTaskTransferThread Start"</span>);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FinishWorker(), <span class="string">"DelayTaskFinishThread"</span>);</div><div class="line">        t2.start();</div><div class="line">        LOGGER.info(<span class="string">"DelayTaskFinishThread Start"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着是步骤2的实现代码，在实际项目实现中，我定义了一个内部类<code>TransferWorker</code>，它实现了<code>Runnable</code>接口，可以单独运行在一个线程中。主要工作就是根据<code>zrangeByScore</code>命令获取已经到期的延迟任务，并将它们转移到另外一个Redis集合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//从Redis Sorted Set获取已经过去的延迟任务</span></div><div class="line">                Set&lt;String&gt; set = client.zrangeByScore(KEY_SORTED_SET, <span class="number">0</span>,</div><div class="line">                        System.currentTimeMillis());</div><div class="line">                <span class="keyword">if</span> (set.isEmpty()) &#123;</div><div class="line">                    <span class="comment">//可以做成配置</span></div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">30</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                String[] members = <span class="keyword">new</span> String[set.size()];</div><div class="line">                set.toArray(members);</div><div class="line">                <span class="comment">//将过去的延迟任务添加到Redis Set</span></div><div class="line">                client.sadd(KEY_SET, members);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                LOGGER.error(e.getMessage(), e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后是步骤3的代码实现，同步骤2的做法一样，我也将<code>FinishWorker</code>定义为内部类，并实现了<code>Runnable</code>接口。它会从Redis集合中获取延迟任务，并将其移除，随后根据任务信息进行业务处理，最终如果一切顺利，那么会把原始任务从Redis有序集合中移除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FinishWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//从Redis Set获取一个延迟任务，并将其从Set中移除</span></div><div class="line">                String any = client.spop(KEY_SET);</div><div class="line">                <span class="keyword">if</span> (any == <span class="keyword">null</span> || any.trim().isEmpty()) &#123;</div><div class="line">                    <span class="comment">//可以做成配置</span></div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                DelayedTask task = mapper.readValue(any, DelayedTask.class);</div><div class="line">                <span class="comment">//省略业务处理代码...</span></div><div class="line">                </div><div class="line">                <span class="comment">//将原始的延迟任务从Redis Sorted Set中移除</span></div><div class="line">                client.zrem(KEY_SORTED_SET, any);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                LOGGER.error(e.getMessage(), e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我让<code>DelayedTaskProducer</code>实现<code>InitializingBean</code>接口，这样在初始化时，可以启动<code>TransferWork</code>和<code>FinishWorker</code>这两个线程任务。当然也可以将<code>TransferWork</code>和<code>FinishWorkder</code>提取出来，声明成非内部类，并在另外的地方启动它们。另外，由于这仅仅只是示例，所以在代码里只各启动了一个线程，然而在实际情况下，需要根据任务量来最终确定两种任务启动的线程数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TransferWorker(), <span class="string">"DelayTaskTransferThread"</span>);</div><div class="line">    t1.start();</div><div class="line">    LOGGER.info(<span class="string">"DelayTaskTransferThread Start"</span>);</div><div class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FinishWorker(), <span class="string">"DelayTaskFinishThread"</span>);</div><div class="line">    t2.start();</div><div class="line">    LOGGER.info(<span class="string">"DelayTaskFinishThread Start"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="背后考虑"><a href="#背后考虑" class="headerlink" title="背后考虑"></a>背后考虑</h3><p>最后再来总结一下整个设计过程中的一些考虑：</p>
<ul>
<li>最重要的一点是业务处理过程需要满足<strong>幂等性</strong>。</li>
<li>对程序异常有一定容忍，允许重试。</li>
<li>由于将移除有序集合的原始任务放在最后，因此即使前面的步骤发生异常，也可以通过重新加载有序集合的原始任务进行重试。</li>
<li>使用Set作为中转的原因是期望同一个任务只被一个线程消费，用<code>SPOP</code>命令可以实现。当然List也能满足这一点，但最终使用Set的原因是为了避免步骤2中多个程序实例的线程插入相同的任务。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://redislabs.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-4-task-queues/6-4-2-delayed-tasks/" target="_blank" rel="external">Delayd tasks</a></p>
</div></article><div class="tags"><a href="/tags/DelayQueue/">DelayQueue</a><a href="/tags/Redis/">Redis</a></div><div class="paginator"><a href="/2017/06/24/Java-serialization-mechanism/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div id="disqus_thread"></div></section><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://lukaicheng.github.io/2017/06/25/Delay-task-practice/';
    this.page.identifier = '2017/06/25/Delay-task-practice/';
    this.page.title = '延迟任务实践总结';
};
(function() {
var d = document, s = d.createElement('script');

s.src = '//Your disqus ID.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();</script></section><footer><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2017<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Lucifer</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>